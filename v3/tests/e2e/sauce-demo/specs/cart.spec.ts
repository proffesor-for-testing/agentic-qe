import { test, expect } from '@playwright/test';
import { CartPage, ProductPage, HomePage } from '../pages';
import { TestData } from '../fixtures/test-data';

/**
 * Cart Page E2E Tests
 * Test Suite: View Cart and Cart Management Flow
 *
 * QE Assessment: sauce-demo.myshopify.com
 * Generated by: QE Queen Coordinator - qe-test-architect domain
 *
 * Coverage:
 * - Empty cart state
 * - Cart with items
 * - Quantity updates
 * - Item removal
 * - Cart totals calculation
 * - Proceed to checkout
 */

test.describe('Cart Page - View and Manage Cart', () => {
  let cartPage: CartPage;

  test.beforeEach(async ({ page }) => {
    cartPage = new CartPage(page);
  });

  test.describe('Empty Cart State', () => {
    test('should show empty cart message when no items', async ({ page }) => {
      await cartPage.goto();
      await cartPage.assertCartPageLoaded();

      const isEmpty = await cartPage.isEmpty();
      expect(isEmpty).toBe(true);
    });

    test('should display continue shopping link on empty cart', async ({ page }) => {
      await cartPage.goto();

      await expect(cartPage.continueShoppingLink).toBeVisible();
    });

    test('should not show checkout button on empty cart', async ({ page }) => {
      await cartPage.goto();

      // Checkout should be hidden or disabled
      const checkoutVisible = await cartPage.checkoutButton.isVisible().catch(() => false);
      if (checkoutVisible) {
        await expect(cartPage.checkoutButton).toBeDisabled();
      }
    });
  });

  test.describe('Cart with Items', () => {
    test.beforeEach(async ({ page }) => {
      // Add a product to cart first
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.assertProductPageLoaded();
      await productPage.addToCart();

      // Navigate to cart
      await cartPage.goto();
    });

    test('should display cart items', async () => {
      await cartPage.assertHasItems();

      const itemCount = await cartPage.getItemCount();
      expect(itemCount).toBeGreaterThan(0);
    });

    test('should display item titles', async () => {
      const titles = await cartPage.getItemTitles();
      expect(titles.length).toBeGreaterThan(0);
      expect(titles[0]).toBeTruthy();
    });

    test('should display cart subtotal', async () => {
      const subtotal = await cartPage.getSubtotal();
      expect(subtotal).toMatch(/£\d+/);
    });

    test('should display checkout button', async () => {
      await expect(cartPage.checkoutButton).toBeVisible();
      await expect(cartPage.checkoutButton).toBeEnabled();
    });
  });

  test.describe('Quantity Management', () => {
    test.beforeEach(async ({ page }) => {
      // Add a product to cart
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.addToCart();
      await cartPage.goto();
    });

    test('should update quantity in cart', async ({ page }) => {
      const initialSubtotal = await cartPage.getSubtotal();

      await cartPage.updateQuantity(0, 2);
      await page.waitForTimeout(1000);

      const newSubtotal = await cartPage.getSubtotal();

      // Price should change (double for quantity 2)
      expect(newSubtotal).not.toBe(initialSubtotal);
    });

    test('should remove item when quantity set to 0', async ({ page }) => {
      await cartPage.updateQuantity(0, 0);
      await page.waitForTimeout(1000);

      const isEmpty = await cartPage.isEmpty();
      expect(isEmpty).toBe(true);
    });
  });

  test.describe('Item Removal', () => {
    test.beforeEach(async ({ page }) => {
      // Add a product to cart
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.addToCart();
      await cartPage.goto();
    });

    test('should remove single item from cart', async () => {
      await cartPage.assertHasItems();

      await cartPage.removeItem(0);

      const isEmpty = await cartPage.isEmpty();
      expect(isEmpty).toBe(true);
    });

    test('should clear entire cart', async ({ page }) => {
      // Add another product
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').nth(1).click();
      await productPage.addToCart();
      await cartPage.goto();

      await cartPage.clearCart();
      await cartPage.assertIsEmpty();
    });
  });

  test.describe('Multiple Products', () => {
    test('should handle multiple different products', async ({ page }) => {
      const productPage = new ProductPage(page);

      // Add first product
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.addToCart();

      // Add second product
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').nth(1).click();
      await productPage.addToCart();

      // Go to cart
      await cartPage.goto();

      const itemCount = await cartPage.getItemCount();
      expect(itemCount).toBe(2);
    });

    test('should calculate correct total for multiple items', async ({ page }) => {
      const productPage = new ProductPage(page);

      // Add two of the same product
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.setQuantity(2);
      await productPage.addToCart();

      await cartPage.goto();

      const subtotal = await cartPage.getSubtotal();
      // Verify subtotal is present and in GBP
      expect(subtotal).toMatch(/£\d+/);
    });
  });

  test.describe('Navigation', () => {
    test('should navigate to checkout from cart', async ({ page }) => {
      // Add a product
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.addToCart();

      await cartPage.goto();
      await cartPage.proceedToCheckout();

      // Should be on checkout page (Shopify hosted)
      await expect(page).toHaveURL(/.*checkout.*/);
    });

    test('should continue shopping from cart', async ({ page }) => {
      await cartPage.goto();
      await cartPage.continueShopping();

      // Should navigate away from cart
      await expect(page).not.toHaveURL(/.*\/cart$/);
    });
  });

  test.describe('Cart Persistence', () => {
    test('should persist cart across page navigation', async ({ page }) => {
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.addToCart();

      // Navigate around
      await page.goto('/');
      await page.goto('/collections/frontpage');

      // Cart should still have items
      await cartPage.goto();
      await cartPage.assertHasItems();
    });

    test('should persist cart after browser refresh', async ({ page }) => {
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.addToCart();

      await cartPage.goto();
      const itemsBefore = await cartPage.getItemCount();

      await page.reload();

      const itemsAfter = await cartPage.getItemCount();
      expect(itemsAfter).toBe(itemsBefore);
    });
  });

  test.describe('Cart Edge Cases', () => {
    test('should handle very large quantities', async ({ page }) => {
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.setQuantity(99);
      await productPage.addToCart();

      await cartPage.goto();

      // Should either accept or show error, but not crash
      await expect(page).not.toHaveTitle(/error/i);
    });

    test('should handle direct cart URL access', async ({ page }) => {
      await page.goto('/cart');

      await cartPage.assertCartPageLoaded();
    });
  });
});

/**
 * Agentic QE v3 - Morphogenetic Test Generation
 * ADR-047: MinCut Self-Organizing QE Integration - Phase 3
 *
 * Implements biologically-inspired test generation that grows test coverage
 * organically, mimicking how organisms develop through morphogenetic fields.
 *
 * Key Concepts:
 * - MorphogeneticField: Represents growth potential across the codebase
 * - GrowthPattern: Defines how tests propagate (radial, branching, adaptive)
 * - TestSeed: Starting points for test generation at coverage gaps
 * - MorphogeneticController: Orchestrates the growth cycle
 *
 * The system:
 * 1. Plants seeds at weak vertices (low coverage / high risk)
 * 2. Grows tests outward following code dependencies
 * 3. Prunes redundant or flaky tests
 * 4. Harvests mature test specifications
 *
 * Reference: Biological morphogenesis patterns applied to software testing
 */

import { v4 as uuidv4 } from 'uuid';
import { DomainName } from '../../shared/types';
import { SwarmGraph } from './swarm-graph';
import { MinCutCalculator, createMinCutCalculator } from './mincut-calculator';
import { CausalGraph } from './causal-discovery';
import { StrangeLoopController } from './strange-loop';
import { WeakVertex, SwarmVertex } from './interfaces';

// ============================================================================
// Types & Interfaces
// ============================================================================

/**
 * Growth pattern determines how tests propagate from seeds
 */
export type GrowthPattern = 'radial' | 'branching' | 'adaptive';

/**
 * Test specification generated by morphogenetic growth
 */
export interface TestSpecification {
  /** Unique identifier */
  readonly id: string;

  /** Test name */
  readonly name: string;

  /** Target file/module to test */
  readonly targetPath: string;

  /** Test type */
  readonly type: 'unit' | 'integration' | 'e2e' | 'property';

  /** Description of what to test */
  readonly description: string;

  /** Priority based on coverage gap severity */
  readonly priority: number;

  /** Seed that generated this test */
  readonly seedId: string;

  /** Generation (distance from seed) */
  readonly generation: number;

  /** Estimated complexity (1-10) */
  readonly complexity: number;

  /** Related tests (for grouping) */
  readonly relatedTests: string[];

  /** Mutation rules for property tests */
  readonly mutationRules?: MutationRule[];

  /** Creation timestamp */
  readonly createdAt: Date;

  /** Status in the growth cycle */
  status: 'growing' | 'mature' | 'pruned' | 'harvested';
}

/**
 * Mutation rule for property-based test generation
 */
export interface MutationRule {
  /** Target property/parameter */
  readonly target: string;

  /** Mutation type */
  readonly mutationType: 'boundary' | 'random' | 'null' | 'type-change' | 'sequence';

  /** Constraints on mutation */
  readonly constraints?: Record<string, unknown>;
}

/**
 * Test seed - starting point for test generation
 */
export interface TestSeed {
  /** Unique identifier */
  readonly id: string;

  /** Source weak vertex */
  readonly sourceVertexId: string;

  /** Target path/module */
  readonly targetPath: string;

  /** Domain */
  readonly domain?: DomainName;

  /** Growth rate (tests per iteration) */
  readonly growthRate: number;

  /** Coverage target (0-1) */
  readonly coverageTarget: number;

  /** Current coverage (0-1) */
  currentCoverage: number;

  /** Growth pattern to use */
  readonly pattern: GrowthPattern;

  /** Mutation rules for generated tests */
  readonly mutationRules: MutationRule[];

  /** Maximum tests to generate */
  readonly maxTests: number;

  /** Tests generated from this seed */
  generatedTests: string[];

  /** Planting timestamp */
  readonly plantedAt: Date;

  /** Whether seed is still active */
  active: boolean;

  /** Energy level (determines growth vigor) */
  energy: number;
}

/**
 * Morphogenetic field cell - represents a point in the coverage landscape
 */
export interface FieldCell {
  /** Position identifier (file:function or module path) */
  readonly position: string;

  /** Growth potential (0-1, higher = more tests should grow here) */
  potential: number;

  /** Current coverage (0-1) */
  coverage: number;

  /** Risk factor based on complexity and change frequency */
  riskFactor: number;

  /** Neighboring cells */
  readonly neighbors: string[];

  /** Tests covering this cell */
  tests: string[];

  /** Whether cell has been visited in current growth cycle */
  visited: boolean;
}

/**
 * Morphogenetic field - the landscape for test growth
 */
export interface MorphogeneticField {
  /** Field identifier */
  readonly id: string;

  /** All cells in the field */
  readonly cells: Map<string, FieldCell>;

  /** Domain this field covers */
  readonly domain?: DomainName;

  /** Global growth signal strength */
  globalSignal: number;

  /** Inhibition zones (areas with sufficient coverage) */
  inhibitionZones: Set<string>;

  /** Last update timestamp */
  lastUpdated: Date;
}

/**
 * Growth cycle result
 */
export interface GrowthCycleResult {
  /** Cycle number */
  readonly cycle: number;

  /** Seeds that grew */
  readonly activeSeeds: number;

  /** New tests generated */
  readonly newTests: TestSpecification[];

  /** Tests pruned */
  readonly prunedTests: string[];

  /** Coverage improvement */
  readonly coverageImprovement: number;

  /** Field state after growth */
  readonly fieldSnapshot: {
    totalCells: number;
    coveredCells: number;
    averagePotential: number;
  };

  /** Duration in milliseconds */
  readonly durationMs: number;
}

/**
 * Harvest result
 */
export interface HarvestResult {
  /** Total tests harvested */
  readonly totalTests: number;

  /** Tests by type */
  readonly byType: Record<string, number>;

  /** Tests by priority */
  readonly byPriority: { high: number; medium: number; low: number };

  /** Test specifications */
  readonly specifications: TestSpecification[];

  /** Recommended execution order */
  readonly executionOrder: string[];
}

/**
 * Morphogenetic controller configuration
 */
export interface MorphogeneticConfig {
  /** Enable morphogenetic growth */
  enabled: boolean;

  /** Default growth pattern */
  defaultPattern: GrowthPattern;

  /** Growth interval (ms) */
  growthIntervalMs: number;

  /** Maximum seeds at once */
  maxActiveSeeds: number;

  /** Minimum potential to start growing */
  minGrowthPotential: number;

  /** Coverage threshold to inhibit further growth */
  coverageInhibitionThreshold: number;

  /** Energy decay rate per cycle */
  energyDecayRate: number;

  /** Pruning threshold (tests below this maturity get pruned) */
  pruningThreshold: number;

  /** Maximum generations from seed */
  maxGenerations: number;

  /** Adaptive learning rate */
  adaptiveLearningRate: number;
}

/**
 * Default configuration
 */
export const DEFAULT_MORPHOGENETIC_CONFIG: MorphogeneticConfig = {
  enabled: true,
  defaultPattern: 'adaptive',
  growthIntervalMs: 30000, // 30 seconds
  maxActiveSeeds: 10,
  minGrowthPotential: 0.3,
  coverageInhibitionThreshold: 0.8,
  energyDecayRate: 0.1,
  pruningThreshold: 0.4,
  maxGenerations: 5,
  adaptiveLearningRate: 0.15,
};

// ============================================================================
// Morphogenetic Field Implementation
// ============================================================================

/**
 * Creates and manages the morphogenetic field
 */
export class MorphogeneticFieldManager {
  private fields: Map<string, MorphogeneticField> = new Map();
  private readonly config: MorphogeneticConfig;

  constructor(config: Partial<MorphogeneticConfig> = {}) {
    this.config = { ...DEFAULT_MORPHOGENETIC_CONFIG, ...config };
  }

  /**
   * Create a field from a swarm graph
   */
  createFieldFromGraph(graph: SwarmGraph, domain?: DomainName): MorphogeneticField {
    const fieldId = domain ? `field:${domain}` : `field:${uuidv4().slice(0, 8)}`;
    const cells = new Map<string, FieldCell>();

    // Convert vertices to field cells
    for (const vertex of graph.getVertices()) {
      if (domain && vertex.domain !== domain) continue;

      const neighbors = graph.neighborIds(vertex.id);
      const weightedDegree = graph.weightedDegree(vertex.id);
      const avgDegree = graph.getStats().averageDegree;

      // Calculate initial potential based on connectivity (lower = higher potential)
      const connectivityFactor = avgDegree > 0 ? 1 - (weightedDegree / (avgDegree * 2)) : 1;
      const potential = Math.max(0, Math.min(1, connectivityFactor));

      cells.set(vertex.id, {
        position: vertex.id,
        potential,
        coverage: 0,
        riskFactor: this.calculateRiskFactor(vertex, graph),
        neighbors,
        tests: [],
        visited: false,
      });
    }

    const field: MorphogeneticField = {
      id: fieldId,
      cells,
      domain,
      globalSignal: 1.0,
      inhibitionZones: new Set(),
      lastUpdated: new Date(),
    };

    this.fields.set(fieldId, field);
    return field;
  }

  /**
   * Update field based on coverage data
   */
  updateFieldCoverage(fieldId: string, coverageData: Map<string, number>): void {
    const field = this.fields.get(fieldId);
    if (!field) return;

    for (const [position, coverage] of coverageData) {
      const cell = field.cells.get(position);
      if (cell) {
        cell.coverage = coverage;

        // Update potential based on coverage (lower coverage = higher potential)
        cell.potential = (1 - coverage) * cell.riskFactor;

        // Add to inhibition zone if well-covered
        if (coverage >= this.config.coverageInhibitionThreshold) {
          field.inhibitionZones.add(position);
        } else {
          field.inhibitionZones.delete(position);
        }
      }
    }

    field.lastUpdated = new Date();
  }

  /**
   * Get cells with highest growth potential
   */
  getHighPotentialCells(fieldId: string, limit: number = 10): FieldCell[] {
    const field = this.fields.get(fieldId);
    if (!field) return [];

    return Array.from(field.cells.values())
      .filter(cell => !field.inhibitionZones.has(cell.position))
      .filter(cell => cell.potential >= this.config.minGrowthPotential)
      .sort((a, b) => b.potential - a.potential)
      .slice(0, limit);
  }

  /**
   * Propagate growth signal through the field
   */
  propagateSignal(fieldId: string, sourcePosition: string, strength: number): void {
    const field = this.fields.get(fieldId);
    if (!field) return;

    const visited = new Set<string>();
    const queue: Array<{ position: string; signal: number }> = [
      { position: sourcePosition, signal: strength },
    ];

    while (queue.length > 0) {
      const { position, signal } = queue.shift()!;

      if (visited.has(position) || signal < 0.1) continue;
      visited.add(position);

      const cell = field.cells.get(position);
      if (!cell) continue;

      // Apply signal to cell potential
      cell.potential = Math.min(1, cell.potential + signal * 0.3);

      // Propagate to neighbors with decay
      for (const neighborId of cell.neighbors) {
        if (!visited.has(neighborId) && !field.inhibitionZones.has(neighborId)) {
          queue.push({ position: neighborId, signal: signal * 0.6 });
        }
      }
    }

    field.lastUpdated = new Date();
  }

  /**
   * Get field by ID
   */
  getField(fieldId: string): MorphogeneticField | undefined {
    return this.fields.get(fieldId);
  }

  /**
   * Calculate risk factor for a vertex
   */
  private calculateRiskFactor(vertex: SwarmVertex, graph: SwarmGraph): number {
    // Base risk from vertex weight (if set)
    let risk = vertex.weight || 0.5;

    // Increase risk for isolated vertices
    const degree = graph.degree(vertex.id);
    if (degree <= 1) {
      risk = Math.min(1, risk + 0.3);
    }

    // Increase risk for coordinator vertices (critical)
    if (vertex.type === 'coordinator') {
      risk = Math.min(1, risk + 0.2);
    }

    return risk;
  }

  /**
   * Reset visited flags for all cells
   */
  resetVisited(fieldId: string): void {
    const field = this.fields.get(fieldId);
    if (!field) return;

    for (const cell of field.cells.values()) {
      cell.visited = false;
    }
  }

  /**
   * Get field statistics
   */
  getFieldStats(fieldId: string): {
    totalCells: number;
    coveredCells: number;
    averagePotential: number;
    inhibitionZoneSize: number;
  } | undefined {
    const field = this.fields.get(fieldId);
    if (!field) return undefined;

    const cells = Array.from(field.cells.values());
    const totalCells = cells.length;
    const coveredCells = cells.filter(c => c.coverage >= this.config.coverageInhibitionThreshold).length;
    const averagePotential = cells.reduce((sum, c) => sum + c.potential, 0) / totalCells || 0;

    return {
      totalCells,
      coveredCells,
      averagePotential,
      inhibitionZoneSize: field.inhibitionZones.size,
    };
  }
}

// ============================================================================
// Morphogenetic Controller Implementation
// ============================================================================

/**
 * MorphogeneticController - Orchestrates the test growth cycle
 *
 * Lifecycle:
 * 1. plantSeeds(): Initialize growth points from MinCut weak vertices
 * 2. grow(): Expand test coverage iteratively
 * 3. prune(): Remove redundant/flaky tests
 * 4. harvest(): Extract mature test specifications
 */
export class MorphogeneticController {
  private readonly config: MorphogeneticConfig;
  private readonly fieldManager: MorphogeneticFieldManager;
  private readonly calculator: MinCutCalculator;
  private readonly graph: SwarmGraph;
  private readonly causalGraph?: CausalGraph;
  private readonly strangeLoop?: StrangeLoopController;

  private seeds: Map<string, TestSeed> = new Map();
  private tests: Map<string, TestSpecification> = new Map();
  private growthTimer: NodeJS.Timeout | null = null;
  private running = false;
  private cycle = 0;
  private feedbackHistory: Array<{ testId: string; success: boolean; timestamp: Date }> = [];

  constructor(
    graph: SwarmGraph,
    config: Partial<MorphogeneticConfig> = {},
    causalGraph?: CausalGraph,
    strangeLoop?: StrangeLoopController
  ) {
    this.config = { ...DEFAULT_MORPHOGENETIC_CONFIG, ...config };
    this.graph = graph;
    this.calculator = createMinCutCalculator();
    this.fieldManager = new MorphogeneticFieldManager(this.config);
    this.causalGraph = causalGraph;
    this.strangeLoop = strangeLoop;
  }

  // ==========================================================================
  // Lifecycle Methods
  // ==========================================================================

  /**
   * Start the morphogenetic growth cycle
   */
  start(): void {
    if (this.running || !this.config.enabled) return;

    this.running = true;

    // Create initial field from graph
    this.fieldManager.createFieldFromGraph(this.graph);

    // Start growth timer
    this.growthTimer = setInterval(
      () => this.runGrowthCycle(),
      this.config.growthIntervalMs
    );
  }

  /**
   * Stop the growth cycle
   */
  stop(): void {
    if (this.growthTimer) {
      clearInterval(this.growthTimer);
      this.growthTimer = null;
    }
    this.running = false;
  }

  /**
   * Check if running
   */
  isRunning(): boolean {
    return this.running;
  }

  // ==========================================================================
  // Plant Seeds
  // ==========================================================================

  /**
   * Plant seeds at weak vertices identified by MinCut analysis
   */
  plantSeeds(weakVertices: WeakVertex[]): TestSeed[] {
    const newSeeds: TestSeed[] = [];

    // Sort by risk score (highest first)
    const sorted = [...weakVertices].sort((a, b) => b.riskScore - a.riskScore);

    // Plant up to maxActiveSeeds
    const toPlant = sorted.slice(0, this.config.maxActiveSeeds - this.getActiveSeeds().length);

    for (const weak of toPlant) {
      // Skip if already have a seed for this vertex
      if (this.hasSeedForVertex(weak.vertexId)) continue;

      const seed = this.createSeed(weak);
      this.seeds.set(seed.id, seed);
      newSeeds.push(seed);

      // Propagate growth signal in field
      const fieldId = weak.vertex.domain ? `field:${weak.vertex.domain}` : Array.from(this.fieldManager['fields'].keys())[0];
      if (fieldId) {
        this.fieldManager.propagateSignal(fieldId, weak.vertexId, weak.riskScore);
      }
    }

    return newSeeds;
  }

  /**
   * Create a seed from a weak vertex
   */
  private createSeed(weak: WeakVertex): TestSeed {
    // Determine growth pattern based on vertex characteristics
    let pattern: GrowthPattern = this.config.defaultPattern;

    if (weak.vertex.type === 'coordinator') {
      pattern = 'radial'; // Coordinators need broad coverage
    } else if (weak.vertex.capabilities && weak.vertex.capabilities.length > 3) {
      pattern = 'branching'; // Complex vertices need focused branches
    }

    // Generate mutation rules based on domain
    const mutationRules = this.generateMutationRules(weak);

    return {
      id: uuidv4(),
      sourceVertexId: weak.vertexId,
      targetPath: weak.vertex.id,
      domain: weak.vertex.domain,
      growthRate: Math.ceil(weak.riskScore * 3) || 1,
      coverageTarget: 0.8,
      currentCoverage: 0,
      pattern,
      mutationRules,
      maxTests: Math.ceil(weak.riskScore * 10) + 5,
      generatedTests: [],
      plantedAt: new Date(),
      active: true,
      energy: 1.0,
    };
  }

  /**
   * Generate mutation rules for property-based testing
   */
  private generateMutationRules(weak: WeakVertex): MutationRule[] {
    const rules: MutationRule[] = [];

    // Default boundary testing
    rules.push({
      target: 'input',
      mutationType: 'boundary',
      constraints: { min: 0, max: 1000 },
    });

    // Null testing for nullable types
    rules.push({
      target: 'optional-params',
      mutationType: 'null',
    });

    // Type-based mutations
    if (weak.vertex.capabilities) {
      for (const cap of weak.vertex.capabilities) {
        if (cap.includes('string') || cap.includes('text')) {
          rules.push({
            target: cap,
            mutationType: 'sequence',
            constraints: { types: ['empty', 'unicode', 'long', 'special-chars'] },
          });
        }
      }
    }

    return rules;
  }

  // ==========================================================================
  // Grow
  // ==========================================================================

  /**
   * Run one growth cycle - expand test coverage
   */
  async runGrowthCycle(): Promise<GrowthCycleResult> {
    const startTime = Date.now();
    this.cycle++;

    const newTests: TestSpecification[] = [];
    const activeSeeds = this.getActiveSeeds();

    // Grow from each active seed
    for (const seed of activeSeeds) {
      const testsFromSeed = this.growFromSeed(seed);
      newTests.push(...testsFromSeed);

      // Decay seed energy
      seed.energy = Math.max(0, seed.energy - this.config.energyDecayRate);

      // Deactivate exhausted seeds
      if (seed.energy <= 0 || seed.generatedTests.length >= seed.maxTests) {
        seed.active = false;
      }
    }

    // Apply adaptive learning if StrangeLoop is available
    if (this.strangeLoop && this.config.defaultPattern === 'adaptive') {
      this.applyAdaptiveLearning();
    }

    // Prune weak tests
    const prunedTests = this.pruneWeak();

    // Get field snapshot
    const fields = Array.from(this.fieldManager['fields'].values());
    const primaryField = fields[0];
    const fieldSnapshot = primaryField
      ? this.fieldManager.getFieldStats(primaryField.id) || { totalCells: 0, coveredCells: 0, averagePotential: 0 }
      : { totalCells: 0, coveredCells: 0, averagePotential: 0 };

    // Calculate coverage improvement
    const coverageImprovement = this.calculateCoverageImprovement(newTests);

    return {
      cycle: this.cycle,
      activeSeeds: activeSeeds.filter(s => s.active).length,
      newTests,
      prunedTests,
      coverageImprovement,
      fieldSnapshot: {
        ...fieldSnapshot,
        averagePotential: fieldSnapshot.averagePotential,
      },
      durationMs: Date.now() - startTime,
    };
  }

  /**
   * Grow tests from a single seed
   */
  private growFromSeed(seed: TestSeed): TestSpecification[] {
    const tests: TestSpecification[] = [];
    const testsToGenerate = Math.ceil(seed.growthRate * seed.energy);

    switch (seed.pattern) {
      case 'radial':
        tests.push(...this.growRadial(seed, testsToGenerate));
        break;
      case 'branching':
        tests.push(...this.growBranching(seed, testsToGenerate));
        break;
      case 'adaptive':
        tests.push(...this.growAdaptive(seed, testsToGenerate));
        break;
    }

    // Register tests
    for (const test of tests) {
      this.tests.set(test.id, test);
      seed.generatedTests.push(test.id);
    }

    return tests;
  }

  /**
   * Radial growth - expand coverage outward from seed
   */
  private growRadial(seed: TestSeed, count: number): TestSpecification[] {
    const tests: TestSpecification[] = [];
    const neighbors = this.graph.neighborIds(seed.sourceVertexId);

    // Generate tests for the seed itself first
    if (seed.generatedTests.length === 0) {
      tests.push(this.createTestSpec(seed, seed.targetPath, 0, 'unit'));
    }

    // Then expand to neighbors
    for (const neighborId of neighbors.slice(0, count)) {
      const neighbor = this.graph.getVertex(neighborId);
      if (!neighbor) continue;

      const generation = Math.floor(seed.generatedTests.length / 3) + 1;
      if (generation > this.config.maxGenerations) continue;

      tests.push(this.createTestSpec(seed, neighbor.id, generation, 'integration'));
    }

    return tests;
  }

  /**
   * Branching growth - follow code dependencies
   */
  private growBranching(seed: TestSeed, count: number): TestSpecification[] {
    const tests: TestSpecification[] = [];

    // Use causal graph if available to follow failure chains
    if (this.causalGraph) {
      const failures = this.causalGraph.getAllFailures();
      const relevantFailures = failures.filter(f =>
        f.relatedFiles.some(file => file.includes(seed.targetPath))
      );

      for (const failure of relevantFailures.slice(0, count)) {
        const generation = seed.generatedTests.length + 1;
        if (generation > this.config.maxGenerations) break;

        tests.push(this.createTestSpec(
          seed,
          failure.filePath,
          generation,
          'unit',
          `Regression test for: ${failure.testName}`
        ));
      }
    }

    // Fall back to dependency-based branching
    if (tests.length < count) {
      const vertex = this.graph.getVertex(seed.sourceVertexId);
      if (vertex?.capabilities) {
        for (const capability of vertex.capabilities.slice(0, count - tests.length)) {
          const generation = seed.generatedTests.length + tests.length + 1;
          if (generation > this.config.maxGenerations) break;

          tests.push(this.createTestSpec(
            seed,
            `${seed.targetPath}:${capability}`,
            generation,
            'unit',
            `Test capability: ${capability}`
          ));
        }
      }
    }

    return tests;
  }

  /**
   * Adaptive growth - learn from feedback
   */
  private growAdaptive(seed: TestSeed, count: number): TestSpecification[] {
    const tests: TestSpecification[] = [];

    // Analyze feedback history to determine best approach
    const relevantFeedback = this.feedbackHistory.filter(f => {
      const test = this.tests.get(f.testId);
      return test?.seedId === seed.id;
    });

    const successRate = relevantFeedback.length > 0
      ? relevantFeedback.filter(f => f.success).length / relevantFeedback.length
      : 0.5;

    // High success rate -> more of the same pattern
    // Low success rate -> try different approach
    if (successRate >= 0.7) {
      // Current approach working, continue with integration tests
      tests.push(...this.growRadial(seed, count));
    } else if (successRate <= 0.3 && seed.generatedTests.length > 2) {
      // Struggling, switch to property-based testing
      tests.push(this.createTestSpec(
        seed,
        seed.targetPath,
        seed.generatedTests.length + 1,
        'property',
        'Property-based testing for edge cases'
      ));
    } else {
      // Mixed results, try branching
      tests.push(...this.growBranching(seed, count));
    }

    return tests;
  }

  /**
   * Create a test specification
   */
  private createTestSpec(
    seed: TestSeed,
    targetPath: string,
    generation: number,
    type: TestSpecification['type'],
    customDescription?: string
  ): TestSpecification {
    const description = customDescription ||
      this.generateTestDescription(seed, targetPath, type);

    const complexity = this.estimateComplexity(seed, type, generation);
    const priority = this.calculatePriority(seed, generation);

    return {
      id: uuidv4(),
      name: this.generateTestName(seed, targetPath, type),
      targetPath,
      type,
      description,
      priority,
      seedId: seed.id,
      generation,
      complexity,
      relatedTests: seed.generatedTests.slice(-3), // Last 3 related tests
      mutationRules: type === 'property' ? seed.mutationRules : undefined,
      createdAt: new Date(),
      status: 'growing',
    };
  }

  /**
   * Generate test name
   */
  private generateTestName(seed: TestSeed, targetPath: string, type: string): string {
    const pathPart = targetPath.split(':').pop() || targetPath.split('/').pop() || 'test';
    const typeSuffix = type === 'unit' ? 'Unit' : type === 'integration' ? 'Integration' : type === 'property' ? 'Property' : 'E2E';
    return `${pathPart}_${typeSuffix}_${seed.generatedTests.length + 1}`;
  }

  /**
   * Generate test description
   */
  private generateTestDescription(seed: TestSeed, targetPath: string, type: string): string {
    switch (type) {
      case 'unit':
        return `Unit test for ${targetPath} - verifies isolated behavior`;
      case 'integration':
        return `Integration test for ${targetPath} - verifies interactions with ${seed.targetPath}`;
      case 'property':
        return `Property-based test for ${targetPath} - verifies invariants with generated inputs`;
      case 'e2e':
        return `End-to-end test for ${targetPath} - verifies complete workflow`;
      default:
        return `Test for ${targetPath}`;
    }
  }

  /**
   * Estimate test complexity
   */
  private estimateComplexity(seed: TestSeed, type: string, generation: number): number {
    let base = 3; // Default medium complexity

    // Type-based adjustment
    switch (type) {
      case 'unit':
        base = 2;
        break;
      case 'integration':
        base = 5;
        break;
      case 'property':
        base = 6;
        break;
      case 'e2e':
        base = 8;
        break;
    }

    // Generation-based adjustment (later = more complex)
    base += Math.min(2, generation * 0.5);

    // Mutation rules increase complexity
    if (seed.mutationRules.length > 3) {
      base += 1;
    }

    return Math.min(10, Math.max(1, Math.round(base)));
  }

  /**
   * Calculate priority based on seed risk and generation
   */
  private calculatePriority(seed: TestSeed, generation: number): number {
    // Earlier generations get higher priority
    const generationFactor = 1 - (generation / (this.config.maxGenerations * 2));

    // Combine with seed energy (proxy for importance)
    return seed.energy * generationFactor;
  }

  // ==========================================================================
  // Prune
  // ==========================================================================

  /**
   * Prune weak/redundant tests
   */
  prune(): string[] {
    return this.pruneWeak();
  }

  /**
   * Remove tests that are weak or redundant
   */
  private pruneWeak(): string[] {
    const pruned: string[] = [];
    const now = Date.now();

    for (const [testId, test] of this.tests) {
      if (test.status === 'pruned' || test.status === 'harvested') continue;

      // Check if test should be pruned
      const shouldPrune =
        // Old tests that never matured
        (now - test.createdAt.getTime() > 300000 && test.status === 'growing') ||
        // Very low priority
        test.priority < this.config.pruningThreshold ||
        // Failed feedback
        this.hasNegativeFeedback(testId);

      if (shouldPrune) {
        test.status = 'pruned';
        pruned.push(testId);
      }
    }

    return pruned;
  }

  /**
   * Check if test has negative feedback
   */
  private hasNegativeFeedback(testId: string): boolean {
    const feedback = this.feedbackHistory.filter(f => f.testId === testId);
    if (feedback.length < 2) return false;

    const failures = feedback.filter(f => !f.success).length;
    return failures / feedback.length > 0.7; // >70% failure rate
  }

  // ==========================================================================
  // Harvest
  // ==========================================================================

  /**
   * Harvest mature test specifications
   */
  harvest(): HarvestResult {
    const matureTests: TestSpecification[] = [];
    const byType: Record<string, number> = {};
    const byPriority = { high: 0, medium: 0, low: 0 };

    for (const [, test] of this.tests) {
      if (test.status === 'pruned' || test.status === 'harvested') continue;

      // Check maturity
      if (this.isTestMature(test)) {
        test.status = 'harvested';
        matureTests.push(test);

        // Count by type
        byType[test.type] = (byType[test.type] || 0) + 1;

        // Count by priority
        if (test.priority >= 0.7) byPriority.high++;
        else if (test.priority >= 0.4) byPriority.medium++;
        else byPriority.low++;
      }
    }

    // Determine execution order (high priority first, then by complexity)
    const executionOrder = matureTests
      .sort((a, b) => {
        if (b.priority !== a.priority) return b.priority - a.priority;
        return a.complexity - b.complexity; // Simpler tests first for same priority
      })
      .map(t => t.id);

    return {
      totalTests: matureTests.length,
      byType,
      byPriority,
      specifications: matureTests,
      executionOrder,
    };
  }

  /**
   * Check if a test is mature (ready for harvest)
   */
  private isTestMature(test: TestSpecification): boolean {
    // Tests are mature if:
    // 1. They've had time to grow (at least 1 growth cycle)
    const age = Date.now() - test.createdAt.getTime();
    const minAge = this.config.growthIntervalMs;

    if (age < minAge) return false;

    // 2. Priority is above pruning threshold
    if (test.priority < this.config.pruningThreshold) return false;

    // 3. Status is still growing or already mature
    if (test.status === 'pruned' || test.status === 'harvested') return false;

    // Mark as mature
    test.status = 'mature';
    return true;
  }

  // ==========================================================================
  // Adaptive Learning
  // ==========================================================================

  /**
   * Record feedback for a test
   */
  recordFeedback(testId: string, success: boolean): void {
    this.feedbackHistory.push({
      testId,
      success,
      timestamp: new Date(),
    });

    // Keep last 1000 feedback entries
    if (this.feedbackHistory.length > 1000) {
      this.feedbackHistory.shift();
    }

    // Update seed coverage if test passed
    if (success) {
      const test = this.tests.get(testId);
      if (test) {
        const seed = this.seeds.get(test.seedId);
        if (seed) {
          seed.currentCoverage = Math.min(1, seed.currentCoverage + 0.05);
        }
      }
    }
  }

  /**
   * Apply adaptive learning from StrangeLoop feedback
   */
  private applyAdaptiveLearning(): void {
    if (!this.strangeLoop) return;

    const results = this.strangeLoop.getResults(10);
    const recentObservations = this.strangeLoop.getObservations(10);

    // Analyze which types of tests are most effective
    for (const result of results) {
      if (result.success && result.improvement > 0) {
        // Positive outcome - increase energy for related seeds
        const relatedSeeds = this.getActiveSeeds().filter(s =>
          s.domain === (result.action as unknown as { domain?: DomainName }).domain
        );

        for (const seed of relatedSeeds) {
          seed.energy = Math.min(1, seed.energy + this.config.adaptiveLearningRate);
        }
      }
    }

    // Use observations to identify new seed opportunities
    for (const obs of recentObservations) {
      for (const weak of obs.weakVertices) {
        if (!this.hasSeedForVertex(weak.vertexId) && weak.riskScore > 0.6) {
          // High-risk vertex without seed - consider planting
          if (this.getActiveSeeds().length < this.config.maxActiveSeeds) {
            this.plantSeeds([weak]);
          }
        }
      }
    }
  }

  // ==========================================================================
  // Status & Query Methods
  // ==========================================================================

  /**
   * Get active seeds
   */
  getActiveSeeds(): TestSeed[] {
    return Array.from(this.seeds.values()).filter(s => s.active);
  }

  /**
   * Check if vertex has a seed
   */
  private hasSeedForVertex(vertexId: string): boolean {
    return Array.from(this.seeds.values()).some(
      s => s.sourceVertexId === vertexId && s.active
    );
  }

  /**
   * Get all tests
   */
  getTests(): TestSpecification[] {
    return Array.from(this.tests.values());
  }

  /**
   * Get tests by status
   */
  getTestsByStatus(status: TestSpecification['status']): TestSpecification[] {
    return Array.from(this.tests.values()).filter(t => t.status === status);
  }

  /**
   * Get seed by ID
   */
  getSeed(seedId: string): TestSeed | undefined {
    return this.seeds.get(seedId);
  }

  /**
   * Get current cycle number
   */
  getCycle(): number {
    return this.cycle;
  }

  /**
   * Calculate coverage improvement from new tests
   */
  private calculateCoverageImprovement(newTests: TestSpecification[]): number {
    if (newTests.length === 0) return 0;

    // Simple estimation based on test count and complexity
    return newTests.reduce((sum, test) => {
      const typeWeight = test.type === 'integration' ? 0.02 : test.type === 'e2e' ? 0.03 : 0.01;
      return sum + typeWeight;
    }, 0);
  }

  /**
   * Get growth statistics
   */
  getStats(): {
    totalSeeds: number;
    activeSeeds: number;
    totalTests: number;
    growingTests: number;
    matureTests: number;
    harvestedTests: number;
    prunedTests: number;
    currentCycle: number;
    averageEnergy: number;
  } {
    const seeds = Array.from(this.seeds.values());
    const tests = Array.from(this.tests.values());
    const activeSeeds = seeds.filter(s => s.active);

    return {
      totalSeeds: seeds.length,
      activeSeeds: activeSeeds.length,
      totalTests: tests.length,
      growingTests: tests.filter(t => t.status === 'growing').length,
      matureTests: tests.filter(t => t.status === 'mature').length,
      harvestedTests: tests.filter(t => t.status === 'harvested').length,
      prunedTests: tests.filter(t => t.status === 'pruned').length,
      currentCycle: this.cycle,
      averageEnergy: activeSeeds.length > 0
        ? activeSeeds.reduce((sum, s) => sum + s.energy, 0) / activeSeeds.length
        : 0,
    };
  }

  /**
   * Get configuration
   */
  getConfig(): MorphogeneticConfig {
    return { ...this.config };
  }

  /**
   * Get field manager (for advanced usage)
   */
  getFieldManager(): MorphogeneticFieldManager {
    return this.fieldManager;
  }
}

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Create a morphogenetic controller
 */
export function createMorphogeneticController(
  graph: SwarmGraph,
  config?: Partial<MorphogeneticConfig>,
  causalGraph?: CausalGraph,
  strangeLoop?: StrangeLoopController
): MorphogeneticController {
  return new MorphogeneticController(graph, config, causalGraph, strangeLoop);
}

/**
 * Create a morphogenetic field manager
 */
export function createMorphogeneticFieldManager(
  config?: Partial<MorphogeneticConfig>
): MorphogeneticFieldManager {
  return new MorphogeneticFieldManager(config);
}

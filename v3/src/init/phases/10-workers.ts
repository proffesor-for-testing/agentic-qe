/**
 * Phase 10: Workers
 * Configures background workers for continuous monitoring
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import { spawn } from 'child_process';

import {
  BasePhase,
  type InitContext,
} from './phase-interface.js';
import type { AQEInitConfig } from '../types.js';

interface WorkerRegistration {
  name: string;
  enabled: boolean;
  interval: number;
  lastRun: string | null;
  status: 'pending' | 'running' | 'completed' | 'error';
}

export interface WorkersResult {
  workersDir: string;
  workersConfigured: number;
  registryPath: string;
  daemonStarted: boolean;
  daemonPid: number | null;
  daemonError?: string;
}

/**
 * Workers phase - configures background workers
 */
export class WorkersPhase extends BasePhase<WorkersResult> {
  readonly name = 'workers';
  readonly description = 'Configure background workers';
  readonly order = 100;
  readonly critical = false;
  readonly requiresPhases = ['configuration'] as const;

  async shouldRun(context: InitContext): Promise<boolean> {
    const config = context.config as AQEInitConfig;
    return config?.workers?.daemonAutoStart && (config?.workers?.enabled?.length ?? 0) > 0;
  }

  protected async run(context: InitContext): Promise<WorkersResult> {
    const config = context.config as AQEInitConfig;
    const { projectRoot } = context;

    if (!config.workers.daemonAutoStart || config.workers.enabled.length === 0) {
      return {
        workersDir: '',
        workersConfigured: 0,
        registryPath: '',
        daemonStarted: false,
        daemonPid: null,
      };
    }

    // Create workers directory
    const workersDir = join(projectRoot, '.agentic-qe', 'workers');
    if (!existsSync(workersDir)) {
      mkdirSync(workersDir, { recursive: true });
    }

    // Default intervals for all 11 workers (ADR-014)
    const defaultIntervals: Record<string, number> = {
      // Learning & Pattern Workers
      'learning-consolidation': 1800000, // 30 min - Pattern consolidation, dream cycles
      'pattern-consolidator': 1800000,   // Alias for learning-consolidation

      // Test Quality Workers
      'test-health': 300000,             // 5 min - Test suite health
      'coverage-tracker': 600000,        // 10 min - Coverage trends
      'coverage-gap-scanner': 600000,    // Alias for coverage-tracker
      'flaky-detector': 900000,          // 15 min - Flaky test detection
      'flaky-test-detector': 900000,     // Alias for flaky-detector

      // Security & Quality Workers
      'security-scan': 1800000,          // 30 min - Vulnerability scanning
      'quality-gate': 300000,            // 5 min - Gate evaluation
      'compliance-checker': 1800000,     // 30 min - ADR/DDD compliance

      // ML & Prediction Workers
      'defect-predictor': 900000,        // 15 min - ML defect prediction
      'regression-monitor': 600000,      // 10 min - Regression watching
      'routing-accuracy-monitor': 900000,// 15 min - Routing accuracy

      // Performance Workers
      'performance-baseline': 3600000,   // 1 hour - Performance tracking

      // Sync Workers
      'cloud-sync': 300000,              // 5 min - Cloud synchronization
    };

    // Build worker registry
    const workerRegistry: Record<string, WorkerRegistration> = {};

    for (const workerName of config.workers.enabled) {
      workerRegistry[workerName] = {
        name: workerName,
        enabled: true,
        interval: config.workers.intervals[workerName] || defaultIntervals[workerName] || 60000,
        lastRun: null,
        status: 'pending',
      };
    }

    // Write registry
    const registryPath = join(workersDir, 'registry.json');
    const registryData = {
      version: config.version,
      maxConcurrent: config.workers.maxConcurrent,
      workers: workerRegistry,
      createdAt: new Date().toISOString(),
      daemonPid: null,
    };
    writeFileSync(registryPath, JSON.stringify(registryData, null, 2), 'utf-8');

    // Write individual worker configs
    for (const workerName of config.workers.enabled) {
      const workerConfigPath = join(workersDir, `${workerName}.json`);
      const workerConfig = {
        name: workerName,
        enabled: true,
        interval: config.workers.intervals[workerName] || defaultIntervals[workerName] || 60000,
        projectRoot,
        dataDir: join(projectRoot, '.agentic-qe', 'data'),
        createdAt: new Date().toISOString(),
      };
      writeFileSync(workerConfigPath, JSON.stringify(workerConfig, null, 2), 'utf-8');
    }

    // Write daemon startup script (using relative paths for portability)
    const daemonScriptPath = join(workersDir, 'start-daemon.sh');
    const daemonScript = `#!/bin/bash
# AQE v3 Worker Daemon Startup Script
# Generated by aqe init
# Starts the MCP server with background workers enabled

# Get directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
# Navigate up from .agentic-qe/workers to project root
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
WORKERS_DIR="$PROJECT_ROOT/.agentic-qe/workers"
PID_FILE="$WORKERS_DIR/daemon.pid"
LOG_FILE="$WORKERS_DIR/daemon.log"

# Check if already running
if [ -f "$PID_FILE" ]; then
  PID=$(cat "$PID_FILE")
  if kill -0 "$PID" 2>/dev/null; then
    echo "Daemon already running (PID: $PID)"
    exit 0
  fi
fi

echo "[$(date)] Starting AQE v3 Worker Daemon..." >> "$LOG_FILE"

# Set environment for learning and workers
export AQE_PROJECT_ROOT="$PROJECT_ROOT"
export AQE_LEARNING_ENABLED=true
export AQE_WORKERS_ENABLED=true
export AQE_HTTP_PORT=0

# Find the best way to run aqe-mcp
MCP_CMD=""
if [ -f "$PROJECT_ROOT/node_modules/.bin/aqe-mcp" ]; then
  MCP_CMD="$PROJECT_ROOT/node_modules/.bin/aqe-mcp"
elif [ -f "$PROJECT_ROOT/node_modules/agentic-qe/v3/dist/mcp/bundle.js" ]; then
  MCP_CMD="node $PROJECT_ROOT/node_modules/agentic-qe/v3/dist/mcp/bundle.js"
elif command -v aqe-mcp &> /dev/null; then
  MCP_CMD="aqe-mcp"
else
  MCP_CMD="npx --yes agentic-qe mcp"
fi

echo "[$(date)] Using MCP command: $MCP_CMD" >> "$LOG_FILE"

# Start the MCP server with workers
cd "$PROJECT_ROOT"
nohup $MCP_CMD >> "$LOG_FILE" 2>&1 &
DAEMON_PID=$!

# Save PID
echo $DAEMON_PID > "$PID_FILE"
echo "[$(date)] Daemon started with PID: $DAEMON_PID" >> "$LOG_FILE"

echo "AQE v3 Worker Daemon started (PID: $DAEMON_PID)"
echo "Log file: $LOG_FILE"
echo ""
echo "To stop: kill $DAEMON_PID"
echo "To view logs: tail -f $LOG_FILE"
`;
    writeFileSync(daemonScriptPath, daemonScript, { mode: 0o755 });

    // Also write a stop script (using relative paths for portability)
    const stopScriptPath = join(workersDir, 'stop-daemon.sh');
    const stopScript = `#!/bin/bash
# AQE v3 Worker Daemon Stop Script
# Generated by aqe init

# Get directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
# Navigate up from .agentic-qe/workers to project root
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
WORKERS_DIR="$PROJECT_ROOT/.agentic-qe/workers"
PID_FILE="$WORKERS_DIR/daemon.pid"

if [ -f "$PID_FILE" ]; then
  PID=$(cat "$PID_FILE")
  if kill -0 "$PID" 2>/dev/null; then
    echo "Stopping daemon (PID: $PID)..."
    kill "$PID"
    rm -f "$PID_FILE"
    echo "Daemon stopped"
  else
    echo "Daemon not running (stale PID file)"
    rm -f "$PID_FILE"
  fi
else
  echo "No PID file found - daemon may not be running"
fi
`;
    writeFileSync(stopScriptPath, stopScript, { mode: 0o755 });

    context.services.log(`  Workers dir: ${workersDir}`);
    context.services.log(`  Workers: ${config.workers.enabled.join(', ')}`);

    // Auto-start the MCP daemon if configured
    let daemonStarted = false;
    let daemonPid: number | null = null;
    let daemonError: string | undefined;

    if (config.workers.daemonAutoStart) {
      try {
        const result = await this.startDaemon(workersDir, projectRoot, context);
        daemonStarted = result.started;
        daemonPid = result.pid;
        daemonError = result.error;

        if (daemonStarted) {
          context.services.log(`  MCP daemon started (PID: ${daemonPid})`);
        } else if (daemonError) {
          context.services.log(`  MCP daemon failed: ${daemonError}`);
        }
      } catch (error) {
        daemonError = error instanceof Error ? error.message : 'Unknown error';
        context.services.log(`  MCP daemon error: ${daemonError}`);
      }
    }

    return {
      workersDir,
      workersConfigured: config.workers.enabled.length,
      registryPath,
      daemonStarted,
      daemonPid,
      daemonError,
    };
  }

  /**
   * Start the MCP daemon in the background
   */
  private async startDaemon(
    workersDir: string,
    projectRoot: string,
    context: InitContext
  ): Promise<{ started: boolean; pid: number | null; error?: string }> {
    const pidFile = join(workersDir, 'daemon.pid');
    const logFile = join(workersDir, 'daemon.log');

    // Check if already running
    if (existsSync(pidFile)) {
      try {
        const existingPid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);
        // Check if process is running
        process.kill(existingPid, 0);
        return { started: true, pid: existingPid, error: 'Already running' };
      } catch {
        // PID file exists but process not running, continue
      }
    }

    // Try to find aqe-mcp command
    const mcpCommand = await this.findMcpCommand(projectRoot);
    if (!mcpCommand) {
      return {
        started: false,
        pid: null,
        error: 'aqe-mcp not found. Install globally with: npm install -g agentic-qe',
      };
    }

    return new Promise((resolve) => {
      try {
        // Set up environment
        const env = {
          ...process.env,
          AQE_PROJECT_ROOT: projectRoot,
          AQE_LEARNING_ENABLED: 'true',
          AQE_WORKERS_ENABLED: 'true',
          AQE_HTTP_PORT: '0',
        };

        // Spawn the MCP server as a detached process
        const child = spawn(mcpCommand.command, mcpCommand.args, {
          cwd: projectRoot,
          env,
          detached: true,
          stdio: ['ignore', 'pipe', 'pipe'],
        });

        // Give the process a moment to start
        let started = false;
        let errorOutput = '';

        child.stderr?.on('data', (data) => {
          errorOutput += data.toString();
        });

        child.on('error', (error) => {
          resolve({
            started: false,
            pid: null,
            error: error.message,
          });
        });

        // Wait a short time to see if the process starts successfully
        setTimeout(() => {
          // Check if process is still alive
          try {
            if (child.pid) {
              process.kill(child.pid, 0); // Check if alive (throws if not)

              // Write PID file
              writeFileSync(pidFile, child.pid.toString(), 'utf-8');

              // Log startup
              const logEntry = `[${new Date().toISOString()}] MCP daemon started with PID: ${child.pid}\n`;
              writeFileSync(logFile, logEntry, { flag: 'a' });

              // Unref so the parent can exit
              child.unref();

              resolve({
                started: true,
                pid: child.pid,
              });
            } else {
              resolve({
                started: false,
                pid: null,
                error: errorOutput || 'No PID assigned',
              });
            }
          } catch {
            // Process died - check error output
            const errMsg = errorOutput.includes('ERR_MODULE_NOT_FOUND')
              ? 'Missing dependencies. Run: npm install agentic-qe'
              : errorOutput || 'Process exited immediately';
            resolve({
              started: false,
              pid: null,
              error: errMsg,
            });
          }
        }, 1500);
      } catch (error) {
        resolve({
          started: false,
          pid: null,
          error: error instanceof Error ? error.message : 'Spawn failed',
        });
      }
    });
  }

  /**
   * Find the aqe-mcp command
   */
  private async findMcpCommand(
    projectRoot: string
  ): Promise<{ command: string; args: string[] } | null> {
    // Try local node_modules first
    const localBin = join(projectRoot, 'node_modules', '.bin', 'aqe-mcp');
    if (existsSync(localBin)) {
      return { command: localBin, args: [] };
    }

    // Try local node_modules bundle (alternative path)
    const localBundle = join(projectRoot, 'node_modules', 'agentic-qe', 'v3', 'dist', 'mcp', 'bundle.js');
    if (existsSync(localBundle)) {
      return { command: 'node', args: [localBundle] };
    }

    // Try to use npx to run the package (most reliable for end users)
    // This handles both global and local installs
    return { command: 'npx', args: ['--yes', 'agentic-qe', 'mcp'] };
  }
}

// Instance exported from index.ts

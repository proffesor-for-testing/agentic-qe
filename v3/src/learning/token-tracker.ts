/**
 * Agentic QE v3 - Token Metrics Collector
 * ADR-042: V3 QE Token Tracking and Consumption Reduction
 *
 * Provides comprehensive token usage tracking and optimization metrics:
 * - Per-task token tracking (input/output/total)
 * - Per-agent aggregation
 * - Per-domain breakdown
 * - Session-level summaries
 * - Pattern reuse tracking for token savings
 *
 * @example
 * ```typescript
 * import { TokenMetricsCollector } from './token-tracker';
 *
 * // Record token usage for a task
 * TokenMetricsCollector.recordTokenUsage('task-123', 'agent-1', 'test-generation', 'generate', {
 *   inputTokens: 500,
 *   outputTokens: 150,
 *   totalTokens: 650,
 * });
 *
 * // Record pattern reuse savings
 * TokenMetricsCollector.recordPatternReuse('task-456', 800);
 *
 * // Get efficiency report
 * const efficiency = TokenMetricsCollector.getTokenEfficiency();
 * console.log(`Savings: ${efficiency.savingsPercentage}%`);
 * ```
 *
 * @module learning/token-tracker
 */

import { randomUUID } from 'crypto';

// ============================================================================
// Token Usage Types (ADR-042 Specification)
// ============================================================================

/**
 * Token usage for a single operation.
 * Tracks input, output, and total tokens with optional cost estimation.
 */
export interface TokenUsage {
  /** Number of input tokens consumed */
  inputTokens: number;
  /** Number of output tokens generated */
  outputTokens: number;
  /** Total tokens (input + output) */
  totalTokens: number;
  /** Estimated cost in USD based on configured pricing */
  estimatedCostUsd?: number;
}

/**
 * Token metric for a single task execution.
 * Captures complete context including agent, domain, and optimization data.
 */
export interface TaskTokenMetric {
  /** Unique task identifier */
  taskId: string;
  /** Agent that executed the task */
  agentId: string;
  /** Domain the task belongs to (e.g., 'test-generation', 'coverage-analysis') */
  domain: string;
  /** Type of operation performed */
  operation: string;
  /** Timestamp when the metric was recorded (epoch ms) */
  timestamp: number;
  /** Token usage details for this task */
  usage: TokenUsage;
  /** Whether a cached pattern was reused (avoiding LLM call) */
  patternReused: boolean;
  /** Estimated tokens saved via caching/pattern reuse */
  tokensSaved?: number;
}

/**
 * Aggregated token metrics for an agent.
 * Provides comprehensive view of agent's token consumption and efficiency.
 */
export interface AgentTokenMetrics {
  /** Agent identifier */
  agentId: string;
  /** Total input tokens consumed by this agent */
  totalInputTokens: number;
  /** Total output tokens generated by this agent */
  totalOutputTokens: number;
  /** Total tokens (input + output) */
  totalTokens: number;
  /** Total estimated cost in USD */
  totalCost: number;
  /** Number of tasks executed */
  tasksExecuted: number;
  /** Number of times patterns were reused (LLM calls skipped) */
  patternsReused: number;
  /** Estimated tokens saved via pattern reuse and caching */
  estimatedTokensSaved: number;
}

/**
 * Session-level token summary with optimization statistics.
 * Provides complete overview of token usage across a session.
 */
export interface SessionTokenSummary {
  /** Session identifier */
  sessionId: string;
  /** Session start timestamp (epoch ms) */
  startTime: number;
  /** Session end timestamp (epoch ms), undefined if session is active */
  endTime?: number;
  /** Token metrics aggregated by agent */
  byAgent: Map<string, AgentTokenMetrics>;
  /** Token usage aggregated by domain */
  byDomain: Map<string, TokenUsage>;
  /** Total token usage across all operations */
  totalUsage: TokenUsage;
  /** Optimization statistics showing token savings */
  optimizationStats: {
    /** Number of patterns successfully reused */
    patternsReused: number;
    /** Number of cache hits (avoided API calls) */
    cacheHits: number;
    /** Number of early exits (high-confidence pattern matches) */
    earlyExits: number;
    /** Total tokens saved through all optimizations */
    tokensSaved: number;
    /** Percentage of tokens saved relative to theoretical usage */
    savingsPercentage: number;
  };
}

/**
 * Token efficiency report with actionable recommendations.
 * Generated by analyzing token usage patterns.
 */
export interface TokenEfficiencyReport {
  /** Total tokens actually used */
  totalTokensUsed: number;
  /** Total tokens saved via optimizations */
  totalTokensSaved: number;
  /** Percentage of tokens saved (0-100) */
  savingsPercentage: number;
  /** Rate of pattern reuse (0-1) */
  patternReuseRate: number;
  /** Average tokens consumed per task */
  averageTokensPerTask: number;
  /** Actionable recommendations for improving efficiency */
  recommendations: string[];
}

/**
 * Timeframe for filtering metrics.
 * Used for time-bounded analysis of token consumption.
 */
export type Timeframe = '1h' | '24h' | '7d' | '30d';

// ============================================================================
// Cost Configuration
// ============================================================================

/**
 * Default token cost configuration (Claude 3.5 Sonnet pricing)
 */
export interface TokenCostConfig {
  costPerInputToken: number;
  costPerOutputToken: number;
}

const DEFAULT_COST_CONFIG: TokenCostConfig = {
  costPerInputToken: 0.003 / 1000,   // $3 per 1M input tokens
  costPerOutputToken: 0.015 / 1000,  // $15 per 1M output tokens
};

// ============================================================================
// Token Metrics Collector Implementation
// ============================================================================

/**
 * Singleton collector for token metrics across the system
 */
/**
 * Persistence configuration for token metrics
 */
export interface TokenPersistenceConfig {
  /** Path to the persistence file */
  filePath: string;
  /** Auto-save interval in milliseconds (0 = disabled) */
  autoSaveIntervalMs: number;
  /** Maximum number of metrics to keep in memory */
  maxMetricsInMemory: number;
}

const DEFAULT_PERSISTENCE_CONFIG: TokenPersistenceConfig = {
  filePath: '.aqe/token-metrics.json',
  autoSaveIntervalMs: 60000, // Auto-save every minute
  maxMetricsInMemory: 10000,
};

/**
 * Persisted data structure
 */
interface PersistedTokenData {
  version: string;
  sessionId: string;
  sessionStartTime: number;
  taskMetrics: TaskTokenMetric[];
  optimizationStats: {
    cacheHits: number;
    earlyExits: number;
    totalTokensSaved: number;
    totalPatternsReused: number;
  };
  lastSavedAt: number;
}

class TokenMetricsCollectorImpl {
  private taskMetrics: TaskTokenMetric[] = [];
  private agentMetrics: Map<string, AgentTokenMetrics> = new Map();
  private domainMetrics: Map<string, TokenUsage> = new Map();
  private sessionId: string;
  private sessionStartTime: number;
  private costConfig: TokenCostConfig;
  private cacheHits = 0;
  private earlyExits = 0;
  private totalTokensSaved = 0;
  private totalPatternsReused = 0;
  private initialized = false;

  // Persistence fields
  private persistenceConfig: TokenPersistenceConfig = DEFAULT_PERSISTENCE_CONFIG;
  private autoSaveTimer: NodeJS.Timeout | null = null;
  private isDirty = false;

  constructor() {
    // Use cryptographically secure random UUID instead of Math.random()
    this.sessionId = `session-${Date.now()}-${randomUUID().substring(0, 8)}`;
    this.sessionStartTime = Date.now();
    this.costConfig = DEFAULT_COST_CONFIG;
  }

  /**
   * Initialize the collector with optional cost configuration.
   * @param config - Optional cost configuration override
   */
  initialize(config?: Partial<TokenCostConfig>): void {
    if (this.initialized) return;
    this.initialized = true;

    if (config) {
      this.costConfig = { ...DEFAULT_COST_CONFIG, ...config };
    }
  }

  /**
   * Set cost configuration for token pricing.
   * @param config - Partial cost configuration to merge
   */
  setCostConfig(config: Partial<TokenCostConfig>): void {
    this.costConfig = { ...this.costConfig, ...config };
  }

  /**
   * Record token usage for a completed task.
   * Updates all aggregations (agent, domain) and tracks optimization stats.
   *
   * @param taskId - Unique task identifier
   * @param usage - Token usage details
   * @example
   * ```typescript
   * TokenMetricsCollector.recordTokenUsage('task-123', {
   *   inputTokens: 500,
   *   outputTokens: 150,
   *   totalTokens: 650
   * });
   * ```
   */
  recordTokenUsage(
    taskId: string,
    usage: TokenUsage
  ): void;

  /**
   * Record token usage for a completed task with full context.
   *
   * @param taskId - Unique task identifier
   * @param agentId - Agent that executed the task
   * @param domain - Domain the task belongs to
   * @param operation - Type of operation performed
   * @param usage - Token usage details
   * @param options - Additional options for pattern reuse tracking
   */
  recordTokenUsage(
    taskId: string,
    agentId: string,
    domain: string,
    operation: string,
    usage: TokenUsage,
    options?: {
      patternReused?: boolean;
      tokensSaved?: number;
    }
  ): void;

  // Implementation signature
  recordTokenUsage(
    taskId: string,
    agentIdOrUsage: string | TokenUsage,
    domain?: string,
    operation?: string,
    usage?: TokenUsage,
    options?: {
      patternReused?: boolean;
      tokensSaved?: number;
    }
  ): void {
    this.ensureInitialized();

    // Handle overloaded signatures
    let actualAgentId: string;
    let actualDomain: string;
    let actualOperation: string;
    let actualUsage: TokenUsage;
    let patternReused: boolean;
    let tokensSaved: number;

    if (typeof agentIdOrUsage === 'object') {
      // Simple signature: recordTokenUsage(taskId, usage)
      actualAgentId = 'default';
      actualDomain = 'unknown';
      actualOperation = 'unknown';
      actualUsage = agentIdOrUsage;
      patternReused = false;
      tokensSaved = 0;
    } else {
      // Full signature
      actualAgentId = agentIdOrUsage;
      actualDomain = domain ?? 'unknown';
      actualOperation = operation ?? 'unknown';
      actualUsage = usage!;
      patternReused = options?.patternReused ?? false;
      tokensSaved = options?.tokensSaved ?? 0;
    }

    // Calculate cost if not provided
    if (actualUsage.estimatedCostUsd === undefined) {
      actualUsage.estimatedCostUsd = this.calculateCost(actualUsage);
    }

    const metric: TaskTokenMetric = {
      taskId,
      agentId: actualAgentId,
      domain: actualDomain,
      operation: actualOperation,
      timestamp: Date.now(),
      usage: actualUsage,
      patternReused,
      tokensSaved,
    };

    this.taskMetrics.push(metric);

    // Update aggregations
    this.updateAgentMetrics(actualAgentId, actualUsage, patternReused, tokensSaved);
    this.updateDomainMetrics(actualDomain, actualUsage);

    // Track optimization stats
    if (patternReused) {
      this.totalPatternsReused++;
    }
    if (tokensSaved > 0) {
      this.totalTokensSaved += tokensSaved;
    }

    // Mark as dirty for persistence
    this.isDirty = true;
  }

  /**
   * Record pattern reuse for a task (tokens saved by skipping LLM call).
   * This is called when a cached pattern is successfully reused.
   *
   * @param taskId - The task identifier
   * @param tokensSaved - Estimated tokens that would have been used
   * @example
   * ```typescript
   * TokenMetricsCollector.recordPatternReuse('task-456', 800);
   * ```
   */
  recordPatternReuse(taskId: string, tokensSaved: number): void {
    this.ensureInitialized();
    this.totalPatternsReused++;
    this.totalTokensSaved += tokensSaved;

    // Create a minimal metric entry for the pattern reuse
    const metric: TaskTokenMetric = {
      taskId,
      agentId: 'pattern-cache',
      domain: 'optimization',
      operation: 'pattern-reuse',
      timestamp: Date.now(),
      usage: {
        inputTokens: 0,
        outputTokens: 0,
        totalTokens: 0,
        estimatedCostUsd: 0,
      },
      patternReused: true,
      tokensSaved,
    };

    this.taskMetrics.push(metric);
    this.isDirty = true;
  }

  /**
   * Record a cache hit (avoided API call).
   * @param tokensSaved - Estimated tokens saved by the cache hit
   */
  recordCacheHit(tokensSaved: number): void {
    this.cacheHits++;
    this.totalTokensSaved += tokensSaved;
    this.isDirty = true;
  }

  /**
   * Record an early exit (skipped LLM call due to high-confidence pattern).
   * @param tokensSaved - Estimated tokens saved by the early exit
   */
  recordEarlyExit(tokensSaved: number): void {
    this.earlyExits++;
    this.totalTokensSaved += tokensSaved;
    this.isDirty = true;
  }

  /**
   * Get session summary
   */
  getSessionSummary(timeframe?: Timeframe): SessionTokenSummary {
    this.ensureInitialized();

    const filteredMetrics = this.filterByTimeframe(this.taskMetrics, timeframe);
    const totalUsage = this.aggregateTokenUsage(filteredMetrics);

    // Build per-agent map from filtered metrics
    const byAgent = new Map<string, AgentTokenMetrics>();
    for (const metric of filteredMetrics) {
      const existing = byAgent.get(metric.agentId);
      if (existing) {
        existing.totalInputTokens += metric.usage.inputTokens;
        existing.totalOutputTokens += metric.usage.outputTokens;
        existing.totalTokens += metric.usage.totalTokens;
        existing.totalCost += metric.usage.estimatedCostUsd || 0;
        existing.tasksExecuted++;
        if (metric.patternReused) existing.patternsReused++;
        existing.estimatedTokensSaved += metric.tokensSaved || 0;
      } else {
        byAgent.set(metric.agentId, {
          agentId: metric.agentId,
          totalInputTokens: metric.usage.inputTokens,
          totalOutputTokens: metric.usage.outputTokens,
          totalTokens: metric.usage.totalTokens,
          totalCost: metric.usage.estimatedCostUsd || 0,
          tasksExecuted: 1,
          patternsReused: metric.patternReused ? 1 : 0,
          estimatedTokensSaved: metric.tokensSaved || 0,
        });
      }
    }

    // Build per-domain map from filtered metrics
    const byDomain = new Map<string, TokenUsage>();
    for (const metric of filteredMetrics) {
      const existing = byDomain.get(metric.domain);
      if (existing) {
        existing.inputTokens += metric.usage.inputTokens;
        existing.outputTokens += metric.usage.outputTokens;
        existing.totalTokens += metric.usage.totalTokens;
        existing.estimatedCostUsd = (existing.estimatedCostUsd || 0) + (metric.usage.estimatedCostUsd || 0);
      } else {
        byDomain.set(metric.domain, { ...metric.usage });
      }
    }

    // Calculate savings percentage
    const totalConsumed = totalUsage.totalTokens;
    const totalSaved = this.totalTokensSaved;
    const savingsPercentage = totalConsumed + totalSaved > 0
      ? (totalSaved / (totalConsumed + totalSaved)) * 100
      : 0;

    return {
      sessionId: this.sessionId,
      startTime: this.sessionStartTime,
      endTime: Date.now(),
      byAgent,
      byDomain,
      totalUsage,
      optimizationStats: {
        patternsReused: this.totalPatternsReused,
        cacheHits: this.cacheHits,
        earlyExits: this.earlyExits,
        tokensSaved: this.totalTokensSaved,
        savingsPercentage: Math.round(savingsPercentage * 100) / 100,
      },
    };
  }

  /**
   * Get metrics for a specific agent
   */
  getAgentMetrics(agentId?: string, timeframe?: Timeframe): AgentTokenMetrics | AgentTokenMetrics[] {
    this.ensureInitialized();

    const filteredMetrics = this.filterByTimeframe(this.taskMetrics, timeframe);

    if (agentId) {
      const agentTasks = filteredMetrics.filter(m => m.agentId === agentId);
      return this.aggregateAgentMetrics(agentId, agentTasks);
    }

    // Return all agents
    const agentMap = new Map<string, TaskTokenMetric[]>();
    for (const metric of filteredMetrics) {
      const existing = agentMap.get(metric.agentId) || [];
      existing.push(metric);
      agentMap.set(metric.agentId, existing);
    }

    return Array.from(agentMap.entries()).map(([id, tasks]) =>
      this.aggregateAgentMetrics(id, tasks)
    );
  }

  /**
   * Get metrics for a specific domain.
   *
   * @param domain - Optional domain name to filter by
   * @param timeframe - Optional timeframe to filter by
   * @returns Token usage for specified domain, or map of all domains if none specified
   */
  getDomainMetrics(domain?: string, timeframe?: Timeframe): TokenUsage | Map<string, TokenUsage> {
    this.ensureInitialized();

    const filteredMetrics = this.filterByTimeframe(this.taskMetrics, timeframe);

    if (domain) {
      const domainTasks = filteredMetrics.filter(m => m.domain === domain);
      return this.aggregateTokenUsage(domainTasks);
    }

    // Return all domains
    const domainMap = new Map<string, TokenUsage>();
    for (const metric of filteredMetrics) {
      const existing = domainMap.get(metric.domain);
      if (existing) {
        existing.inputTokens += metric.usage.inputTokens;
        existing.outputTokens += metric.usage.outputTokens;
        existing.totalTokens += metric.usage.totalTokens;
        existing.estimatedCostUsd = (existing.estimatedCostUsd || 0) + (metric.usage.estimatedCostUsd || 0);
      } else {
        domainMap.set(metric.domain, { ...metric.usage });
      }
    }

    return domainMap;
  }

  /**
   * Get task-level metrics
   */
  getTaskMetrics(timeframe?: Timeframe): TaskTokenMetric[] {
    this.ensureInitialized();
    return this.filterByTimeframe(this.taskMetrics, timeframe);
  }

  /**
   * Get token efficiency report with recommendations.
   * Analyzes token usage patterns and generates actionable insights.
   *
   * @param timeframe - Optional timeframe to filter by
   * @returns Token efficiency report with recommendations
   * @deprecated Use getTokenEfficiency() for ADR-042 compliance
   */
  getEfficiencyReport(timeframe?: Timeframe): TokenEfficiencyReport {
    return this.getTokenEfficiency(timeframe);
  }

  /**
   * Get overall token efficiency metrics and recommendations.
   * This is the primary method for ADR-042 compliance.
   *
   * @param timeframe - Optional timeframe to filter by
   * @returns Token efficiency report with usage stats and recommendations
   * @example
   * ```typescript
   * const efficiency = TokenMetricsCollector.getTokenEfficiency();
   * console.log(`Savings: ${efficiency.savingsPercentage}%`);
   * console.log(`Recommendations: ${efficiency.recommendations.join(', ')}`);
   * ```
   */
  getTokenEfficiency(timeframe?: Timeframe): TokenEfficiencyReport {
    this.ensureInitialized();

    const filteredMetrics = this.filterByTimeframe(this.taskMetrics, timeframe);
    const totalUsage = this.aggregateTokenUsage(filteredMetrics);

    const totalTokensUsed = totalUsage.totalTokens;
    const totalTokensSaved = this.totalTokensSaved;
    const savingsPercentage = totalTokensUsed + totalTokensSaved > 0
      ? (totalTokensSaved / (totalTokensUsed + totalTokensSaved)) * 100
      : 0;

    const totalTasks = filteredMetrics.length;
    const patternReuseRate = totalTasks > 0
      ? filteredMetrics.filter(m => m.patternReused).length / totalTasks
      : 0;

    const averageTokensPerTask = totalTasks > 0
      ? totalTokensUsed / totalTasks
      : 0;

    // Generate recommendations based on analysis
    const recommendations = this.generateRecommendations(filteredMetrics);

    return {
      totalTokensUsed,
      totalTokensSaved,
      savingsPercentage: Math.round(savingsPercentage * 100) / 100,
      patternReuseRate: Math.round(patternReuseRate * 100) / 100,
      averageTokensPerTask: Math.round(averageTokensPerTask),
      recommendations,
    };
  }

  /**
   * Reset all metrics (useful for testing)
   */
  reset(): void {
    this.stopAutoSave();
    this.taskMetrics = [];
    this.agentMetrics.clear();
    this.domainMetrics.clear();
    // Use cryptographically secure random UUID instead of Math.random()
    this.sessionId = `session-${Date.now()}-${randomUUID().substring(0, 8)}`;
    this.sessionStartTime = Date.now();
    this.cacheHits = 0;
    this.earlyExits = 0;
    this.totalTokensSaved = 0;
    this.totalPatternsReused = 0;
    this.isDirty = false;
  }

  // ============================================================================
  // Persistence Methods (ADR-042)
  // ============================================================================

  /**
   * Configure persistence settings
   */
  configurePersistence(config: Partial<TokenPersistenceConfig>): void {
    this.persistenceConfig = { ...this.persistenceConfig, ...config };

    // Restart auto-save if interval changed
    if (config.autoSaveIntervalMs !== undefined) {
      this.stopAutoSave();
      if (config.autoSaveIntervalMs > 0) {
        this.startAutoSave();
      }
    }
  }

  /**
   * Start auto-save timer
   */
  startAutoSave(): void {
    if (this.autoSaveTimer) return;

    if (this.persistenceConfig.autoSaveIntervalMs > 0) {
      this.autoSaveTimer = setInterval(() => {
        if (this.isDirty) {
          this.save().catch(err => {
            console.warn('[TokenMetricsCollector] Auto-save failed:', err);
          });
        }
      }, this.persistenceConfig.autoSaveIntervalMs);
    }
  }

  /**
   * Stop auto-save timer
   */
  stopAutoSave(): void {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
  }

  /**
   * Save metrics to persistent storage
   */
  async save(): Promise<void> {
    const fs = await import('fs');
    const path = await import('path');

    const data: PersistedTokenData = {
      version: '1.0.0',
      sessionId: this.sessionId,
      sessionStartTime: this.sessionStartTime,
      taskMetrics: this.taskMetrics.slice(-this.persistenceConfig.maxMetricsInMemory),
      optimizationStats: {
        cacheHits: this.cacheHits,
        earlyExits: this.earlyExits,
        totalTokensSaved: this.totalTokensSaved,
        totalPatternsReused: this.totalPatternsReused,
      },
      lastSavedAt: Date.now(),
    };

    const filePath = path.resolve(this.persistenceConfig.filePath);
    const dirPath = path.dirname(filePath);

    // Ensure directory exists
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }

    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    this.isDirty = false;
  }

  /**
   * Load metrics from persistent storage
   */
  async load(): Promise<boolean> {
    const fs = await import('fs');
    const path = await import('path');

    const filePath = path.resolve(this.persistenceConfig.filePath);

    if (!fs.existsSync(filePath)) {
      return false;
    }

    try {
      const content = fs.readFileSync(filePath, 'utf-8');
      const data: PersistedTokenData = JSON.parse(content);

      // Validate version
      if (!data.version || !data.version.startsWith('1.')) {
        console.warn('[TokenMetricsCollector] Incompatible data version, skipping load');
        return false;
      }

      // Restore state (merge with current session)
      // Keep current session ID but append historical metrics
      const historicalMetrics = data.taskMetrics || [];
      this.taskMetrics = [...historicalMetrics, ...this.taskMetrics];

      // Accumulate optimization stats from history
      this.cacheHits += data.optimizationStats?.cacheHits || 0;
      this.earlyExits += data.optimizationStats?.earlyExits || 0;
      this.totalTokensSaved += data.optimizationStats?.totalTokensSaved || 0;
      this.totalPatternsReused += data.optimizationStats?.totalPatternsReused || 0;

      // Rebuild aggregations
      for (const metric of historicalMetrics) {
        this.updateAgentMetrics(metric.agentId, metric.usage, metric.patternReused, metric.tokensSaved || 0);
        this.updateDomainMetrics(metric.domain, metric.usage);
      }

      // Trim if needed
      if (this.taskMetrics.length > this.persistenceConfig.maxMetricsInMemory) {
        this.taskMetrics = this.taskMetrics.slice(-this.persistenceConfig.maxMetricsInMemory);
      }

      return true;
    } catch (error) {
      console.warn('[TokenMetricsCollector] Failed to load persisted data:', error);
      return false;
    }
  }

  /**
   * Get persistence file path
   */
  getPersistenceFilePath(): string {
    return this.persistenceConfig.filePath;
  }

  /**
   * Check if there are unsaved changes
   */
  hasUnsavedChanges(): boolean {
    return this.isDirty;
  }

  // ============================================================================
  // Private Helper Methods
  // ============================================================================

  private ensureInitialized(): void {
    if (!this.initialized) {
      this.initialize();
    }
  }

  private calculateCost(usage: TokenUsage): number {
    const inputCost = usage.inputTokens * this.costConfig.costPerInputToken;
    const outputCost = usage.outputTokens * this.costConfig.costPerOutputToken;
    return Math.round((inputCost + outputCost) * 100000) / 100000; // Round to 5 decimal places
  }

  private filterByTimeframe(metrics: TaskTokenMetric[], timeframe?: Timeframe): TaskTokenMetric[] {
    if (!timeframe) return metrics;

    const now = Date.now();
    let cutoff: number;

    switch (timeframe) {
      case '1h':
        cutoff = now - 60 * 60 * 1000;
        break;
      case '24h':
        cutoff = now - 24 * 60 * 60 * 1000;
        break;
      case '7d':
        cutoff = now - 7 * 24 * 60 * 60 * 1000;
        break;
      case '30d':
        cutoff = now - 30 * 24 * 60 * 60 * 1000;
        break;
      default:
        return metrics;
    }

    return metrics.filter(m => m.timestamp >= cutoff);
  }

  private aggregateTokenUsage(metrics: TaskTokenMetric[]): TokenUsage {
    let inputTokens = 0;
    let outputTokens = 0;
    let totalTokens = 0;
    let estimatedCostUsd = 0;

    for (const metric of metrics) {
      inputTokens += metric.usage.inputTokens;
      outputTokens += metric.usage.outputTokens;
      totalTokens += metric.usage.totalTokens;
      estimatedCostUsd += metric.usage.estimatedCostUsd || 0;
    }

    return {
      inputTokens,
      outputTokens,
      totalTokens,
      estimatedCostUsd: Math.round(estimatedCostUsd * 100000) / 100000,
    };
  }

  private aggregateAgentMetrics(agentId: string, tasks: TaskTokenMetric[]): AgentTokenMetrics {
    let totalInputTokens = 0;
    let totalOutputTokens = 0;
    let totalTokens = 0;
    let totalCost = 0;
    let patternsReused = 0;
    let estimatedTokensSaved = 0;

    for (const task of tasks) {
      totalInputTokens += task.usage.inputTokens;
      totalOutputTokens += task.usage.outputTokens;
      totalTokens += task.usage.totalTokens;
      totalCost += task.usage.estimatedCostUsd || 0;
      if (task.patternReused) patternsReused++;
      estimatedTokensSaved += task.tokensSaved || 0;
    }

    return {
      agentId,
      totalInputTokens,
      totalOutputTokens,
      totalTokens,
      totalCost: Math.round(totalCost * 100000) / 100000,
      tasksExecuted: tasks.length,
      patternsReused,
      estimatedTokensSaved,
    };
  }

  private updateAgentMetrics(
    agentId: string,
    usage: TokenUsage,
    patternReused: boolean,
    tokensSaved: number
  ): void {
    const existing = this.agentMetrics.get(agentId);

    if (existing) {
      existing.totalInputTokens += usage.inputTokens;
      existing.totalOutputTokens += usage.outputTokens;
      existing.totalTokens += usage.totalTokens;
      existing.totalCost += usage.estimatedCostUsd || 0;
      existing.tasksExecuted++;
      if (patternReused) existing.patternsReused++;
      existing.estimatedTokensSaved += tokensSaved;
    } else {
      this.agentMetrics.set(agentId, {
        agentId,
        totalInputTokens: usage.inputTokens,
        totalOutputTokens: usage.outputTokens,
        totalTokens: usage.totalTokens,
        totalCost: usage.estimatedCostUsd || 0,
        tasksExecuted: 1,
        patternsReused: patternReused ? 1 : 0,
        estimatedTokensSaved: tokensSaved,
      });
    }
  }

  private updateDomainMetrics(domain: string, usage: TokenUsage): void {
    const existing = this.domainMetrics.get(domain);

    if (existing) {
      existing.inputTokens += usage.inputTokens;
      existing.outputTokens += usage.outputTokens;
      existing.totalTokens += usage.totalTokens;
      existing.estimatedCostUsd = (existing.estimatedCostUsd || 0) + (usage.estimatedCostUsd || 0);
    } else {
      this.domainMetrics.set(domain, { ...usage });
    }
  }

  private generateRecommendations(metrics: TaskTokenMetric[]): string[] {
    const recommendations: string[] = [];

    if (metrics.length === 0) {
      return ['No token usage data available yet. Start executing tasks to track consumption.'];
    }

    // Analyze pattern reuse rate
    const reuseRate = metrics.filter(m => m.patternReused).length / metrics.length;
    if (reuseRate < 0.2) {
      recommendations.push('Low pattern reuse rate detected. Consider enabling pattern caching for similar tasks.');
    } else if (reuseRate > 0.5) {
      recommendations.push('Good pattern reuse rate. Continue leveraging cached patterns for token savings.');
    }

    // Analyze by domain for high consumers
    const domainUsage = new Map<string, number>();
    for (const metric of metrics) {
      const current = domainUsage.get(metric.domain) || 0;
      domainUsage.set(metric.domain, current + metric.usage.totalTokens);
    }

    const sortedDomains = Array.from(domainUsage.entries())
      .sort((a, b) => b[1] - a[1]);

    if (sortedDomains.length > 0) {
      const topDomain = sortedDomains[0];
      recommendations.push(
        `Highest token consumer: ${topDomain[0]} (${topDomain[1].toLocaleString()} tokens). Consider optimizing prompts or increasing caching.`
      );
    }

    // Check for high output-to-input ratio (potential verbose responses)
    const totalInput = metrics.reduce((sum, m) => sum + m.usage.inputTokens, 0);
    const totalOutput = metrics.reduce((sum, m) => sum + m.usage.outputTokens, 0);
    const outputRatio = totalOutput / (totalInput || 1);

    if (outputRatio > 2) {
      recommendations.push('High output-to-input token ratio. Consider requesting more concise responses.');
    }

    // Check cache hit effectiveness
    if (this.cacheHits === 0 && metrics.length > 10) {
      recommendations.push('No cache hits detected. Enable response caching to reduce duplicate API calls.');
    }

    // Check early exit usage
    if (this.earlyExits === 0 && metrics.length > 20) {
      recommendations.push('Early exit optimization not utilized. Enable high-confidence pattern matching to skip unnecessary LLM calls.');
    }

    return recommendations;
  }
}

// ============================================================================
// Dashboard Summary (ADR-062: Token Budget Dashboard)
// ============================================================================

/**
 * Input metrics for the dashboard summary formatter.
 */
export interface DashboardSummaryMetrics {
  totalTokens?: number;
  totalCostUsd?: number;
  savedTokens?: number;
  savedCostUsd?: number;
  budgetLimitUsd?: number;
  tierSplit?: Record<string, number>;
}

/**
 * Format a number with comma separators (e.g. 1234567 -> "1,234,567").
 */
function formatWithCommas(n: number): string {
  return n.toLocaleString('en-US');
}

/**
 * Format a compact, terminal-friendly token budget dashboard summary.
 *
 * Feature flag: respects `process.env.AQE_TOKEN_DASHBOARD_ENABLED`.
 * When set to 'false', returns a disabled notice.
 *
 * @param metrics - Optional metrics to display. When omitted, pulls from
 *   the live singleton session data.
 * @returns Multi-line dashboard string suitable for terminal output.
 */
export function formatDashboardSummary(metrics?: DashboardSummaryMetrics): string {
  // Feature flag check
  if (process.env.AQE_TOKEN_DASHBOARD_ENABLED === 'false') {
    return 'Token dashboard disabled (AQE_TOKEN_DASHBOARD_ENABLED=false)';
  }

  // If no explicit metrics provided, pull from the live collector
  if (!metrics) {
    const session = TokenMetricsCollector.getSessionSummary();
    const totalTokens = session.totalUsage.totalTokens;
    const totalCostUsd = session.totalUsage.estimatedCostUsd ?? 0;
    const savedTokens = session.optimizationStats.tokensSaved;
    // Estimate saved cost proportionally
    const costPerToken = totalTokens > 0 ? totalCostUsd / totalTokens : 0;
    const savedCostUsd = savedTokens * costPerToken;

    metrics = {
      totalTokens,
      totalCostUsd,
      savedTokens,
      savedCostUsd,
    };
  }

  const totalTokens = metrics.totalTokens ?? 0;
  const totalCostUsd = metrics.totalCostUsd ?? 0;
  const savedTokens = metrics.savedTokens ?? 0;
  const savedCostUsd = metrics.savedCostUsd ?? 0;
  const budgetLimitUsd = metrics.budgetLimitUsd;

  if (totalTokens === 0 && savedTokens === 0) {
    return 'Token Dashboard: No data available';
  }

  // Line 1: Usage and savings
  let line1 = `Token Usage: ${formatWithCommas(totalTokens)} tokens ($${totalCostUsd.toFixed(2)})`;
  if (savedTokens > 0) {
    line1 += ` | Saved: ${formatWithCommas(savedTokens)} tokens ($${savedCostUsd.toFixed(2)}) via pattern reuse`;
  }

  // Line 2: Budget and tier split
  const parts: string[] = [];

  if (budgetLimitUsd !== undefined && budgetLimitUsd > 0) {
    const utilPct = Math.round((totalCostUsd / budgetLimitUsd) * 100);
    parts.push(`Budget: $${totalCostUsd.toFixed(2)} / $${budgetLimitUsd.toFixed(2)} (${utilPct}%)`);
  }

  if (metrics.tierSplit && Object.keys(metrics.tierSplit).length > 0) {
    const tierParts = Object.entries(metrics.tierSplit)
      .sort((a, b) => b[1] - a[1])
      .map(([name, pct]) => `${name} ${pct}%`);
    parts.push(`Tier split: ${tierParts.join(' | ')}`);
  }

  if (parts.length === 0) {
    return line1;
  }

  return `${line1}\n${parts.join(' | ')}`;
}

// ============================================================================
// Singleton Export
// ============================================================================

/**
 * Global singleton instance for token metrics collection
 */
export const TokenMetricsCollector = new TokenMetricsCollectorImpl();

/**
 * Export class for testing
 */
export { TokenMetricsCollectorImpl };

/**
 * Helper to format cost as USD string
 */
export function formatCostUsd(cost: number): string {
  return `$${cost.toFixed(2)}`;
}

/**
 * Helper to estimate tokens from text (rough approximation)
 * Uses ~4 characters per token as a general rule
 */
export function estimateTokens(text: string): number {
  return Math.ceil(text.length / 4);
}

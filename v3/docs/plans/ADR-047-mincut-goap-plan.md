# ADR-047: MinCut Self-Organizing QE Integration - GOAP Implementation Plan

**Created:** 2026-01-16
**Status:** Ready for Execution
**Generated By:** Goal-Oriented Action Planner
**Total Phases:** 7 (P0-P6)
**Estimated Duration:** 10 weeks

---

## 1. World State Definition

### 1.1 Current State (Initial World State)

```typescript
const CURRENT_STATE: MinCutWorldState = {
  // Foundation Infrastructure
  infrastructure: {
    queenCoordinatorExists: true,         // ADR-008: Queen Coordinator implemented
    goapPlannerExists: true,              // ADR-046: GOAP Planner with A* search
    dreamEngineExists: true,              // ADR-046: Dream Engine implemented
    reasoningBankExists: true,            // ADR-021: ReasoningBank with HNSW
    hybridMemoryBackendExists: true,      // Unified memory persistence
    mcpToolRegistryExists: true,          // MCP tools registered
  },

  // MinCut Components (all false - to be implemented)
  mincut: {
    calculatorImplemented: false,
    healthMonitorImplemented: false,
    strangeLoopHealerImplemented: false,
    mincutIntegratedWithQueen: false,
    mincutTablesCreated: false,
  },

  // Self-Healing Components
  selfHealing: {
    swarmObserverImplemented: false,
    selfModelImplemented: false,
    healingControllerImplemented: false,
    autoSpawnEnabled: false,
    predictionAccuracy: 0,
    mttrSeconds: Infinity,
  },

  // Causal Discovery Components
  causalDiscovery: {
    causalGraphImplemented: false,
    rootCauseFinderImplemented: false,
    stdpIntegrated: false,
    rootCauseLatencyMs: Infinity,
    causalAccuracy: 0,
  },

  // Morphogenetic Components
  morphogenetic: {
    growthSignalsImplemented: false,
    testSpawnerImplemented: false,
    signalDiffusionEnabled: false,
    organicTestGrowthActive: false,
  },

  // Time Crystal Components
  timeCrystal: {
    schedulerFreeCoordination: false,
    kuramotoOscillatorsImplemented: false,
    phaseSynchronizationActive: false,
  },

  // Neural GOAP Components
  neuralGOAP: {
    qValuePlannerImplemented: false,
    replayBufferImplemented: false,
    costsLearned: false,
    planEfficiencyImprovement: 0,
  },

  // Dream x Strange Loop Components
  dreamStrangeLoop: {
    hypotheticalScenariosEnabled: false,
    strangeLoopIntegrated: false,
    temporalAttractorsActive: false,
    qualityEquilibriumReached: false,
  },

  // Test State
  tests: {
    mincutUnitTests: false,
    selfHealingTests: false,
    causalTests: false,
    morphogeneticTests: false,
    timeCrystalTests: false,
    neuralGOAPTests: false,
    dreamStrangeLoopTests: false,
    integrationTests: false,
  },

  // Documentation
  docs: {
    mincutApiDocs: false,
    architectureDiagram: false,
    usageExamples: false,
  },
};
```

### 1.2 Goal State (Target World State)

```typescript
const GOAL_STATE: MinCutWorldState = {
  // All infrastructure must remain functional
  infrastructure: {
    queenCoordinatorExists: true,
    goapPlannerExists: true,
    dreamEngineExists: true,
    reasoningBankExists: true,
    hybridMemoryBackendExists: true,
    mcpToolRegistryExists: true,
  },

  // MinCut fully implemented
  mincut: {
    calculatorImplemented: true,
    healthMonitorImplemented: true,
    strangeLoopHealerImplemented: true,
    mincutIntegratedWithQueen: true,
    mincutTablesCreated: true,
  },

  // Self-Healing fully operational
  selfHealing: {
    swarmObserverImplemented: true,
    selfModelImplemented: true,
    healingControllerImplemented: true,
    autoSpawnEnabled: true,
    predictionAccuracy: { min: 70 },      // > 70% accuracy
    mttrSeconds: { max: 30 },             // < 30s MTTR
  },

  // Causal Discovery operational
  causalDiscovery: {
    causalGraphImplemented: true,
    rootCauseFinderImplemented: true,
    stdpIntegrated: true,
    rootCauseLatencyMs: { max: 5000 },   // < 5s latency
    causalAccuracy: { min: 80 },         // > 80% accuracy
  },

  // Morphogenetic test generation
  morphogenetic: {
    growthSignalsImplemented: true,
    testSpawnerImplemented: true,
    signalDiffusionEnabled: true,
    organicTestGrowthActive: true,
  },

  // Time Crystal scheduling
  timeCrystal: {
    schedulerFreeCoordination: true,
    kuramotoOscillatorsImplemented: true,
    phaseSynchronizationActive: true,
  },

  // Neural GOAP optimization
  neuralGOAP: {
    qValuePlannerImplemented: true,
    replayBufferImplemented: true,
    costsLearned: true,
    planEfficiencyImprovement: { min: 20 }, // >= 20% improvement
  },

  // Dream x Strange Loop meta-learning
  dreamStrangeLoop: {
    hypotheticalScenariosEnabled: true,
    strangeLoopIntegrated: true,
    temporalAttractorsActive: true,
    qualityEquilibriumReached: true,
  },

  // All tests passing
  tests: {
    mincutUnitTests: true,
    selfHealingTests: true,
    causalTests: true,
    morphogeneticTests: true,
    timeCrystalTests: true,
    neuralGOAPTests: true,
    dreamStrangeLoopTests: true,
    integrationTests: true,
  },

  // Documentation complete
  docs: {
    mincutApiDocs: true,
    architectureDiagram: true,
    usageExamples: true,
  },
};
```

---

## 2. Action Library

### 2.1 Phase P0: MinCut Foundation (2 days)

| Action ID | Name | Preconditions | Effects | Cost | Agent |
|-----------|------|---------------|---------|------|-------|
| `P0-A01` | `create-mincut-module-structure` | `infrastructure.queenCoordinatorExists: true` | `mincut.moduleStructureCreated: true` | 0.5 | architect |
| `P0-A02` | `implement-mincut-calculator` | `mincut.moduleStructureCreated: true` | `mincut.calculatorImplemented: true` | 2.0 | coder |
| `P0-A03` | `implement-mincut-health-monitor` | `mincut.calculatorImplemented: true` | `mincut.healthMonitorImplemented: true` | 2.0 | coder |
| `P0-A04` | `create-mincut-tables-schema` | `infrastructure.hybridMemoryBackendExists: true` | `mincut.mincutTablesCreated: true` | 1.0 | coder |
| `P0-A05` | `integrate-mincut-with-queen` | `mincut.healthMonitorImplemented: true`, `mincut.mincutTablesCreated: true` | `mincut.mincutIntegratedWithQueen: true` | 2.0 | coder |
| `P0-A06` | `write-mincut-unit-tests` | `mincut.calculatorImplemented: true` | `tests.mincutUnitTests: true` | 1.5 | tester |

#### Detailed Action Specifications

```typescript
// P0-A01: Create Module Structure
const createMincutModuleStructure: GOAPAction = {
  id: 'P0-A01',
  name: 'create-mincut-module-structure',
  description: 'Create directory structure for MinCut components',
  agentType: 'architect',
  preconditions: {
    'infrastructure.queenCoordinatorExists': true,
  },
  effects: {
    'mincut.moduleStructureCreated': true,
  },
  cost: 0.5,
  estimatedDurationMs: 15 * 60 * 1000, // 15 minutes
  successRate: 0.98,
  category: 'analysis',
  qeDomain: 'code-intelligence',
};

// P0-A02: Implement MinCut Calculator
const implementMincutCalculator: GOAPAction = {
  id: 'P0-A02',
  name: 'implement-mincut-calculator',
  description: `
    Implement approximate MinCut calculation using minimum weighted degree heuristic.
    Port from RuVector strange_loop/main.rs:

    function approxMincut(graph: SwarmGraph): number {
      return Math.min(...graph.vertices.map(v => graph.weightedDegree(v)));
    }

    Also implement:
    - SwarmGraph class with vertices, edges, weights
    - weightedDegree(vertex) method
    - findWeakVertices() method
    - Efficient adjacency list representation
  `,
  agentType: 'coder',
  preconditions: {
    'mincut.moduleStructureCreated': true,
  },
  effects: {
    'mincut.calculatorImplemented': true,
  },
  cost: 2.0,
  estimatedDurationMs: 2 * 60 * 60 * 1000, // 2 hours
  successRate: 0.9,
  category: 'analysis',
  qeDomain: 'code-intelligence',
};

// P0-A03: Implement Health Monitor
const implementMincutHealthMonitor: GOAPAction = {
  id: 'P0-A03',
  name: 'implement-mincut-health-monitor',
  description: `
    Create MinCutHealthMonitor that tracks swarm topology health.

    Features:
    - Real-time MinCut value calculation
    - Connectivity threshold alerts (default: 2.0)
    - Integration with QueenHealth interface
    - Metrics emission for dashboard
    - Event publishing for topology changes
  `,
  agentType: 'coder',
  preconditions: {
    'mincut.calculatorImplemented': true,
  },
  effects: {
    'mincut.healthMonitorImplemented': true,
  },
  cost: 2.0,
  estimatedDurationMs: 2 * 60 * 60 * 1000, // 2 hours
  successRate: 0.88,
  category: 'analysis',
  qeDomain: 'quality-assessment',
};
```

### 2.2 Phase P1: Strange Loop Self-Healing (1 week)

| Action ID | Name | Preconditions | Effects | Cost | Agent |
|-----------|------|---------------|---------|------|-------|
| `P1-A01` | `implement-swarm-observer` | `mincut.mincutIntegratedWithQueen: true` | `selfHealing.swarmObserverImplemented: true` | 3.0 | coder |
| `P1-A02` | `implement-self-model` | `selfHealing.swarmObserverImplemented: true` | `selfHealing.selfModelImplemented: true` | 4.0 | coder |
| `P1-A03` | `implement-healing-controller` | `selfHealing.selfModelImplemented: true` | `selfHealing.healingControllerImplemented: true` | 3.5 | coder |
| `P1-A04` | `implement-strange-loop-healer` | `selfHealing.healingControllerImplemented: true` | `mincut.strangeLoopHealerImplemented: true` | 4.0 | coder |
| `P1-A05` | `integrate-auto-spawn` | `mincut.strangeLoopHealerImplemented: true` | `selfHealing.autoSpawnEnabled: true` | 2.0 | coder |
| `P1-A06` | `tune-prediction-accuracy` | `selfHealing.autoSpawnEnabled: true` | `selfHealing.predictionAccuracy: { delta: 70 }` | 3.0 | ml-developer |
| `P1-A07` | `optimize-mttr` | `selfHealing.predictionAccuracy: { min: 70 }` | `selfHealing.mttrSeconds: { set: 30 }` | 2.5 | coder |
| `P1-A08` | `write-self-healing-tests` | `selfHealing.autoSpawnEnabled: true` | `tests.selfHealingTests: true` | 2.0 | tester |

#### Core Algorithm: Strange Loop Cycle

```typescript
/**
 * The think() cycle from strange_loop/main.rs
 * Observe -> Model -> Decide -> Act
 */
interface StrangeLoopCycle {
  // Step 1: Observe self
  observe(swarm: SwarmGraph): ObservationResult;

  // Step 2: Update self-model with observations
  model(observation: ObservationResult): void;

  // Step 3: Decide on reorganization action
  decide(): ReorganizationAction;

  // Step 4: Execute the action
  act(action: ReorganizationAction): Promise<void>;

  // Check convergence
  checkConvergence(): boolean;
}

type ReorganizationAction =
  | { type: 'spawn_agent'; domain: DomainName; capabilities: string[] }
  | { type: 'reinforce_edge'; source: string; target: string }
  | { type: 'remove_weak_vertex'; agentId: string }
  | { type: 'rebalance_load'; fromAgent: string; toAgent: string }
  | { type: 'no_action' };
```

### 2.3 Phase P2: Causal Test Failure Discovery (1 week)

| Action ID | Name | Preconditions | Effects | Cost | Agent |
|-----------|------|---------------|---------|------|-------|
| `P2-A01` | `create-causal-module-structure` | `tests.selfHealingTests: true` | `causalDiscovery.moduleCreated: true` | 0.5 | architect |
| `P2-A02` | `implement-causal-graph` | `causalDiscovery.moduleCreated: true` | `causalDiscovery.causalGraphImplemented: true` | 4.0 | coder |
| `P2-A03` | `implement-root-cause-finder` | `causalDiscovery.causalGraphImplemented: true` | `causalDiscovery.rootCauseFinderImplemented: true` | 4.0 | coder |
| `P2-A04` | `integrate-stdp-learning` | `causalDiscovery.rootCauseFinderImplemented: true` | `causalDiscovery.stdpIntegrated: true` | 3.5 | ml-developer |
| `P2-A05` | `optimize-root-cause-latency` | `causalDiscovery.stdpIntegrated: true` | `causalDiscovery.rootCauseLatencyMs: { set: 5000 }` | 2.5 | coder |
| `P2-A06` | `tune-causal-accuracy` | `causalDiscovery.rootCauseLatencyMs: { max: 5000 }` | `causalDiscovery.causalAccuracy: { delta: 80 }` | 3.0 | ml-developer |
| `P2-A07` | `write-causal-tests` | `causalDiscovery.stdpIntegrated: true` | `tests.causalTests: true` | 2.0 | tester |

#### STDP Learning Algorithm

```typescript
/**
 * Spike-Timing-Dependent Plasticity for causal edge weighting
 *
 * When test A fails 50ms before test B:
 * - Increase edge weight A -> B (potential causal relationship)
 *
 * Learning rule: Δw = η * exp(-Δt / τ)
 * where:
 * - Δt = time difference between failure events
 * - η = learning rate
 * - τ = time constant (default: 100ms)
 */
interface STDPLearner {
  recordFailure(testId: string, timestamp: number): void;
  updateEdgeWeights(): void;
  getTopCausalEdges(limit: number): CausalEdge[];
}
```

### 2.4 Phase P3: Morphogenetic Test Generation (2 weeks)

| Action ID | Name | Preconditions | Effects | Cost | Agent |
|-----------|------|---------------|---------|------|-------|
| `P3-A01` | `create-morphogenetic-module` | `tests.causalTests: true` | `morphogenetic.moduleCreated: true` | 0.5 | architect |
| `P3-A02` | `implement-growth-signals` | `morphogenetic.moduleCreated: true` | `morphogenetic.growthSignalsImplemented: true` | 4.0 | coder |
| `P3-A03` | `implement-test-spawner` | `morphogenetic.growthSignalsImplemented: true` | `morphogenetic.testSpawnerImplemented: true` | 5.0 | coder |
| `P3-A04` | `implement-signal-diffusion` | `morphogenetic.testSpawnerImplemented: true` | `morphogenetic.signalDiffusionEnabled: true` | 4.0 | coder |
| `P3-A05` | `integrate-with-test-generation` | `morphogenetic.signalDiffusionEnabled: true` | `morphogenetic.integratedWithTestGen: true` | 3.0 | coder |
| `P3-A06` | `enable-organic-growth` | `morphogenetic.integratedWithTestGen: true` | `morphogenetic.organicTestGrowthActive: true` | 2.0 | coder |
| `P3-A07` | `write-morphogenetic-tests` | `morphogenetic.organicTestGrowthActive: true` | `tests.morphogeneticTests: true` | 2.5 | tester |

#### Morphogenetic Growth Rules

```typescript
/**
 * Bio-inspired growth rules from morphogenetic/main.rs
 */
interface GrowthRules {
  // Low connectivity -> spawn new test
  shouldSpawn(node: TestNode, signal: number): boolean {
    return signal > 0.5 && node.connections.length < 3;
  }

  // High degree -> branch/specialize
  shouldBranch(node: TestNode, signal: number): boolean {
    return signal > 0.6 && node.connections.length > 5;
  }

  // Weak cut -> reinforce with more tests
  shouldReinforce(node: TestNode, signal: number): boolean {
    return signal > 0.4 && node.localMincut < 2.0;
  }

  // Otherwise stable
  isStable(node: TestNode, signal: number): boolean {
    return !this.shouldSpawn(node, signal) &&
           !this.shouldBranch(node, signal) &&
           !this.shouldReinforce(node, signal);
  }
}
```

### 2.5 Phase P4: Time Crystal CI/CD (1 week)

| Action ID | Name | Preconditions | Effects | Cost | Agent |
|-----------|------|---------------|---------|------|-------|
| `P4-A01` | `implement-kuramoto-oscillators` | `tests.morphogeneticTests: true` | `timeCrystal.kuramotoOscillatorsImplemented: true` | 4.0 | coder |
| `P4-A02` | `implement-phase-synchronization` | `timeCrystal.kuramotoOscillatorsImplemented: true` | `timeCrystal.phaseSynchronizationActive: true` | 3.5 | coder |
| `P4-A03` | `remove-scheduler-dependency` | `timeCrystal.phaseSynchronizationActive: true` | `timeCrystal.schedulerFreeCoordination: true` | 3.0 | coder |
| `P4-A04` | `write-time-crystal-tests` | `timeCrystal.schedulerFreeCoordination: true` | `tests.timeCrystalTests: true` | 2.0 | tester |

#### Kuramoto Model for Test Coordination

```typescript
/**
 * Kuramoto oscillator model for scheduler-free test coordination
 *
 * Each test runner is an oscillator with phase θ
 * Natural frequency ω_i (based on test duration)
 * Coupling strength K (coordination level)
 *
 * dθ_i/dt = ω_i + (K/N) * Σ sin(θ_j - θ_i)
 */
interface KuramotoCoordinator {
  // Initialize oscillators for test runners
  initializeOscillators(runners: TestRunner[]): void;

  // Update phases based on coupling
  updatePhases(deltaT: number): void;

  // Check if runners are synchronized
  isSynchronized(threshold: number): boolean;

  // Get next test to run (phase-based selection)
  getNextTest(): TestCase | null;
}
```

### 2.6 Phase P5: Neural GOAP Optimizer (2 weeks)

| Action ID | Name | Preconditions | Effects | Cost | Agent |
|-----------|------|---------------|---------|------|-------|
| `P5-A01` | `create-neural-optimizer-module` | `tests.timeCrystalTests: true` | `neuralGOAP.moduleCreated: true` | 0.5 | architect |
| `P5-A02` | `implement-q-value-planner` | `neuralGOAP.moduleCreated: true`, `infrastructure.goapPlannerExists: true` | `neuralGOAP.qValuePlannerImplemented: true` | 5.0 | coder |
| `P5-A03` | `implement-plan-replay-buffer` | `neuralGOAP.qValuePlannerImplemented: true` | `neuralGOAP.replayBufferImplemented: true` | 3.5 | coder |
| `P5-A04` | `integrate-with-goap-planner` | `neuralGOAP.replayBufferImplemented: true` | `neuralGOAP.integratedWithGOAP: true` | 3.0 | coder |
| `P5-A05` | `train-initial-q-values` | `neuralGOAP.integratedWithGOAP: true` | `neuralGOAP.costsLearned: true` | 4.0 | ml-developer |
| `P5-A06` | `measure-efficiency-improvement` | `neuralGOAP.costsLearned: true` | `neuralGOAP.planEfficiencyImprovement: { delta: 20 }` | 2.0 | tester |
| `P5-A07` | `write-neural-goap-tests` | `neuralGOAP.planEfficiencyImprovement: { min: 20 }` | `tests.neuralGOAPTests: true` | 2.5 | tester |

#### Q-Learning for GOAP Cost Optimization

```typescript
/**
 * Q-learning integration with GOAP planner
 *
 * State: Current world state (discretized)
 * Action: GOAP action to execute
 * Reward: -actual_cost (minimize cost)
 *
 * Q(s,a) = Q(s,a) + α * (r + γ * max_a' Q(s',a') - Q(s,a))
 */
interface QValuePlanner {
  // Get learned Q-value for action in state
  getQValue(state: V3WorldState, action: GOAPAction): number;

  // Update Q-value after execution
  updateQValue(
    state: V3WorldState,
    action: GOAPAction,
    reward: number,
    nextState: V3WorldState
  ): void;

  // Get action cost adjusted by Q-value
  getLearnedCost(action: GOAPAction, state: V3WorldState): number;

  // Store experience in replay buffer
  storeExperience(experience: PlanExperience): void;

  // Train on replay buffer batch
  trainOnBatch(batchSize: number): void;
}
```

### 2.7 Phase P6: Dream x Strange Loop Meta-Learning (3 weeks, Experimental)

| Action ID | Name | Preconditions | Effects | Cost | Agent |
|-----------|------|---------------|---------|------|-------|
| `P6-A01` | `design-meta-learning-architecture` | `tests.neuralGOAPTests: true`, `infrastructure.dreamEngineExists: true` | `dreamStrangeLoop.architectureDesigned: true` | 3.0 | architect |
| `P6-A02` | `implement-hypothetical-scenario-generator` | `dreamStrangeLoop.architectureDesigned: true` | `dreamStrangeLoop.hypotheticalScenariosEnabled: true` | 5.0 | coder |
| `P6-A03` | `integrate-strange-loop-with-dream` | `dreamStrangeLoop.hypotheticalScenariosEnabled: true`, `mincut.strangeLoopHealerImplemented: true` | `dreamStrangeLoop.strangeLoopIntegrated: true` | 4.0 | coder |
| `P6-A04` | `implement-temporal-attractors` | `dreamStrangeLoop.strangeLoopIntegrated: true` | `dreamStrangeLoop.temporalAttractorsActive: true` | 5.0 | coder |
| `P6-A05` | `implement-quality-equilibrium-detector` | `dreamStrangeLoop.temporalAttractorsActive: true` | `dreamStrangeLoop.equilibriumDetectorReady: true` | 3.5 | coder |
| `P6-A06` | `enable-quality-equilibrium-convergence` | `dreamStrangeLoop.equilibriumDetectorReady: true` | `dreamStrangeLoop.qualityEquilibriumReached: true` | 4.0 | ml-developer |
| `P6-A07` | `write-dream-strange-loop-tests` | `dreamStrangeLoop.qualityEquilibriumReached: true` | `tests.dreamStrangeLoopTests: true` | 3.0 | tester |

#### Dream x Strange Loop Integration

```typescript
/**
 * Meta-learning combining Dreams and Strange Loop
 *
 * 1. Dreams generate hypothetical scenarios during idle time
 * 2. Strange Loop tests hypotheses in simulated environments
 * 3. Temporal Attractors pull system toward "quality equilibrium"
 */
interface DreamStrangeLoopIntegration {
  // Generate hypothetical QE scenarios
  generateHypothetical(dreamCycle: DreamCycle): HypotheticalScenario[];

  // Test hypothesis using Strange Loop cycle
  testHypothesis(scenario: HypotheticalScenario): HypothesisResult;

  // Calculate distance to quality equilibrium
  distanceToEquilibrium(state: V3WorldState): number;

  // Apply temporal attractor force
  applyAttractorForce(state: V3WorldState): V3WorldState;

  // Check convergence to equilibrium
  hasConverged(threshold: number): boolean;
}
```

---

## 3. Optimal Execution Sequence

### 3.1 Critical Path Analysis

```
P0 (Foundation) → P1 (Self-Healing) → P2 (Causal Discovery)
                                    ↘
                                      → P3 (Morphogenetic) → P4 (Time Crystal)
                                                           ↘
                                                             → P5 (Neural GOAP) → P6 (Meta-Learning)
```

### 3.2 Parallel Execution Opportunities

| Phase | Can Parallelize With | Notes |
|-------|---------------------|-------|
| P0 | None | Foundation must complete first |
| P1 | P2 starts after P1-A04 completes | Causal graph independent of self-healing |
| P2 | P3 starts after P2-A03 completes | Morphogenetic independent of STDP tuning |
| P3 | P4 starts after P3-A04 completes | Time Crystal independent of test gen integration |
| P4 | P5 starts after P4-A02 completes | Neural GOAP independent of scheduler removal |
| P5 | P6 starts after P5-A04 completes | Meta-learning independent of Q-value training |
| P6 | None | Final experimental phase |

### 3.3 Execution Timeline (Optimal)

```
Week 1:  P0 (all) + P1-A01, P1-A02 (start)
Week 2:  P1 (complete A02-A05) + P2-A01, P2-A02 (start in parallel)
Week 3:  P1 (complete) + P2 (complete A02-A04)
Week 4:  P2 (complete) + P3-A01, P3-A02 (start)
Week 5:  P3 (complete A02-A04) + P4-A01 (start in parallel)
Week 6:  P3 (complete) + P4 (complete A01-A02)
Week 7:  P4 (complete) + P5-A01, P5-A02 (start)
Week 8:  P5 (complete A02-A04)
Week 9:  P5 (complete) + P6-A01, P6-A02 (start)
Week 10: P6 (complete)
```

---

## 4. Agent Assignments

### 4.1 Agent Roster

| Agent Type | Expertise | Phases |
|------------|-----------|--------|
| `architect` | System design, module structure | P0, P1, P2, P3, P5, P6 |
| `coder` | TypeScript, algorithms | All phases |
| `tester` | Unit/integration testing | All phases |
| `ml-developer` | ML algorithms, RL | P1, P2, P5, P6 |
| `researcher` | Algorithm research | P4 (Kuramoto), P6 |

### 4.2 Detailed Assignments

```typescript
const agentAssignments: Record<string, AgentAssignment[]> = {
  'architect': [
    { phase: 'P0', actions: ['P0-A01'], focus: 'Module structure' },
    { phase: 'P1', actions: ['P1-design'], focus: 'Self-healing architecture' },
    { phase: 'P3', actions: ['P3-A01'], focus: 'Morphogenetic design' },
    { phase: 'P5', actions: ['P5-A01'], focus: 'Neural optimizer architecture' },
    { phase: 'P6', actions: ['P6-A01'], focus: 'Meta-learning design' },
  ],

  'coder': [
    { phase: 'P0', actions: ['P0-A02', 'P0-A03', 'P0-A04', 'P0-A05'], focus: 'Core MinCut implementation' },
    { phase: 'P1', actions: ['P1-A01', 'P1-A02', 'P1-A03', 'P1-A04', 'P1-A05', 'P1-A07'], focus: 'Self-healing implementation' },
    { phase: 'P2', actions: ['P2-A02', 'P2-A03', 'P2-A05'], focus: 'Causal graph implementation' },
    { phase: 'P3', actions: ['P3-A02', 'P3-A03', 'P3-A04', 'P3-A05', 'P3-A06'], focus: 'Morphogenetic implementation' },
    { phase: 'P4', actions: ['P4-A01', 'P4-A02', 'P4-A03'], focus: 'Time Crystal implementation' },
    { phase: 'P5', actions: ['P5-A02', 'P5-A03', 'P5-A04'], focus: 'Neural GOAP implementation' },
    { phase: 'P6', actions: ['P6-A02', 'P6-A03', 'P6-A04', 'P6-A05'], focus: 'Meta-learning implementation' },
  ],

  'tester': [
    { phase: 'P0', actions: ['P0-A06'], focus: 'MinCut unit tests' },
    { phase: 'P1', actions: ['P1-A08'], focus: 'Self-healing tests' },
    { phase: 'P2', actions: ['P2-A07'], focus: 'Causal tests' },
    { phase: 'P3', actions: ['P3-A07'], focus: 'Morphogenetic tests' },
    { phase: 'P4', actions: ['P4-A04'], focus: 'Time Crystal tests' },
    { phase: 'P5', actions: ['P5-A06', 'P5-A07'], focus: 'Neural GOAP tests' },
    { phase: 'P6', actions: ['P6-A07'], focus: 'Meta-learning tests' },
  ],

  'ml-developer': [
    { phase: 'P1', actions: ['P1-A06'], focus: 'Self-model prediction tuning' },
    { phase: 'P2', actions: ['P2-A04', 'P2-A06'], focus: 'STDP learning, causal accuracy' },
    { phase: 'P5', actions: ['P5-A05'], focus: 'Q-value training' },
    { phase: 'P6', actions: ['P6-A06'], focus: 'Quality equilibrium tuning' },
  ],

  'researcher': [
    { phase: 'P4', actions: ['P4-research'], focus: 'Kuramoto oscillator research' },
    { phase: 'P6', actions: ['P6-research'], focus: 'Temporal attractor research' },
  ],
};
```

---

## 5. File Structure

### 5.1 Files to Create

```
v3/src/coordination/mincut/
├── index.ts                    # Module exports
├── mincut-calculator.ts        # P0: Graph algorithms
├── mincut-health-monitor.ts    # P0: Queen integration
├── swarm-graph.ts              # P0: Graph data structure
├── strange-loop-healer.ts      # P1: Self-healing controller
├── swarm-observer.ts           # P1: Topology observation
├── self-model.ts               # P1: Prediction model
└── healing-controller.ts       # P1: Action execution

v3/src/domains/defect-intelligence/causal/
├── index.ts                    # Module exports
├── causal-graph.ts             # P2: Failure propagation
├── root-cause-finder.ts        # P2: Root cause identification
├── stdp-learner.ts             # P2: STDP edge weighting
└── interfaces.ts               # P2: Type definitions

v3/src/domains/test-generation/morphogenetic/
├── index.ts                    # Module exports
├── growth-signals.ts           # P3: Signal diffusion
├── test-spawner.ts             # P3: Organic test creation
├── growth-rules.ts             # P3: Bio-inspired rules
└── interfaces.ts               # P3: Type definitions

v3/src/coordination/time-crystal/
├── index.ts                    # Module exports
├── kuramoto-coordinator.ts     # P4: Oscillator model
├── phase-synchronizer.ts       # P4: Phase alignment
└── interfaces.ts               # P4: Type definitions

v3/src/planning/neural-optimizer/
├── index.ts                    # Module exports
├── q-value-planner.ts          # P5: Q-learning integration
├── plan-replay-buffer.ts       # P5: Experience storage
├── cost-adjuster.ts            # P5: Learned cost adjustment
└── interfaces.ts               # P5: Type definitions

v3/src/learning/dream/meta-learning/
├── index.ts                    # Module exports
├── hypothetical-generator.ts   # P6: Scenario generation
├── strange-loop-integration.ts # P6: Dream-SL bridge
├── temporal-attractor.ts       # P6: Equilibrium attraction
├── equilibrium-detector.ts     # P6: Convergence detection
└── interfaces.ts               # P6: Type definitions

v3/tests/unit/coordination/mincut/
├── mincut-calculator.test.ts   # P0 tests
├── mincut-health-monitor.test.ts
├── strange-loop-healer.test.ts # P1 tests
└── swarm-observer.test.ts

v3/tests/unit/domains/defect-intelligence/causal/
├── causal-graph.test.ts        # P2 tests
├── root-cause-finder.test.ts
└── stdp-learner.test.ts

v3/tests/unit/domains/test-generation/morphogenetic/
├── growth-signals.test.ts      # P3 tests
├── test-spawner.test.ts
└── growth-rules.test.ts

v3/tests/unit/coordination/time-crystal/
├── kuramoto-coordinator.test.ts # P4 tests
└── phase-synchronizer.test.ts

v3/tests/unit/planning/neural-optimizer/
├── q-value-planner.test.ts     # P5 tests
├── plan-replay-buffer.test.ts
└── cost-adjuster.test.ts

v3/tests/unit/learning/dream/meta-learning/
├── hypothetical-generator.test.ts # P6 tests
├── strange-loop-integration.test.ts
└── temporal-attractor.test.ts

v3/tests/integration/
├── mincut-queen-integration.test.ts  # P0-P1 integration
├── causal-failure-tracking.test.ts   # P2 integration
├── morphogenetic-coverage.test.ts    # P3 integration
├── time-crystal-cicd.test.ts         # P4 integration
├── neural-goap-learning.test.ts      # P5 integration
└── dream-strange-loop.test.ts        # P6 integration
```

### 5.2 Files to Modify

| File | Phase | Modifications |
|------|-------|---------------|
| `v3/src/coordination/queen-coordinator.ts` | P0-P1 | Add MinCut health, self-healing hooks |
| `v3/src/mcp/tools/registry.ts` | P0, P2-P6 | Register new MCP tools |
| `v3/src/kernel/hybrid-backend.ts` | P0 | Add MinCut tables |
| `v3/src/kernel/unified-persistence.ts` | P0 | Add MinCut schema |
| `v3/src/learning/dream/dream-engine.ts` | P6 | Strange Loop integration |
| `v3/src/planning/goap-planner.ts` | P5 | Neural optimizer integration |
| `v3/src/coordination/index.ts` | P0-P1, P4 | Export new modules |
| `v3/src/domains/index.ts` | P2-P3 | Export new domains |
| `v3/src/planning/index.ts` | P5 | Export neural optimizer |

---

## 6. Risk Mitigations

### 6.1 Risk Matrix

| Risk | Likelihood | Impact | Phase | Mitigation |
|------|------------|--------|-------|------------|
| **Language barrier (Rust -> TS)** | High | Medium | All | Use TypeScript ports, not WASM; validate with unit tests |
| **Complexity explosion** | Medium | High | P5, P6 | Feature flags for each component; gradual rollout |
| **Emergent behavior debugging** | Medium | Medium | P1, P4, P6 | Comprehensive logging; state snapshots; replay capability |
| **Performance overhead** | Low | Medium | P1, P5 | Profile early; use Web Workers for computation |
| **Integration conflicts** | Medium | High | P0-P1 | Feature flags; canary releases; rollback capability |
| **Q-learning instability** | Medium | Medium | P5 | Conservative learning rates; experience replay; target networks |
| **Dream cycle latency** | Low | Low | P6 | Async execution; background workers |
| **Test generation quality** | Medium | Medium | P3 | Human review; quality gates; mutation testing |

### 6.2 Rollback Strategy

```typescript
interface RollbackStrategy {
  // Feature flags for each phase
  featureFlags: {
    'mincut.healthMetric': boolean;
    'mincut.strangeLoopHealing': boolean;
    'causal.stdpLearning': boolean;
    'morphogenetic.testGrowth': boolean;
    'timeCrystal.scheduling': boolean;
    'neural.goapOptimization': boolean;
    'dream.strangeLoopIntegration': boolean;
  };

  // Rollback procedure
  rollback(phase: string): void {
    // 1. Disable feature flag
    // 2. Clear phase-specific data
    // 3. Restore previous Queen configuration
    // 4. Run validation tests
  }
}
```

---

## 7. Success Criteria

### 7.1 Phase-Specific Criteria

| Phase | Criterion | Measurement | Target |
|-------|-----------|-------------|--------|
| **P0** | MinCut displayed in Queen status | Dashboard visibility | Visible |
| **P0** | Threshold alerts | Alert count when MinCut < 2.0 | >= 1 alert per test |
| **P1** | Auto agent spawning | Spawn events when MinCut < threshold | Automated |
| **P1** | Prediction accuracy | Correct weakness predictions / total | >= 70% |
| **P1** | MTTR | Mean time from failure detection to recovery | <= 30 seconds |
| **P2** | Root cause identification time | Time from failure to root cause | <= 5 seconds |
| **P2** | Causal graph accuracy | Correct causal edges / total edges | >= 80% |
| **P3** | Organic test growth | Tests spawned via morphogenetic signals | Active |
| **P3** | Coverage maintenance | Line coverage maintained | >= 80% |
| **P3** | Signal diffusion latency | Time for signal to propagate | <= 1 second |
| **P4** | Scheduler-free coordination | Tests run without explicit scheduler | Achieved |
| **P4** | Phase synchronization | Cycles to synchronization | <= 10 cycles |
| **P4** | Performance parity | Execution time vs traditional scheduler | <= 100% |
| **P5** | Learned costs | Q-values updated from execution | Persisted |
| **P5** | Plan efficiency improvement | Cost reduction after 100 executions | >= 20% |
| **P6** | Hypothetical scenarios | Scenarios generated per dream cycle | >= 3 |
| **P6** | Quality equilibrium | Convergence to stable quality state | Achieved |

### 7.2 Overall Success Metrics

| Metric | Baseline | Target | Measurement |
|--------|----------|--------|-------------|
| Manual intervention rate | 100% | 20% | Self-healing events / total issues |
| Test suite adaptability | Manual | Organic | Morphogenetic test growth active |
| Root cause discovery time | Manual | < 5s | Automated causal analysis |
| CI/CD scheduling overhead | High | Zero | Time Crystal coordination |
| GOAP plan efficiency | Baseline | +20% | Neural optimizer learning |
| Quality stability | Variable | Equilibrium | Dream x Strange Loop convergence |

---

## 8. MCP Tool Registration

### 8.1 New Tools to Register

```typescript
// Phase P0: MinCut tools
'qe/mincut/health': MincutHealthTool,
'qe/mincut/topology': MincutTopologyTool,

// Phase P1: Self-healing tools
'qe/healing/status': HealingStatusTool,
'qe/healing/trigger': HealingTriggerTool,

// Phase P2: Causal tools
'qe/causal/analyze': CausalAnalyzeTool,
'qe/causal/rootcause': RootCauseTool,

// Phase P3: Morphogenetic tools
'qe/morpho/signals': GrowthSignalsTool,
'qe/morpho/spawn': TestSpawnTool,

// Phase P4: Time Crystal tools
'qe/timecrystal/status': TimeCrystalStatusTool,
'qe/timecrystal/sync': PhaseSyncTool,

// Phase P5: Neural GOAP tools
'qe/neural/qvalues': QValuesTool,
'qe/neural/optimize': NeuralOptimizeTool,

// Phase P6: Dream x Strange Loop tools
'qe/metalearn/dream': MetaDreamTool,
'qe/metalearn/equilibrium': EquilibriumTool,
```

---

## 9. Execution Commands

### 9.1 Claude Flow Swarm Configuration

```bash
# Initialize swarm for ADR-047 implementation
npx @claude-flow/cli@latest swarm init \
  --topology hierarchical \
  --max-agents 12 \
  --strategy specialized \
  --config '{
    "project": "ADR-047-MinCut",
    "phases": ["P0", "P1", "P2", "P3", "P4", "P5", "P6"],
    "consensusAlgorithm": "raft"
  }'

# Spawn phase-specific agents
npx @claude-flow/cli@latest agent spawn -t architect --name adr047-architect
npx @claude-flow/cli@latest agent spawn -t coder --name adr047-coder-1
npx @claude-flow/cli@latest agent spawn -t coder --name adr047-coder-2
npx @claude-flow/cli@latest agent spawn -t tester --name adr047-tester
npx @claude-flow/cli@latest agent spawn -t ml-developer --name adr047-ml-dev
npx @claude-flow/cli@latest agent spawn -t researcher --name adr047-researcher

# Store implementation plan in memory
npx @claude-flow/cli@latest memory store \
  --key "adr047-goap-plan" \
  --namespace "implementation-plans" \
  --value "$(cat /workspaces/agentic-qe/v3/docs/plans/ADR-047-mincut-goap-plan.md)"
```

### 9.2 Phase Execution Commands

```bash
# Execute P0: Foundation
npx @claude-flow/cli@latest task create \
  --type feature \
  --description "ADR-047 P0: MinCut Foundation" \
  --priority critical \
  --assign architect,coder,tester

# Execute P1: Self-Healing
npx @claude-flow/cli@latest task create \
  --type feature \
  --description "ADR-047 P1: Strange Loop Self-Healing" \
  --priority critical \
  --assign architect,coder,tester,ml-developer

# Continue for P2-P6...
```

---

## 10. Appendix: Algorithm Pseudocode

### 10.1 MinCut Calculation

```typescript
/**
 * Approximate MinCut using minimum weighted degree
 * Time: O(V + E)
 * Space: O(1) additional
 */
function approxMincut(graph: SwarmGraph): number {
  let minDegree = Infinity;

  for (const vertex of graph.vertices) {
    const degree = graph.weightedDegree(vertex);
    if (degree < minDegree) {
      minDegree = degree;
    }
  }

  return minDegree;
}

function findWeakVertices(graph: SwarmGraph, threshold: number): Vertex[] {
  const weak: Vertex[] = [];

  for (const vertex of graph.vertices) {
    if (graph.weightedDegree(vertex) < threshold) {
      weak.push(vertex);
    }
  }

  return weak.sort((a, b) =>
    graph.weightedDegree(a) - graph.weightedDegree(b)
  );
}
```

### 10.2 Strange Loop Think Cycle

```typescript
/**
 * Complete Strange Loop cycle
 * Observe -> Model -> Decide -> Act
 */
async function think(swarm: MetaSwarm): Promise<boolean> {
  // Step 1: Observe self
  const mincut = approxMincut(swarm.graph);
  const weakVertices = findWeakVertices(swarm.graph, 2.0);

  const observation: Observation = {
    mincut,
    weakVertices,
    timestamp: Date.now(),
    agentCount: swarm.graph.vertices.length,
    edgeCount: swarm.graph.edges.length,
  };

  // Step 2: Update self-model
  swarm.selfModel.update(observation);

  // Step 3: Decide reorganization
  const action = swarm.selfModel.decide();

  // Step 4: Apply action
  await swarm.applyAction(action);

  // Check convergence
  return swarm.checkConvergence();
}
```

### 10.3 Morphogenetic Growth

```typescript
/**
 * Bio-inspired growth decision
 */
function grow(node: TestNode, signal: number): GrowthAction {
  const degree = node.connections.length;

  // Low connectivity -> spawn new test
  if (signal > 0.5 && degree < 3) {
    return {
      type: 'spawn',
      reason: 'Low connectivity area needs more tests',
      targetCoverage: node.uncoveredPaths,
    };
  }

  // High degree -> branch/specialize
  if (signal > 0.6 && degree > 5) {
    return {
      type: 'branch',
      reason: 'High traffic area needs specialized tests',
      specializationType: determineSpecialization(node),
    };
  }

  // Weak cut -> reinforce
  if (signal > 0.4 && node.localMincut < 2.0) {
    return {
      type: 'reinforce',
      reason: 'Weak cut needs redundant test coverage',
      reinforcementLevel: 2.0 - node.localMincut,
    };
  }

  return { type: 'stable' };
}
```

---

## 11. Changelog

| Date | Change | Author |
|------|--------|--------|
| 2026-01-16 | Initial GOAP plan generated | Goal Planner Agent |
| 2026-01-16 | Added detailed action specifications | Goal Planner Agent |
| 2026-01-16 | Added file structure and agent assignments | Goal Planner Agent |
| 2026-01-16 | Added risk mitigations and success criteria | Goal Planner Agent |

---

**Plan Status:** Ready for Execution
**Estimated Start:** Upon approval
**Estimated Completion:** 10 weeks from start

# Flaky Test Remediation Plan

**Generated by**: qe-flaky-test-hunter
**Date**: 2025-11-11
**Total Flaky Tests Detected**: 13
**Current Reliability**: 98.62%
**Target Reliability**: 95%+ (EXCEEDING TARGET)

## Executive Summary

The test suite has 13 flaky tests across 4 categories. Despite this, overall reliability is **98.62%**, which **exceeds the 95% target**. However, there is **1 CRITICAL issue** (open handle) that blocks test suite completion and must be fixed immediately.

### Key Metrics
- **Total Tests**: 941
- **Flaky Tests**: 13 (1.38%)
- **Critical Issues**: 1 (open handle)
- **High Severity**: 11 tests
- **Medium Severity**: 1 test

### Impact Assessment
- **Immediate Impact**: Test suite hangs due to open handle in MemoryManager
- **Secondary Impact**: 5 database tests fail inconsistently due to cleanup issues
- **Minor Impact**: 6 performance tests have timing dependencies
- **Long-term Risk**: 200+ tests use non-deterministic functions (Date.now, Math.random)

---

## CRITICAL - Fix Immediately (30 minutes)

### 1. MemoryManager Open Handle ⚠️ BLOCKING

**Severity**: CRITICAL
**Flakiness Score**: 0.95
**Impact**: Prevents test suite from completing

**Problem**:
```typescript
// src/core/MemoryManager.ts:51
this.cleanupInterval = setInterval(() => {
  this.cleanupExpired();
}, 5 * 60 * 1000);
```

Jest detects an open handle (setInterval) that prevents the process from exiting.

**Root Cause**:
- `setInterval` is created in constructor but never cleared
- Tests that instantiate MemoryManager leave timers running
- Jest waits indefinitely for process to exit

**Fix** (30 minutes):
```typescript
// 1. Add cleanup method to MemoryManager
public async cleanup(): Promise<void> {
  if (this.cleanupInterval) {
    clearInterval(this.cleanupInterval);
    this.cleanupInterval = null;
  }
  // Clear any other resources
  this.cache.clear();
}

// 2. Update tests
afterEach(async () => {
  if (memoryManager) {
    await memoryManager.cleanup();
  }
});
```

**Verification**:
```bash
npm run test:unit -- tests/unit/fleet-manager.test.ts
# Should complete without "open handle" warning
```

---

## HIGH Priority - Fix This Week (4-5 hours)

### 2. Database Cleanup Issues (5 tests)

**Severity**: HIGH
**Affected Files**:
- `tests/unit/learning/LearningEngine.database.test.ts` (Score: 0.82)
- `tests/unit/core/memory/AgentDBManager.test.ts` (Score: 0.78)
- `tests/unit/core/memory/AgentDBService.test.ts` (Score: 0.76)

**Problem**: Database state leaks between tests causing cascading failures

**Root Causes**:
1. Mock database not fully reset between tests
2. Async cleanup operations not properly awaited
3. Shared database instances across test cases

**Fix Strategy**:

#### LearningEngine.database.test.ts (2 hours)
```typescript
beforeEach(async () => {
  // Create FRESH database instance per test
  database = new Database();
  Database._resetAllMocks();

  // Clear test data store
  testDataStore.clear();

  // Configure mocks with clean state
  setupMockImplementations(database);
});

afterEach(async () => {
  // Explicitly await cleanup
  if (database) {
    await database.close?.();
  }

  // Clear all intervals/timeouts
  jest.clearAllTimers();

  // Force garbage collection in test
  if (global.gc) {
    global.gc();
  }
});
```

#### AgentDBManager.test.ts (1 hour)
```typescript
afterEach(async () => {
  // Ensure AgentDB connection is closed
  if (agentDBManager) {
    await agentDBManager.disconnect();
  }

  // Clean up database files if in-memory
  if (testDbPath && fs.existsSync(testDbPath)) {
    fs.unlinkSync(testDbPath);
  }
});
```

#### AgentDBService.test.ts (1 hour)
```typescript
afterEach(async () => {
  // Wait for all pending operations
  await new Promise(resolve => setImmediate(resolve));

  // Close database connection
  if (agentDBService) {
    await agentDBService.close();
  }

  // Clear mock state
  jest.clearAllMocks();
});
```

**Verification**:
```bash
# Run each test 10 times to ensure consistency
for i in {1..10}; do
  npm run test:unit -- tests/unit/learning/LearningEngine.database.test.ts
done
```

---

## MEDIUM Priority - Fix This Sprint (3 hours)

### 3. Timing-Related Flakiness (6 tests)

**Severity**: HIGH
**Primary File**: `tests/performance/load-testing.test.ts` (Score: 0.75)

**Problem**: 47 hardcoded `setTimeout` calls with variable delays

**Examples of Problematic Code**:
```typescript
// Random delays (non-deterministic)
await new Promise(resolve => setTimeout(resolve, Math.random() * 2)); // 0-2ms
await new Promise(resolve => setTimeout(resolve, Math.random() * 5)); // 0-5ms

// Fixed delays (timing-dependent)
await new Promise(resolve => setTimeout(resolve, 100)); // Assumes 100ms is enough
```

**Fix Strategy** (3 hours):

#### Option 1: Use Fake Timers (Recommended)
```typescript
describe('Load Testing Suite', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.runOnlyPendingTimers();
    jest.useRealTimers();
  });

  it('should handle load', async () => {
    const promise = agent.executeTask(task);

    // Advance time deterministically
    jest.advanceTimersByTime(100);

    const result = await promise;
    expect(result).toBeDefined();
  });
});
```

#### Option 2: State-Based Waits
```typescript
// Replace timing-based waits with state checks
async function waitForCondition(
  condition: () => boolean | Promise<boolean>,
  options = { timeout: 5000, interval: 100 }
): Promise<void> {
  const startTime = Date.now();

  while (Date.now() - startTime < options.timeout) {
    if (await condition()) {
      return;
    }
    await new Promise(resolve => setTimeout(resolve, options.interval));
  }

  throw new Error(`Timeout waiting for condition after ${options.timeout}ms`);
}

// Usage
await waitForCondition(() => agent.status === 'completed');
```

**Files to Update**:
1. `tests/performance/load-testing.test.ts` (47 setTimeout calls)
2. `tests/performance/quic-benchmarks.test.ts` (5 setTimeout calls)
3. `tests/mcp/services/AgentRegistry.test.ts` (mixing fake/real timers)

---

## LOW Priority - Technical Debt (Ongoing)

### 4. Non-Deterministic Functions (200+ test files)

**Severity**: MEDIUM
**Flakiness Score**: 0.45

**Problem**: 200+ test files use `Date.now()` or `Math.random()` without mocking

**Long-Term Strategy**:

#### Global Setup (tests/setup.ts)
```typescript
// Mock Date.now() globally
const FIXED_TIMESTAMP = 1699632000000; // 2023-11-10T12:00:00Z
jest.spyOn(Date, 'now').mockReturnValue(FIXED_TIMESTAMP);

// Mock Math.random() for deterministic tests
let randomIndex = 0;
const randomSequence = [0.1, 0.5, 0.9, 0.3, 0.7]; // Predictable sequence
jest.spyOn(Math, 'random').mockImplementation(() => {
  const value = randomSequence[randomIndex % randomSequence.length];
  randomIndex++;
  return value;
});
```

#### Per-Test Override
```typescript
it('should handle specific timestamp', () => {
  jest.spyOn(Date, 'now').mockReturnValueOnce(1234567890000);
  // Test code that depends on Date.now()
});
```

---

## Verification Plan

### Phase 1: Critical Fix (Day 1)
```bash
# 1. Fix MemoryManager open handle
git checkout -b fix/memory-manager-open-handle

# 2. Verify fix
npm run test:unit -- tests/unit/fleet-manager.test.ts
# Should see: ✓ Tests complete with no open handles

# 3. Run full unit test suite
npm run test:unit
# Should see: Tests complete without hanging
```

### Phase 2: Database Cleanup (Day 2-3)
```bash
# Fix database cleanup issues
git checkout -b fix/database-cleanup-flakiness

# Run each fixed test 20 times
for i in {1..20}; do
  npm run test:unit -- tests/unit/learning/LearningEngine.database.test.ts
done
# Should see: 20/20 passes

# Verify no state leaks
npm run test:unit -- tests/unit/core/memory/
# Should see: All tests pass consistently
```

### Phase 3: Timing Fixes (Day 4-5)
```bash
# Fix timing-related flakiness
git checkout -b fix/timing-flakiness

# Run performance tests 10 times
for i in {1..10}; do
  npm run test:unit -- tests/performance/load-testing.test.ts
done
# Should see: 10/10 passes with consistent duration
```

---

## Success Metrics

### Current State
- ✅ Overall Reliability: 98.62% (exceeds 95% target)
- ⚠️ Test Suite Completion: Blocked by open handle
- ⚠️ Database Tests: 5 tests fail inconsistently
- ⚠️ Performance Tests: 6 tests have timing dependencies

### Target State (After Fixes)
- ✅ Test Suite Completion: 100% (no blocking issues)
- ✅ Database Tests: 100% pass rate over 20 runs
- ✅ Performance Tests: 100% pass rate over 10 runs
- ✅ Overall Reliability: 99%+ (maintain high reliability)

### Metrics to Track
1. **Pass Rate**: Tests passing on first run (target: >98%)
2. **Consistency**: Same result over 10 runs (target: 100%)
3. **Duration Variance**: Test duration variance (target: <10%)
4. **Open Handles**: Number of open handles (target: 0)

---

## Timeline & Effort Estimate

| Phase | Priority | Effort | Timeline |
|-------|----------|--------|----------|
| Fix MemoryManager open handle | CRITICAL | 30 min | Day 1 AM |
| Fix database cleanup (5 tests) | HIGH | 4-5 hours | Day 1 PM - Day 2 |
| Fix timing issues (6 tests) | MEDIUM | 3 hours | Day 3 |
| Global mock setup | LOW | 1 hour | Day 4 |
| **Total** | | **8-10 hours** | **4-5 days** |

---

## Appendix: Flaky Test Patterns Detected

### Pattern 1: Open Handles (1 occurrence)
```typescript
// FLAKY: Timer not cleaned up
this.interval = setInterval(() => { /* ... */ }, 1000);

// FIX: Add cleanup
public cleanup(): void {
  if (this.interval) {
    clearInterval(this.interval);
  }
}
```

### Pattern 2: Database State Leaks (5 occurrences)
```typescript
// FLAKY: Shared database state
beforeEach(() => {
  database = new Database(); // Reuses connection
});

// FIX: Isolate per test
beforeEach(async () => {
  database = new Database({ filename: ':memory:' });
  await database.initialize();
});

afterEach(async () => {
  await database.close();
});
```

### Pattern 3: Timing Dependencies (6 occurrences)
```typescript
// FLAKY: Hardcoded sleep
await new Promise(resolve => setTimeout(resolve, 100));
expect(result).toBeDefined();

// FIX: State-based wait
await waitForCondition(() => result !== undefined);
expect(result).toBeDefined();
```

### Pattern 4: Non-Deterministic Functions (200+ occurrences)
```typescript
// FLAKY: Random values
const id = Date.now() + '-' + Math.random();

// FIX: Mock globally
jest.spyOn(Date, 'now').mockReturnValue(FIXED_TIME);
jest.spyOn(Math, 'random').mockReturnValue(0.5);
```

---

## Conclusion

The test suite is in **good health overall** with 98.62% reliability, exceeding the 95% target. However, the **critical open handle issue must be fixed immediately** to unblock test completion. The remaining flaky tests are well-understood and have clear remediation paths.

**Recommended Next Steps**:
1. ✅ Fix MemoryManager open handle (30 min) - **DO THIS NOW**
2. ✅ Fix database cleanup issues (4-5 hours) - **This week**
3. ⚠️ Fix timing issues (3 hours) - **This sprint**
4. ℹ️ Add global mocks for Date/Math (1 hour) - **Technical debt**

**Total Estimated Effort**: 8-10 hours over 4-5 days
**Expected Outcome**: 99%+ test reliability with zero blocking issues

---

**Report Generated by**: qe-flaky-test-hunter (Agentic QE Fleet)
**Learning System**: Enabled (patterns will be persisted to AgentDB)
**Coordination**: Findings stored at `aqe/flaky-tests/findings`

/**
 * GOAP Plan Executor
 *
 * Executes remediation plans generated by GOAPQualityGateIntegration:
 * - Spawns agents for each action
 * - Executes actions in sequence with dependency ordering
 * - Records outcomes for learning via PlanLearning integration
 * - Handles failures with automatic replanning
 * - Phase 6: Live agent execution with real world state updates
 *
 * @module planning/execution/PlanExecutor
 * @version 1.2.0 - Phase 6: Live Agent Execution
 */

import Database from 'better-sqlite3';
import {
  GOAPQualityGateIntegration,
  RemediationPlan,
  RemediationAction,
  QualityGateContext,
  QualityGateMetrics,
  QUALITY_GATE_GOALS
} from '../integration/GOAPQualityGateIntegration';
import { Logger } from '../../utils/Logger';
import { PlanLearning } from '../PlanLearning';
import { WorldState, GOAPAction, GOAPPlan, ExecutedAction, DEFAULT_WORLD_STATE } from '../types';

// Lazy import to avoid circular dependencies and reduce memory in tests
let AgentRegistryModule: typeof import('../../mcp/services/AgentRegistry') | null = null;
async function getAgentRegistryModule() {
  if (!AgentRegistryModule) {
    AgentRegistryModule = await import('../../mcp/services/AgentRegistry');
  }
  return AgentRegistryModule;
}

/**
 * Result of executing a single action
 */
export interface ActionExecutionResult {
  actionId: string;
  actionName: string;
  success: boolean;
  durationMs: number;
  error?: string;
  agentId?: string;
  output?: any;
}

/**
 * Result of executing a full plan
 */
export interface PlanExecutionResult {
  planId: string;
  success: boolean;
  totalDurationMs: number;
  actionsExecuted: number;
  actionsSucceeded: number;
  actionsFailed: number;
  actionResults: ActionExecutionResult[];
  replanned: boolean;
  alternativePlanUsed?: string;
  error?: string;
}

/**
 * Configuration for plan execution
 */
export interface PlanExecutionConfig {
  /** Maximum retries per action (default: 1) */
  maxRetries?: number;
  /** Timeout per action in ms (default: 300000 = 5 min) */
  actionTimeoutMs?: number;
  /** Whether to continue on action failure (default: false - triggers replanning) */
  continueOnFailure?: boolean;
  /** Maximum replan attempts (default: 2) */
  maxReplanAttempts?: number;
  /** Dry run - don't actually execute, just validate (default: false) */
  dryRun?: boolean;
}

const DEFAULT_CONFIG: Required<PlanExecutionConfig> = {
  maxRetries: 1,
  actionTimeoutMs: 300000,
  continueOnFailure: false,
  maxReplanAttempts: 2,
  dryRun: false
};

/**
 * GOAP Plan Executor
 *
 * Bridges plan generation with actual agent execution.
 * Implements the OODA (Observe-Orient-Decide-Act) loop for plan execution.
 * Integrates with PlanLearning for continuous improvement.
 */
export class PlanExecutor {
  private registry: any | null = null; // AgentRegistry - lazily initialized
  private integration: GOAPQualityGateIntegration;
  private planLearning: PlanLearning;
  private db: Database.Database;
  private logger: Logger;
  private config: Required<PlanExecutionConfig>;
  private ownsRegistry = false; // Track if we created the registry
  private currentWorldState: WorldState; // Track current world state for learning

  constructor(
    db: Database.Database,
    integration: GOAPQualityGateIntegration,
    config: PlanExecutionConfig = {}
  ) {
    this.db = db;
    this.integration = integration;
    this.planLearning = new PlanLearning(db);
    this.logger = Logger.getInstance();
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.currentWorldState = { ...DEFAULT_WORLD_STATE };
    // Registry is lazily initialized only when needed (not in dry-run mode)
  }

  /**
   * Get the PlanLearning instance for external access
   */
  getPlanLearning(): PlanLearning {
    return this.planLearning;
  }

  /**
   * Update current world state (called by integration or externally)
   */
  updateWorldState(state: Partial<WorldState>): void {
    this.currentWorldState = {
      ...this.currentWorldState,
      ...state,
      coverage: { ...this.currentWorldState.coverage, ...state.coverage },
      quality: { ...this.currentWorldState.quality, ...state.quality },
      fleet: { ...this.currentWorldState.fleet, ...state.fleet },
      resources: { ...this.currentWorldState.resources, ...state.resources },
      context: { ...this.currentWorldState.context, ...state.context }
    };
  }

  /**
   * Get current world state
   */
  getWorldState(): WorldState {
    return { ...this.currentWorldState };
  }

  /**
   * Initialize registry only when needed for actual execution
   */
  private async ensureRegistry(): Promise<any> {
    if (!this.registry) {
      const { getAgentRegistry } = await getAgentRegistryModule();
      this.registry = getAgentRegistry();
      this.ownsRegistry = true;
    }
    return this.registry;
  }

  /**
   * Cleanup resources - call this when done with the executor
   */
  async cleanup(): Promise<void> {
    // Don't cleanup singleton registry - it's shared
    this.registry = null;
    this.ownsRegistry = false;
  }

  /**
   * Execute a remediation plan
   *
   * @param plan - The remediation plan to execute
   * @param context - Quality gate context for replanning
   * @param metrics - Current metrics for replanning
   */
  async executePlan(
    plan: RemediationPlan,
    context: QualityGateContext,
    metrics: QualityGateMetrics
  ): Promise<PlanExecutionResult> {
    const startTime = Date.now();
    const result: PlanExecutionResult = {
      planId: plan.planId,
      success: false,
      totalDurationMs: 0,
      actionsExecuted: 0,
      actionsSucceeded: 0,
      actionsFailed: 0,
      actionResults: [],
      replanned: false
    };

    // Track executed actions for learning (Phase 5 integration)
    const executedActions: ExecutedAction[] = [];

    // Initialize world state from metrics
    this.initializeWorldStateFromMetrics(metrics, context);
    const initialWorldState = this.getWorldState();

    this.logger.info('[PlanExecutor] Starting plan execution', {
      planId: plan.planId,
      actionCount: plan.actions.length,
      dryRun: this.config.dryRun
    });

    // Update plan status to 'executing'
    await this.updatePlanStatus(plan.planId, 'executing');

    let replanAttempts = 0;
    let currentPlan = plan;

    while (replanAttempts <= this.config.maxReplanAttempts) {
      try {
        // Execute each action in sequence
        for (const action of currentPlan.actions) {
          // Capture state before action
          const stateBefore = this.getWorldState();

          const actionResult = await this.executeAction(action, context);
          result.actionResults.push(actionResult);
          result.actionsExecuted++;

          // Phase 6: Capture state after action
          // Use real output parsing in live mode, simulation in dry-run
          let stateAfter: WorldState;
          if (this.config.dryRun) {
            stateAfter = this.simulateActionEffects(stateBefore, action, actionResult.success);
          } else {
            // Live mode: parse actual agent output for real measurements
            stateAfter = this.updateWorldStateFromAgentOutput(action, actionResult.output, stateBefore);
            // Fallback to simulation if no output parsed
            if (JSON.stringify(stateAfter) === JSON.stringify(stateBefore)) {
              stateAfter = this.simulateActionEffects(stateBefore, action, actionResult.success);
            }
          }
          this.currentWorldState = stateAfter;

          // Build ExecutedAction for learning
          const executedAction: ExecutedAction = {
            action: this.remediationActionToGOAPAction(action),
            success: actionResult.success,
            result: actionResult.output,
            error: actionResult.error,
            stateBefore,
            stateAfter,
            executionTimeMs: actionResult.durationMs,
            agentId: actionResult.agentId
          };
          executedActions.push(executedAction);

          if (actionResult.success) {
            result.actionsSucceeded++;
            // Record success for learning (legacy + new)
            await this.integration.recordActionOutcome(action.id, true);
          } else {
            result.actionsFailed++;
            // Record failure for learning (legacy + new)
            await this.integration.recordActionOutcome(action.id, false);

            if (!this.config.continueOnFailure) {
              this.logger.warn('[PlanExecutor] Action failed, attempting replan', {
                actionId: action.id,
                actionName: action.name,
                error: actionResult.error
              });

              // Try to replan
              replanAttempts++;
              if (replanAttempts > this.config.maxReplanAttempts) {
                result.error = `Max replan attempts (${this.config.maxReplanAttempts}) exceeded. Last error: ${actionResult.error}`;
                break;
              }

              // Try alternative path first
              if (currentPlan.alternativePaths.length > 0) {
                const altPath = currentPlan.alternativePaths[0];
                this.logger.info('[PlanExecutor] Using alternative path', {
                  alternativePlanId: altPath.planId,
                  difference: altPath.differenceFromPrimary
                });

                // Generate new plan from alternative
                const newPlan = await this.integration.generateRemediationPlan(
                  metrics,
                  context
                );

                if (newPlan) {
                  currentPlan = newPlan;
                  result.replanned = true;
                  result.alternativePlanUsed = altPath.planId;
                  continue; // Restart with new plan
                }
              }

              // Full replan if no alternatives
              const newPlan = await this.integration.generateRemediationPlan(
                metrics,
                context
              );

              if (newPlan) {
                currentPlan = newPlan;
                result.replanned = true;
                this.logger.info('[PlanExecutor] Replanned with new strategy', {
                  newPlanId: newPlan.planId
                });
                continue;
              }

              result.error = `Replanning failed after action ${action.id}`;
              break;
            }
          }
        }

        // If we get here without breaking, we succeeded
        if (!result.error) {
          result.success = result.actionsFailed === 0;
        }
        break;

      } catch (error) {
        result.error = error instanceof Error ? error.message : String(error);
        this.logger.error('[PlanExecutor] Plan execution failed', { error: result.error });
        break;
      }
    }

    result.totalDurationMs = Date.now() - startTime;

    // Update plan status
    await this.updatePlanStatus(
      plan.planId,
      result.success ? 'completed' : 'failed',
      result.success,
      result.error
    );

    // Mark plan as completed via integration
    await this.integration.completePlan(plan.planId, result.success, result.error);

    // Phase 5 & 6: Learn from execution and store signatures
    if (executedActions.length > 0) {
      try {
        const goapPlan = this.remediationPlanToGOAPPlan(plan, initialWorldState);

        // Learn from execution (Phase 5)
        const learningOutcome = await this.planLearning.learnFromExecution(
          goapPlan,
          executedActions,
          result.success
        );
        this.logger.info('[PlanExecutor] Learning from execution completed', {
          planId: plan.planId,
          actionsUpdated: learningOutcome.actionsUpdated,
          qValueUpdates: learningOutcome.qValueUpdates
        });

        // Phase 6: Store plan signature for future reuse (only for successful executions)
        if (result.success && !this.config.dryRun) {
          try {
            // Get PlanSimilarity from integration's planner
            const planner = this.integration.getPlanner();
            if (planner) {
              planner.storePlanSignature(goapPlan, initialWorldState);
              this.logger.info('[PlanExecutor] Plan signature stored for future reuse', {
                planId: plan.planId,
                actionCount: goapPlan.actions.length
              });
            }
          } catch (sigError) {
            this.logger.warn('[PlanExecutor] Failed to store plan signature', {
              error: sigError instanceof Error ? sigError.message : String(sigError)
            });
          }
        }
      } catch (error) {
        // Learning failure should not fail the execution
        this.logger.warn('[PlanExecutor] Learning from execution failed', {
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }

    this.logger.info('[PlanExecutor] Plan execution completed', {
      planId: plan.planId,
      success: result.success,
      duration: `${result.totalDurationMs}ms`,
      actionsExecuted: result.actionsExecuted,
      actionsSucceeded: result.actionsSucceeded,
      actionsFailed: result.actionsFailed,
      replanned: result.replanned
    });

    return result;
  }

  /**
   * Execute a single remediation action
   */
  private async executeAction(
    action: RemediationAction,
    context: QualityGateContext
  ): Promise<ActionExecutionResult> {
    const startTime = Date.now();
    const result: ActionExecutionResult = {
      actionId: action.id,
      actionName: action.name,
      success: false,
      durationMs: 0
    };

    if (this.config.dryRun) {
      this.logger.info('[PlanExecutor] DRY RUN - Would execute action', {
        actionId: action.id,
        actionName: action.name,
        agentType: action.agentType
      });
      result.success = true;
      result.durationMs = Date.now() - startTime;
      return result;
    }

    this.logger.info('[PlanExecutor] Executing action', {
      actionId: action.id,
      actionName: action.name,
      agentType: action.agentType
    });

    try {
      // Get registry only when actually executing (not in dry-run)
      const registry = await this.ensureRegistry();

      // Map GOAP agent type to MCP agent type
      const mcpAgentType = this.mapAgentType(action.agentType);

      // Spawn or get an agent of the required type
      const { id: agentId } = await registry.spawnAgent(mcpAgentType, {
        name: `${mcpAgentType}-${action.id}`,
        description: `Spawned for action: ${action.name}`,
        capabilities: this.getCapabilitiesForAction(action)
      });

      result.agentId = agentId;

      // Create task from action
      const task = this.createTaskFromAction(action, context);

      // Execute with timeout
      const executePromise = registry.executeTask(agentId, task);
      const timeoutPromise = new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Action timeout')), this.config.actionTimeoutMs)
      );

      const output = await Promise.race([executePromise, timeoutPromise]);

      result.success = true;
      result.output = output;

      // Terminate the agent after use (cleanup)
      await registry.terminateAgent(agentId).catch((err: unknown) =>
        this.logger.warn('[PlanExecutor] Failed to terminate agent', { agentId, error: err })
      );

    } catch (error) {
      result.success = false;
      result.error = error instanceof Error ? error.message : String(error);
      this.logger.error('[PlanExecutor] Action execution failed', {
        actionId: action.id,
        error: result.error
      });
    }

    result.durationMs = Date.now() - startTime;
    return result;
  }

  /**
   * Map GOAP agent type to MCP agent type
   *
   * GOAP actions use 'qe-*' prefixed agent types which need to be
   * mapped to MCP types that AgentRegistry understands.
   */
  private mapAgentType(goapAgentType: string): string {
    const mapping: Record<string, string> = {
      // Core Testing Agents
      'qe-test-generator': 'test-generator',
      'qe-test-executor': 'test-executor',
      'qe-test-writer': 'test-generator',  // Test writers use test-generator agent
      'qe-integration-tester': 'test-executor',  // Integration tests use test-executor

      // Coverage & Analysis Agents
      'qe-coverage-analyzer': 'coverage-analyzer',
      'qe-code-complexity': 'code-analyzer',  // Maps to quality-analyzer
      'qe-code-intelligence': 'code-analyzer',  // Maps to quality-analyzer

      // Quality & Gate Agents
      'qe-quality-gate': 'quality-gate',
      'qe-quality-analyzer': 'code-analyzer',

      // Security Agents
      'qe-security-scanner': 'security-scanner',

      // Performance Agents
      'qe-performance-tester': 'performance-tester',

      // Specialized Testing Agents
      'qe-flaky-test-hunter': 'flaky-test-detector',
      'qe-regression-risk-analyzer': 'regression-analyzer',
      'qe-chaos-engineer': 'chaos-engineer',
      'qe-visual-tester': 'visual-tester',

      // Strategic Planning Agents
      'qe-requirements-validator': 'requirements-validator',
      'qe-deployment-readiness': 'deployment-validator',
      'qe-production-intelligence': 'production-analyzer',

      // Fleet & Orchestration Agents
      'qe-fleet-commander': 'fleet-commander',

      // Data & Contract Agents
      'qe-test-data-architect': 'data-generator',
      'qe-api-contract-validator': 'contract-validator',

      // Quality Experience (QX) Agent
      'qe-qx-partner': 'qx-partner',

      // Accessibility Agent
      'qe-accessibility-ally': 'accessibility-ally',

      // Legacy/simple mappings (for backward compatibility)
      'test-generator': 'test-generator',
      'test-executor': 'test-executor',
      'coverage-analyzer': 'coverage-analyzer',
      'quality-gate': 'quality-gate',
      'performance-tester': 'performance-tester',
      'security-scanner': 'security-scanner',
      'fleet-commander': 'fleet-commander',
      'chaos-engineer': 'chaos-engineer'
    };

    const mcpType = mapping[goapAgentType];
    if (!mcpType) {
      this.logger.warn(`[PlanExecutor] Unknown GOAP agent type: ${goapAgentType}, defaulting to quality-gate`);
    }
    return mcpType || 'quality-gate';
  }

  /**
   * Get capabilities for an action
   */
  private getCapabilitiesForAction(action: RemediationAction): string[] {
    const categoryCapabilities: Record<string, string[]> = {
      test: ['test-execution', 'test-validation'],
      coverage: ['coverage-analysis', 'gap-detection'],
      security: ['vulnerability-scanning', 'security-testing'],
      performance: ['load-testing', 'performance-analysis'],
      analysis: ['code-analysis', 'impact-analysis'],
      process: ['decision-making', 'workflow-management'],
      fleet: ['agent-coordination', 'resource-management']
    };

    return categoryCapabilities[action.category] || ['generic-execution'];
  }

  /**
   * Create a task from a remediation action
   *
   * Maps GOAP action categories to structured task payloads that
   * QE agents can understand and execute properly.
   */
  private createTaskFromAction(action: RemediationAction, context: QualityGateContext): any {
    const taskId = `task-${action.id}-${Date.now()}`;
    const priority = context.criticality === 'critical' ? 1 : context.criticality === 'high' ? 3 : 5;

    // Build category-specific payload
    const categoryPayload = this.buildCategoryPayload(action, context);

    return {
      id: taskId,
      type: this.mapCategoryToTaskType(action.category),
      taskType: this.mapCategoryToTaskType(action.category),
      payload: {
        ...categoryPayload,
        actionId: action.id,
        actionName: action.name,
        description: action.description,
        effects: action.effects,
        projectId: context.projectId,
        buildId: context.buildId,
        environment: context.environment
      },
      priority,
      description: action.description || action.name,
      context: {
        source: 'goap-remediation',
        planAction: action.id,
        goapCategory: action.category
      },
      requirements: this.buildRequirements(action)
    };
  }

  /**
   * Build category-specific payload for task execution
   *
   * Note: action.effects is string[] describing the state changes
   */
  private buildCategoryPayload(action: RemediationAction, context: QualityGateContext): Record<string, any> {
    const basePayload = {
      actionId: action.id,
      actionName: action.name
    };

    // Parse coverage target from effects if present
    const coverageTarget = this.extractCoverageTarget(action.effects);

    switch (action.category) {
      case 'test':
        return {
          ...basePayload,
          testType: this.inferTestType(action.id),
          targetCoverage: coverageTarget,
          runIntegration: action.id.includes('integration'),
          runUnit: action.id.includes('unit') || !action.id.includes('integration')
        };

      case 'coverage':
        return {
          ...basePayload,
          analysisType: 'gap-detection',
          targetCoverage: coverageTarget,
          includeUncovered: true
        };

      case 'security':
        return {
          ...basePayload,
          scanType: this.inferSecurityScanType(action.id),
          severityThreshold: action.id.includes('critical') ? 'critical' : 'high',
          autoFix: action.id.includes('fix') || action.id.includes('remediate')
        };

      case 'performance':
        return {
          ...basePayload,
          testType: this.inferPerformanceTestType(action.id),
          durationSeconds: 60,
          targetP95Ms: 200,
          targetErrorRate: 0.01
        };

      case 'analysis':
        return {
          ...basePayload,
          analysisDepth: 'full',
          includeMetrics: true
        };

      case 'process':
        return {
          ...basePayload,
          processType: 'quality-gate-evaluation',
          environment: context.environment,
          criticality: context.criticality
        };

      case 'fleet':
        return {
          ...basePayload,
          fleetOperation: this.inferFleetOperation(action.id),
          maxAgents: 10
        };

      default:
        return basePayload;
    }
  }

  /**
   * Extract coverage target from effects array
   */
  private extractCoverageTarget(effects: string[]): number {
    // Effects are strings like "coverage.line >= 80" or "Increase line coverage by 10%"
    for (const effect of effects) {
      const match = effect.match(/coverage.*?(\d+)/i);
      if (match) {
        return parseInt(match[1], 10);
      }
    }
    return 80; // Default target
  }

  /**
   * Map action category to task type
   */
  private mapCategoryToTaskType(category: string): string {
    const mapping: Record<string, string> = {
      test: 'test-execution',
      coverage: 'coverage-analysis',
      security: 'security-scan',
      performance: 'performance-test',
      analysis: 'code-analysis',
      process: 'process-evaluation',
      fleet: 'fleet-management'
    };
    return mapping[category] || 'generic';
  }

  /**
   * Infer test type from action ID
   */
  private inferTestType(actionId: string): string {
    if (actionId.includes('unit')) return 'unit';
    if (actionId.includes('integration')) return 'integration';
    if (actionId.includes('e2e')) return 'e2e';
    if (actionId.includes('smoke')) return 'smoke';
    if (actionId.includes('regression')) return 'regression';
    return 'unit';
  }

  /**
   * Infer security scan type from action ID
   */
  private inferSecurityScanType(actionId: string): string {
    if (actionId.includes('sast')) return 'sast';
    if (actionId.includes('dast')) return 'dast';
    if (actionId.includes('dependency')) return 'dependency';
    if (actionId.includes('vulnerability')) return 'vulnerability';
    return 'comprehensive';
  }

  /**
   * Infer performance test type from action ID
   */
  private inferPerformanceTestType(actionId: string): string {
    if (actionId.includes('load')) return 'load';
    if (actionId.includes('stress')) return 'stress';
    if (actionId.includes('spike')) return 'spike';
    if (actionId.includes('soak')) return 'soak';
    if (actionId.includes('baseline')) return 'baseline';
    return 'load';
  }

  /**
   * Infer fleet operation from action ID
   */
  private inferFleetOperation(actionId: string): string {
    if (actionId.includes('spawn')) return 'spawn';
    if (actionId.includes('terminate')) return 'terminate';
    if (actionId.includes('scale')) return 'scale';
    if (actionId.includes('optimize')) return 'optimize';
    return 'manage';
  }

  /**
   * Build requirements for task execution
   */
  private buildRequirements(action: RemediationAction): Record<string, any> {
    return {
      timeout: action.estimatedDuration || 300000,
      retries: 1,
      expectedEffects: action.effects
    };
  }

  // ============================================================================
  // Phase 6: Live Execution with Real World State Updates
  // ============================================================================

  /**
   * Parse agent output and update world state with real measurements
   * This is called in live execution mode (not dry-run)
   */
  private updateWorldStateFromAgentOutput(
    action: RemediationAction,
    output: any,
    stateBefore: WorldState
  ): WorldState {
    const stateAfter: WorldState = JSON.parse(JSON.stringify(stateBefore));

    if (!output) return stateAfter;

    // Parse output based on action category
    switch (action.category) {
      case 'test':
        this.parseTestOutput(output, stateAfter);
        break;
      case 'coverage':
        this.parseCoverageOutput(output, stateAfter);
        break;
      case 'security':
        this.parseSecurityOutput(output, stateAfter);
        break;
      case 'performance':
        this.parsePerformanceOutput(output, stateAfter);
        break;
      case 'analysis':
        this.parseAnalysisOutput(output, stateAfter);
        break;
      default:
        // For other categories, use simulation as fallback
        break;
    }

    return stateAfter;
  }

  /**
   * Parse test execution output
   */
  private parseTestOutput(output: any, state: WorldState): void {
    // Look for coverage data in output
    if (output.coverage) {
      state.coverage.line = output.coverage.line ?? output.coverage.linePercentage ?? state.coverage.line;
      state.coverage.branch = output.coverage.branch ?? output.coverage.branchPercentage ?? state.coverage.branch;
      state.coverage.function = output.coverage.function ?? output.coverage.functionPercentage ?? state.coverage.function;
      state.coverage.measured = true;
    }

    // Look for test results
    if (output.testResults || output.tests) {
      const results = output.testResults || output.tests;
      if (results.total && results.passed !== undefined) {
        state.quality.testsPassing = (results.passed / results.total) * 100;
        state.quality.testsMeasured = true;
      }
    }

    // Handle simple pass rate
    if (typeof output.passRate === 'number') {
      state.quality.testsPassing = output.passRate;
      state.quality.testsMeasured = true;
    }
  }

  /**
   * Parse coverage analysis output
   */
  private parseCoverageOutput(output: any, state: WorldState): void {
    if (output.coverage) {
      state.coverage.line = output.coverage.line ?? state.coverage.line;
      state.coverage.branch = output.coverage.branch ?? state.coverage.branch;
      state.coverage.function = output.coverage.function ?? state.coverage.function;
      state.coverage.measured = true;
    }

    // Handle gaps detected
    if (output.gaps && Array.isArray(output.gaps)) {
      // Store gap information for future actions
      this.logger.debug('[PlanExecutor] Coverage gaps detected', { gapCount: output.gaps.length });
    }
  }

  /**
   * Parse security scan output
   */
  private parseSecurityOutput(output: any, state: WorldState): void {
    if (output.securityScore !== undefined) {
      state.quality.securityScore = output.securityScore;
      state.quality.securityMeasured = true;
    }

    // Calculate from vulnerabilities
    if (output.vulnerabilities || output.summary) {
      const summary = output.summary || output.vulnerabilities;
      const critical = summary.critical ?? 0;
      const high = summary.high ?? 0;
      const medium = summary.medium ?? 0;

      // Score: 100 - (critical*25 + high*10 + medium*5), clamped to 0-100
      state.quality.securityScore = Math.max(0, Math.min(100,
        100 - (critical * 25 + high * 10 + medium * 5)
      ));
      state.quality.securityMeasured = true;
    }
  }

  /**
   * Parse performance test output
   */
  private parsePerformanceOutput(output: any, state: WorldState): void {
    if (output.performanceScore !== undefined) {
      state.quality.performanceScore = output.performanceScore;
      state.quality.performanceMeasured = true;
    }

    // Calculate from error rate and latency
    if (output.errorRate !== undefined || output.p95 !== undefined) {
      const errorPenalty = (output.errorRate ?? 0) * 100;
      const latencyPenalty = output.p95 && output.targetP95
        ? Math.max(0, (output.p95 - output.targetP95) / output.targetP95 * 50)
        : 0;

      state.quality.performanceScore = Math.max(0, 100 - errorPenalty - latencyPenalty);
      state.quality.performanceMeasured = true;
    }
  }

  /**
   * Parse code analysis output
   */
  private parseAnalysisOutput(output: any, state: WorldState): void {
    if (output.technicalDebt !== undefined) {
      state.quality.technicalDebt = output.technicalDebt;
    }

    if (output.complexity !== undefined) {
      state.quality.complexityMeasured = true;
    }
  }

  // ============================================================================
  // Phase 5: Learning Integration Helpers
  // ============================================================================

  /**
   * Initialize world state from quality gate metrics
   */
  private initializeWorldStateFromMetrics(
    metrics: QualityGateMetrics,
    context: QualityGateContext
  ): void {
    // Calculate pass rate from test results
    const testResults = metrics.testResults;
    const testPassRate = testResults && testResults.total
      ? ((testResults.passed ?? 0) / testResults.total) * 100
      : 0;

    // Calculate security score (inverse of vulnerability count)
    const securitySummary = metrics.security?.summary;
    const securityScore = securitySummary
      ? Math.max(0, 100 - ((securitySummary.critical ?? 0) * 25 + (securitySummary.high ?? 0) * 10))
      : 100;

    // Calculate performance score from error rate
    const performanceScore = metrics.performance?.errorRate !== undefined
      ? Math.max(0, 100 - metrics.performance.errorRate * 100)
      : 100;

    // Map criticality to risk level
    const riskLevelMap: Record<string, 'low' | 'medium' | 'high' | 'critical'> = {
      low: 'low',
      medium: 'medium',
      high: 'high',
      critical: 'critical'
    };
    const riskLevel = riskLevelMap[context.criticality || 'medium'] || 'medium';

    // Estimate change size from changed files count
    const changeSize: 'small' | 'medium' | 'large' =
      (context.changedFiles?.length ?? 0) <= 5 ? 'small' :
      (context.changedFiles?.length ?? 0) <= 20 ? 'medium' : 'large';

    this.currentWorldState = {
      coverage: {
        line: metrics.coverage?.linePercentage ?? metrics.coverage?.overallPercentage ?? 0,
        branch: metrics.coverage?.branchPercentage ?? 0,
        function: metrics.coverage?.functionPercentage ?? 0,
        target: 80,
        measured: metrics.coverage !== undefined
      },
      quality: {
        testsPassing: testPassRate,
        securityScore,
        performanceScore,
        technicalDebt: metrics.codeQuality?.technicalDebtDays ?? 0,
        gateStatus: 'pending',
        testsMeasured: testResults !== undefined,
        securityMeasured: metrics.security !== undefined,
        performanceMeasured: metrics.performance !== undefined
      },
      fleet: {
        activeAgents: 0,
        availableAgents: context.availableAgents || ['test-generator', 'coverage-analyzer', 'security-scanner'],
        busyAgents: [],
        agentTypes: {}
      },
      resources: {
        timeRemaining: context.timeRemaining || 3600,
        memoryAvailable: 4096,
        parallelSlots: 4
      },
      context: {
        environment: context.environment || 'development',
        changeSize,
        riskLevel,
        previousFailures: context.previousFailures || 0
      }
    };
  }

  /**
   * Simulate action effects on world state
   */
  private simulateActionEffects(
    stateBefore: WorldState,
    action: RemediationAction,
    success: boolean
  ): WorldState {
    const stateAfter: WorldState = JSON.parse(JSON.stringify(stateBefore));

    if (!success) return stateAfter;

    // Parse effects and apply them
    for (const effect of action.effects) {
      // Effect format examples:
      // "coverage.line >= 80" -> set coverage if action category is test/coverage
      // "quality.testsPassing = true" -> set tests passing
      // "quality.securityMeasured = true" -> mark security as measured

      if (effect.includes('coverage') && action.category === 'test') {
        // Simulate coverage improvement
        stateAfter.coverage.line = Math.min(100, stateBefore.coverage.line + 10);
        stateAfter.coverage.branch = Math.min(100, stateBefore.coverage.branch + 5);
        stateAfter.coverage.measured = true;
      }

      if (effect.includes('testsPassing') || action.category === 'test') {
        stateAfter.quality.testsPassing = Math.min(100, stateBefore.quality.testsPassing + 5);
        stateAfter.quality.testsMeasured = true;
      }

      if (effect.includes('security') || action.category === 'security') {
        stateAfter.quality.securityScore = Math.min(100, stateBefore.quality.securityScore + 10);
        stateAfter.quality.securityMeasured = true;
      }

      if (effect.includes('performance') || action.category === 'performance') {
        stateAfter.quality.performanceScore = Math.min(100, stateBefore.quality.performanceScore + 5);
        stateAfter.quality.performanceMeasured = true;
      }

      if (effect.includes('gateStatus')) {
        stateAfter.quality.gateStatus = 'passed';
        stateAfter.quality.gateEvaluated = true;
      }
    }

    return stateAfter;
  }

  /**
   * Convert RemediationAction to GOAPAction for learning
   */
  private remediationActionToGOAPAction(action: RemediationAction): GOAPAction {
    return {
      id: action.id,
      name: action.name,
      description: action.description,
      agentType: action.agentType,
      preconditions: {}, // Preconditions were already checked during planning
      effects: {}, // Effects are string[] in RemediationAction
      cost: 1.0 / (action.successRate || 1.0), // Higher cost for lower success rate
      durationEstimate: action.estimatedDuration,
      successRate: action.successRate,
      category: action.category as GOAPAction['category']
    };
  }

  /**
   * Convert RemediationPlan to GOAPPlan for learning
   */
  private remediationPlanToGOAPPlan(
    plan: RemediationPlan,
    initialState: WorldState
  ): GOAPPlan {
    return {
      id: plan.planId,
      actions: plan.actions.map(a => this.remediationActionToGOAPAction(a)),
      totalCost: plan.totalCost,
      estimatedDuration: plan.estimatedDuration,
      goalConditions: {
        'quality.gateStatus': { eq: 'passed' }
      },
      initialState,
      status: 'executing'
    };
  }

  /**
   * Update plan status in database
   */
  private async updatePlanStatus(
    planId: string,
    status: 'pending' | 'executing' | 'completed' | 'failed',
    success?: boolean,
    failureReason?: string
  ): Promise<void> {
    try {
      if (status === 'executing') {
        this.db.prepare(`
          UPDATE goap_plans SET status = ?, started_at = CURRENT_TIMESTAMP WHERE id = ?
        `).run(status, planId);
      } else {
        this.db.prepare(`
          UPDATE goap_plans
          SET status = ?, success = ?, failure_reason = ?, completed_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).run(status, success ? 1 : 0, failureReason || null, planId);
      }
    } catch (error) {
      this.logger.warn('[PlanExecutor] Failed to update plan status', { planId, error });
    }
  }
}

/**
 * Factory function to create a PlanExecutor
 */
export function createPlanExecutor(
  dbPath: string,
  config: PlanExecutionConfig = {}
): { executor: PlanExecutor; integration: GOAPQualityGateIntegration } {
  const Database = require('better-sqlite3');
  const db = new Database(dbPath);
  const integration = new GOAPQualityGateIntegration(db);

  return {
    executor: new PlanExecutor(db, integration, config),
    integration
  };
}

/**
 * Execute a quality gate remediation with GOAP planning
 *
 * High-level function that:
 * 1. Generates a remediation plan
 * 2. Executes the plan
 * 3. Records outcomes for learning
 */
export async function executeQualityGateRemediation(
  metrics: QualityGateMetrics,
  context: QualityGateContext,
  dbPath: string,
  targetGoal?: keyof typeof QUALITY_GATE_GOALS,
  config: PlanExecutionConfig = {}
): Promise<PlanExecutionResult | null> {
  const { executor, integration } = createPlanExecutor(dbPath, config);

  try {
    await integration.initialize();

    // Generate remediation plan
    const plan = await integration.generateRemediationPlan(metrics, context, targetGoal);

    if (!plan) {
      Logger.getInstance().info('[executeQualityGateRemediation] No remediation needed - goal already satisfied');
      return null;
    }

    // Execute the plan
    return await executor.executePlan(plan, context, metrics);
  } finally {
    integration.close();
  }
}

/**
 * QUIC Transport Layer for Agentic QE Fleet
 *
 * High-performance QUIC protocol implementation using Rust/WASM
 * for ultra-low latency agent communication.
 *
 * Features:
 * - 0-RTT connection establishment (50-70% faster than TCP)
 * - Stream multiplexing (no head-of-line blocking)
 * - Connection pooling with automatic reuse
 * - TLS 1.3 encryption built-in
 *
 * @packageDocumentation
 */

// NOTE: This requires the @agentic-flow/quic-wasm module to be installed
// The types are imported from the WASM bindings generated by wasm-bindgen
// If the WASM module is not available, use quic-loader.ts for graceful fallback

// Type definitions for optional WASM module
// The @agentic-flow/quic-wasm module is optional - if not available,
// use quic-loader.ts which provides WebSocket fallback

export interface WasmQuicClient {
  sendMessage(address: string, message: QuicMessage): Promise<void>;
  recvMessage(address: string): Promise<QuicMessage>;
  poolStats(): Promise<PoolStats>;
  close(): Promise<void>;
}

export interface ConnectionConfig {
  server_name: string;
  max_idle_timeout_ms: number;
  max_concurrent_streams: number;
  enable_0rtt: boolean;
}

export interface QuicMessage {
  id: string;
  msg_type: string | Record<string, unknown>;
  payload: number[];
  metadata?: Record<string, unknown>;
}

export interface PoolStats {
  active: number;
  idle: number;
  created: number;
  closed: number;
}

export interface QuicTransportConfig {
  /** Server name for TLS SNI */
  serverName?: string;
  /** Maximum idle timeout in milliseconds */
  maxIdleTimeoutMs?: number;
  /** Maximum concurrent streams per connection */
  maxConcurrentStreams?: number;
  /** Enable 0-RTT connection establishment */
  enable0Rtt?: boolean;
}

export interface AgentMessage {
  /** Unique message identifier */
  id: string;
  /** Message type */
  type: 'task' | 'result' | 'status' | 'coordination' | 'heartbeat' | string;
  /** Message payload */
  payload: unknown;
  /** Optional metadata */
  metadata?: Record<string, unknown>;
}

export interface PoolStatistics {
  /** Active connections */
  active: number;
  /** Idle connections */
  idle: number;
  /** Total connections created */
  created: number;
  /** Total connections closed */
  closed: number;
}

/**
 * QUIC Transport implementation
 *
 * Provides high-performance agent communication using the QUIC protocol
 * via Rust/WASM bindings. Requires the agentic-flow-quic WASM module.
 *
 * @example
 * ```typescript
 * const transport = await QuicTransport.create({
 *   serverName: 'agent-cluster.local',
 *   enable0Rtt: true
 * });
 *
 * await transport.send('192.168.1.100:4433', {
 *   id: 'msg-001',
 *   type: 'task',
 *   payload: { action: 'run-tests' }
 * });
 *
 * const response = await transport.receive('192.168.1.100:4433');
 * ```
 */
export class QuicTransport {
  private wasmClient: WasmQuicClient | null = null;
  private config: Required<QuicTransportConfig>;

  private constructor(config: Required<QuicTransportConfig>) {
    this.config = config;
  }

  /**
   * Create a new QUIC transport instance
   *
   * @param config - Transport configuration options
   * @returns Promise resolving to configured QuicTransport
   * @throws Error if WASM module is not available or config is invalid
   */
  static async create(config: QuicTransportConfig = {}): Promise<QuicTransport> {
    // Dynamic import of the WASM module
    // This will throw if the module is not available - use quic-loader.ts for fallback
    const wasmModule = await import('@agentic-flow/quic-wasm');

    const fullConfig: Required<QuicTransportConfig> = {
      serverName: config.serverName ?? 'localhost',
      maxIdleTimeoutMs: config.maxIdleTimeoutMs ?? 30000,
      maxConcurrentStreams: config.maxConcurrentStreams ?? 100,
      enable0Rtt: config.enable0Rtt ?? true,
    };

    // Validate configuration
    if (fullConfig.maxIdleTimeoutMs < 1000) {
      throw new Error('maxIdleTimeoutMs must be >= 1000ms');
    }

    if (fullConfig.maxConcurrentStreams === 0) {
      throw new Error('maxConcurrentStreams must be > 0');
    }

    const transport = new QuicTransport(fullConfig);

    // Initialize WASM client with configuration
    const wasmConfig = wasmModule.defaultConfig();
    wasmConfig.server_name = fullConfig.serverName;
    wasmConfig.max_idle_timeout_ms = fullConfig.maxIdleTimeoutMs;
    wasmConfig.max_concurrent_streams = fullConfig.maxConcurrentStreams;
    wasmConfig.enable_0rtt = fullConfig.enable0Rtt;

    transport.wasmClient = await wasmModule.WasmQuicClient.new(wasmConfig);

    return transport;
  }

  /**
   * Send a message to an agent at the specified address
   *
   * @param address - Target address in format "host:port"
   * @param message - Message to send
   * @throws Error if transport is not initialized
   */
  async send(address: string, message: AgentMessage): Promise<void> {
    if (!this.wasmClient) {
      throw new Error('Transport not initialized');
    }

    const wasmModule = await import('@agentic-flow/quic-wasm');

    // Encode payload as bytes
    const payloadBytes = new TextEncoder().encode(JSON.stringify(message.payload));

    // Create QUIC message
    const quicMessage = wasmModule.createQuicMessage(
      message.id,
      message.type,
      Array.from(payloadBytes),
      message.metadata ?? null
    );

    await this.wasmClient.sendMessage(address, quicMessage);
  }

  /**
   * Receive a message from an agent at the specified address
   *
   * @param address - Source address in format "host:port"
   * @returns Promise resolving to received AgentMessage
   * @throws Error if transport is not initialized
   */
  async receive(address: string): Promise<AgentMessage> {
    if (!this.wasmClient) {
      throw new Error('Transport not initialized');
    }

    const quicMessage = await this.wasmClient.recvMessage(address);

    // Decode payload from bytes
    const payloadStr = new TextDecoder().decode(
      new Uint8Array(quicMessage.payload)
    );
    const payload = JSON.parse(payloadStr);

    return {
      id: quicMessage.id,
      type: typeof quicMessage.msg_type === 'string'
        ? quicMessage.msg_type
        : Object.keys(quicMessage.msg_type)[0],
      payload,
      metadata: quicMessage.metadata as Record<string, unknown> | undefined,
    };
  }

  /**
   * Get connection pool statistics
   *
   * @returns Promise resolving to pool statistics
   * @throws Error if transport is not initialized
   */
  async getStats(): Promise<PoolStatistics> {
    if (!this.wasmClient) {
      throw new Error('Transport not initialized');
    }

    const stats = await this.wasmClient.poolStats();
    return {
      active: stats.active,
      idle: stats.idle,
      created: stats.created,
      closed: stats.closed,
    };
  }

  /**
   * Close the transport and release all connections
   */
  async close(): Promise<void> {
    if (this.wasmClient) {
      await this.wasmClient.close();
      this.wasmClient = null;
    }
  }

  /**
   * Send a request and wait for response (convenience method)
   *
   * @param address - Target address
   * @param message - Request message
   * @returns Promise resolving to response message
   */
  async request(address: string, message: AgentMessage): Promise<AgentMessage> {
    await this.send(address, message);
    return this.receive(address);
  }

  /**
   * Send multiple messages in parallel
   *
   * @param address - Target address
   * @param messages - Array of messages to send
   */
  async sendBatch(address: string, messages: AgentMessage[]): Promise<void> {
    await Promise.all(messages.map(msg => this.send(address, msg)));
  }
}

/**
 * Create a QUIC transport with default configuration
 *
 * @param config - Optional configuration overrides
 * @returns Promise resolving to QuicTransport instance
 */
export async function createQuicTransport(
  config?: QuicTransportConfig
): Promise<QuicTransport> {
  return QuicTransport.create(config);
}

export default QuicTransport;

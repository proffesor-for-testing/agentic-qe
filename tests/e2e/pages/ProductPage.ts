import { Page, Locator, expect } from '@playwright/test';
import { BasePage } from './BasePage';

/**
 * Product Detail Page Object Model
 * Handles interactions with individual product pages
 *
 * Generated by: qe-queen-coordinator
 */
export class ProductPage extends BasePage {
  // Product information
  readonly productTitle: Locator;
  readonly productPrice: Locator;
  readonly productDescription: Locator;
  readonly productImage: Locator;
  readonly productGallery: Locator;

  // Variant selectors
  readonly variantSelector: Locator;
  readonly sizeSelector: Locator;
  readonly colorSelector: Locator;

  // Quantity and cart
  readonly quantityInput: Locator;
  readonly quantityIncrease: Locator;
  readonly quantityDecrease: Locator;
  readonly addToCartButton: Locator;

  // Stock status
  readonly stockStatus: Locator;
  readonly soldOutMessage: Locator;

  // Related products
  readonly relatedProducts: Locator;
  readonly relatedProductCards: Locator;

  // Breadcrumbs
  readonly breadcrumbs: Locator;

  constructor(page: Page) {
    super(page);

    // Product information selectors
    this.productTitle = page.locator('h1, .product-title, .product__title');
    this.productPrice = page.locator('.product-price, .price, [data-product-price]');
    this.productDescription = page.locator('.product-description, .product__description, [data-description]');
    this.productImage = page.locator('.product-image, .product__image, [data-product-image]');
    this.productGallery = page.locator('.product-gallery, .product-images');

    // Variant selectors
    this.variantSelector = page.locator('[data-variant-selector], .variant-selector, select[name="id"]');
    this.sizeSelector = page.locator('[data-option="Size"], .size-selector');
    this.colorSelector = page.locator('[data-option="Color"], .color-selector');

    // Quantity controls
    this.quantityInput = page.locator('[name="quantity"], input[type="number"], .quantity-input');
    this.quantityIncrease = page.locator('.quantity-plus, [data-quantity-plus], button:has-text("+")');
    this.quantityDecrease = page.locator('.quantity-minus, [data-quantity-minus], button:has-text("-")');
    this.addToCartButton = page.locator('#add, [data-add-to-cart], button:has-text("Add to Cart"), .add-to-cart');

    // Stock status
    this.stockStatus = page.locator('.stock-status, [data-stock]');
    this.soldOutMessage = page.locator('.sold-out, [data-sold-out]');

    // Related products
    this.relatedProducts = page.locator('.related-products, .product-recommendations, [data-recommendations]');
    this.relatedProductCards = page.locator('.related-products .product-card, [data-recommendations] .product-item');

    // Breadcrumbs
    this.breadcrumbs = page.locator('.breadcrumbs, [data-breadcrumbs]');
  }

  /**
   * Navigate to specific product
   */
  async navigate(productSlug: string) {
    await this.goto(`/collections/frontpage/products/${productSlug}`);
    await this.waitForPageLoad();
  }

  /**
   * Get product title text
   */
  async getProductTitle(): Promise<string> {
    const title = await this.productTitle.textContent();
    return title?.trim() || '';
  }

  /**
   * Get product price
   */
  async getProductPrice(): Promise<string> {
    const price = await this.productPrice.textContent();
    return price?.trim() || '';
  }

  /**
   * Get product description
   */
  async getProductDescription(): Promise<string> {
    const description = await this.productDescription.textContent();
    return description?.trim() || '';
  }

  /**
   * Check if product is in stock
   */
  async isInStock(): Promise<boolean> {
    const soldOut = await this.soldOutMessage.isVisible().catch(() => false);
    const addToCartVisible = await this.addToCartButton.isVisible().catch(() => false);
    return !soldOut && addToCartVisible;
  }

  /**
   * Set quantity
   */
  async setQuantity(quantity: number) {
    await this.quantityInput.fill(quantity.toString());
  }

  /**
   * Increase quantity
   */
  async increaseQuantity() {
    if (await this.quantityIncrease.isVisible()) {
      await this.quantityIncrease.click();
    }
  }

  /**
   * Decrease quantity
   */
  async decreaseQuantity() {
    if (await this.quantityDecrease.isVisible()) {
      await this.quantityDecrease.click();
    }
  }

  /**
   * Get current quantity value
   */
  async getQuantity(): Promise<number> {
    const value = await this.quantityInput.inputValue();
    return parseInt(value, 10) || 1;
  }

  /**
   * Select variant option
   */
  async selectVariant(variantName: string) {
    if (await this.variantSelector.isVisible()) {
      await this.variantSelector.selectOption({ label: variantName });
    }
  }

  /**
   * Add product to cart
   */
  async addToCart() {
    await this.addToCartButton.click();
    // Wait for cart update - either redirect or AJAX update
    await this.page.waitForTimeout(1000); // Allow for cart update animation
  }

  /**
   * Add to cart and go to cart
   */
  async addToCartAndGoToCart() {
    await this.addToCart();
    await this.goToCart();
  }

  /**
   * Verify product page loaded
   */
  async verifyProductPageLoaded() {
    await expect(this.productTitle).toBeVisible();
    await expect(this.productPrice).toBeVisible();
  }

  /**
   * Get related product names
   */
  async getRelatedProductNames(): Promise<string[]> {
    if (!(await this.relatedProducts.isVisible().catch(() => false))) {
      return [];
    }

    const titles = await this.relatedProductCards.locator('.product-title, h3').allTextContents();
    return titles.map(t => t.trim());
  }

  /**
   * Click on related product
   */
  async clickRelatedProduct(productName: string) {
    const relatedProduct = this.relatedProductCards.filter({ hasText: productName }).first();
    await relatedProduct.click();
    await this.page.waitForURL('**/products/**');
  }

  /**
   * Check if Add to Cart button is enabled
   */
  async isAddToCartEnabled(): Promise<boolean> {
    return await this.addToCartButton.isEnabled();
  }
}

import { test, expect } from '@playwright/test';
import { ProductPage, CartPage } from '../pages';
import { testData } from '../fixtures/test-data';

/**
 * Cart Management E2E Tests
 * Tests cart operations: add, update, remove, and edge cases
 *
 * Generated by: qe-queen-coordinator
 * Priority: P0 (Critical User Journey)
 */
test.describe('Cart Management @cart @critical', () => {
  test.describe('Add to Cart', () => {
    test('should add single product to cart', async ({ page }) => {
      const productPage = new ProductPage(page);
      const cartPage = new CartPage(page);

      await productPage.navigate(testData.products.greyJacket.slug);

      if (await productPage.isInStock()) {
        // Get initial cart count
        const initialCount = await productPage.getCartItemCount();

        // Add to cart
        await productPage.addToCart();

        // Verify cart updated
        await productPage.goToCart();
        const itemCount = await cartPage.getItemCount();
        expect(itemCount).toBeGreaterThan(0);
      } else {
        test.skip();
      }
    });

    test('should preserve cart across page navigations', async ({ page }) => {
      const productPage = new ProductPage(page);
      const cartPage = new CartPage(page);

      // Add product
      await productPage.navigate(testData.products.greyJacket.slug);

      if (await productPage.isInStock()) {
        await productPage.addToCart();

        // Navigate away
        await productPage.goto('/');

        // Navigate back to cart
        await cartPage.navigate();

        const isEmpty = await cartPage.isCartEmpty();
        expect(isEmpty).toBe(false);
      } else {
        test.skip();
      }
    });

    test('should show correct price in cart', async ({ page }) => {
      const productPage = new ProductPage(page);
      const cartPage = new CartPage(page);

      await productPage.navigate(testData.products.greyJacket.slug);
      const productPrice = await productPage.getProductPrice();

      if (await productPage.isInStock()) {
        await productPage.addToCart();
        await productPage.goToCart();

        const subtotal = await cartPage.getSubtotal();
        // Subtotal should contain the product price
        expect(subtotal).toBeTruthy();
      } else {
        test.skip();
      }
    });
  });

  test.describe('Cart Empty State', () => {
    test('should show empty cart message when no items', async ({ page }) => {
      const cartPage = new CartPage(page);

      await cartPage.navigate();

      const isEmpty = await cartPage.isCartEmpty();
      expect(isEmpty).toBe(true);
    });

    test('should provide continue shopping link from empty cart', async ({ page }) => {
      const cartPage = new CartPage(page);

      await cartPage.navigate();

      if (await cartPage.isCartEmpty()) {
        await cartPage.continueShopping();
        expect(page.url()).toContain('/collections');
      }
    });

    test('should not allow checkout with empty cart', async ({ page }) => {
      const cartPage = new CartPage(page);

      await cartPage.navigate();

      if (await cartPage.isCartEmpty()) {
        // Checkout button should not be functional or not visible
        const checkoutVisible = await cartPage.checkoutButton.isVisible().catch(() => false);

        if (checkoutVisible) {
          // If visible, clicking should not proceed to checkout
          await cartPage.checkoutButton.click();
          // Should stay on cart page or show error
          expect(page.url()).toContain('/cart');
        }
      }
    });
  });

  test.describe('Cart Item Operations', () => {
    test.beforeEach(async ({ page }) => {
      // Add a product before each test
      const productPage = new ProductPage(page);

      await productPage.navigate(testData.products.greyJacket.slug);

      if (await productPage.isInStock()) {
        await productPage.addToCart();
      } else {
        test.skip();
      }
    });

    test('should display cart item details correctly', async ({ page }) => {
      const cartPage = new CartPage(page);

      await cartPage.navigate();

      if (!(await cartPage.isCartEmpty())) {
        const itemNames = await cartPage.getItemNames();
        expect(itemNames.length).toBeGreaterThan(0);

        // Verify item name is correct
        const hasExpectedItem = itemNames.some(name =>
          name.toLowerCase().includes('jacket') ||
          name.toLowerCase().includes('grey')
        );
        expect(hasExpectedItem).toBe(true);
      }
    });

    test('should update item quantity', async ({ page }) => {
      const cartPage = new CartPage(page);

      await cartPage.navigate();

      if (!(await cartPage.isCartEmpty())) {
        const initialQuantity = await cartPage.getItemQuantity(0);

        // Update quantity
        await cartPage.updateQuantity(0, initialQuantity + 1);

        // Verify quantity updated
        const newQuantity = await cartPage.getItemQuantity(0);
        expect(newQuantity).toBe(initialQuantity + 1);
      }
    });

    test('should remove item from cart', async ({ page }) => {
      const cartPage = new CartPage(page);

      await cartPage.navigate();

      if (!(await cartPage.isCartEmpty())) {
        const initialCount = await cartPage.getItemCount();

        // Remove first item
        await cartPage.removeItem(0);

        // Verify item removed
        const newCount = await cartPage.getItemCount();
        expect(newCount).toBeLessThan(initialCount);
      }
    });

    test('should clear cart completely', async ({ page }) => {
      const cartPage = new CartPage(page);

      await cartPage.navigate();

      if (!(await cartPage.isCartEmpty())) {
        // Clear all items
        await cartPage.clearCart();

        const isEmpty = await cartPage.isCartEmpty();
        expect(isEmpty).toBe(true);
      }
    });
  });

  test.describe('Cart Calculations', () => {
    test('should calculate correct subtotal for single item', async ({ page }) => {
      const productPage = new ProductPage(page);
      const cartPage = new CartPage(page);

      await productPage.navigate(testData.products.greyJacket.slug);

      if (await productPage.isInStock()) {
        await productPage.addToCart();
        await productPage.goToCart();

        const subtotal = await cartPage.getSubtotal();
        expect(parseFloat(subtotal)).toBeGreaterThan(0);
      } else {
        test.skip();
      }
    });

    test('should update subtotal when quantity changes', async ({ page }) => {
      const productPage = new ProductPage(page);
      const cartPage = new CartPage(page);

      await productPage.navigate(testData.products.greyJacket.slug);

      if (await productPage.isInStock()) {
        await productPage.addToCart();
        await productPage.goToCart();

        const initialSubtotal = parseFloat(await cartPage.getSubtotal());

        // Double the quantity
        await cartPage.updateQuantity(0, 2);

        const newSubtotal = parseFloat(await cartPage.getSubtotal());

        // New subtotal should be approximately double
        expect(newSubtotal).toBeGreaterThan(initialSubtotal);
      } else {
        test.skip();
      }
    });
  });

  test.describe('Cart Edge Cases', () => {
    test('should handle setting quantity to zero', async ({ page }) => {
      const productPage = new ProductPage(page);
      const cartPage = new CartPage(page);

      await productPage.navigate(testData.products.greyJacket.slug);

      if (await productPage.isInStock()) {
        await productPage.addToCart();
        await productPage.goToCart();

        if (!(await cartPage.isCartEmpty())) {
          // Set quantity to 0 (should remove item)
          await cartPage.updateQuantity(0, 0);

          // Item should be removed
          const isEmpty = await cartPage.isCartEmpty();
          // Either empty or item removed
          expect(isEmpty || await cartPage.getItemCount() === 0).toBe(true);
        }
      } else {
        test.skip();
      }
    });

    test('should handle large quantity values', async ({ page }) => {
      const productPage = new ProductPage(page);
      const cartPage = new CartPage(page);

      await productPage.navigate(testData.products.greyJacket.slug);

      if (await productPage.isInStock()) {
        await productPage.addToCart();
        await productPage.goToCart();

        if (!(await cartPage.isCartEmpty())) {
          // Try setting a large quantity
          await cartPage.updateQuantity(0, 999);

          // Should either accept or show error, not crash
          const quantity = await cartPage.getItemQuantity(0);
          expect(quantity).toBeGreaterThan(0);
        }
      } else {
        test.skip();
      }
    });

    test('should handle rapid add to cart clicks', async ({ page }) => {
      const productPage = new ProductPage(page);
      const cartPage = new CartPage(page);

      await productPage.navigate(testData.products.greyJacket.slug);

      if (await productPage.isInStock()) {
        // Rapid clicks
        await productPage.addToCartButton.click();
        await productPage.addToCartButton.click();
        await productPage.addToCartButton.click();

        await page.waitForTimeout(2000);

        await productPage.goToCart();

        // Cart should have items, not crash
        const isEmpty = await cartPage.isCartEmpty();
        expect(isEmpty).toBe(false);
      } else {
        test.skip();
      }
    });
  });
});

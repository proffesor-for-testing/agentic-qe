import { test, expect } from '@playwright/test';
import { HomePage } from '../pages';
import { TestData } from '../fixtures/test-data';

/**
 * Product Collection Page E2E Tests
 * Target: https://sauce-demo.myshopify.com/collections/all
 *
 * QE Assessment: sauce-demo.myshopify.com
 * Generated by: QE Queen Coordinator
 * Assessment Date: 2026-01-26
 *
 * Coverage:
 * - Page load and core elements
 * - Product grid display
 * - Product card interactions
 * - Navigation
 * - Responsive layout
 * - Performance checks
 * - Edge cases
 */

test.describe('Product Collection Page - /collections/all @collection', () => {

  test.beforeEach(async ({ page }) => {
    await page.goto('/collections/all');
    await page.waitForLoadState('networkidle');
  });

  test.describe('Page Load and Core Elements @critical', () => {

    test('should load collection page successfully', async ({ page }) => {
      await expect(page).toHaveURL(/.*\/collections\/all.*/);
      await expect(page).not.toHaveTitle(/error|404/i);
    });

    test('should display page header with navigation', async ({ page }) => {
      const header = page.locator('header, .site-header');
      await expect(header).toBeVisible();

      // Verify navigation links
      await expect(page.locator('a[href="/"]').first()).toBeVisible();
      await expect(page.locator('[href="/cart"]').first()).toBeVisible();
    });

    test('should display breadcrumb navigation', async ({ page }) => {
      const breadcrumb = page.locator('.breadcrumb, nav[aria-label*="Breadcrumb"], .breadcrumbs');

      // Breadcrumb may or may not be present depending on theme
      if (await breadcrumb.isVisible({ timeout: 3000 }).catch(() => false)) {
        await expect(breadcrumb).toContainText(/home|products/i);
      }
    });

    test('should show cart with item count', async ({ page }) => {
      const cartLink = page.locator('[href="/cart"], .cart-link').first();
      await expect(cartLink).toBeVisible();

      // Cart count should be visible (may be 0)
      const cartText = await cartLink.textContent();
      expect(cartText).toMatch(/cart|\d+|\(0\)/i);
    });

    test('should display page title or heading', async ({ page }) => {
      // Look for page heading
      const heading = page.locator('h1, h2.collection-title, .page-title');
      const headingCount = await heading.count();

      expect(headingCount).toBeGreaterThanOrEqual(1);
    });
  });

  test.describe('Product Grid Display @critical', () => {

    test('should display product grid with multiple products', async ({ page }) => {
      const productCards = page.locator('[class*="product"] a, .grid-product, .product-card');
      const count = await productCards.count();

      expect(count).toBeGreaterThanOrEqual(5);
    });

    test('should display product images for all items', async ({ page }) => {
      const productImages = page.locator('[class*="product"] img, .grid-product img, .product-card img');
      const imageCount = await productImages.count();

      expect(imageCount).toBeGreaterThan(0);

      // Verify first image has valid src
      const firstSrc = await productImages.first().getAttribute('src');
      expect(firstSrc).toMatch(/cdn\.shopify\.com|\.jpg|\.png|\.webp/i);
    });

    test('should display product titles', async ({ page }) => {
      const titles = page.locator('.grid-product__title, [class*="product-title"], .product-card__title, h3 a, h4 a');

      const titleTexts = await titles.allTextContents();
      expect(titleTexts.length).toBeGreaterThan(0);

      // Verify known product exists
      const allTitles = titleTexts.join(' ').toLowerCase();
      expect(allTitles).toMatch(/jacket|top|sandals|heels|shades/i);
    });

    test('should display product prices in GBP format', async ({ page }) => {
      const prices = page.locator('.grid-product__price, .money, [class*="price"], .product-price');
      const priceTexts = await prices.allTextContents();

      expect(priceTexts.length).toBeGreaterThan(0);

      // Verify GBP currency format exists
      const allPrices = priceTexts.join(' ');
      expect(allPrices).toMatch(/Â£\d+(\.\d{2})?/);
    });

    test('should indicate sold out products', async ({ page }) => {
      // Look for sold out indicators
      const soldOutBadges = page.locator('.badge--sold-out, :text("Sold Out"), :text("sold out"), .sold-out');
      const soldOutCount = await soldOutBadges.count();

      // Based on site analysis, products may or may not be sold out
      expect(soldOutCount).toBeGreaterThanOrEqual(0);
    });

    test('should display at least 7 products', async ({ page }) => {
      // Based on site analysis, there are 7+ products
      const products = page.locator('[class*="product"] a[href*="/products/"], .grid-product a[href*="/products/"]');
      const count = await products.count();

      expect(count).toBeGreaterThanOrEqual(5);
    });
  });

  test.describe('Product Card Interactions @critical', () => {

    test('should navigate to product page when clicking product', async ({ page }) => {
      const firstProduct = page.locator('[class*="product"] a[href*="/products/"], .grid-product a[href*="/products/"]').first();
      await firstProduct.click();

      await expect(page).toHaveURL(/.*\/products\/.*/);
    });

    test('should navigate to specific product page', async ({ page }) => {
      // Look for any known product
      const knownProducts = ['Grey jacket', 'Noir jacket', 'Striped top', 'Black heels'];
      let productFound = false;

      for (const product of knownProducts) {
        const productLink = page.locator(`a:has-text("${product}")`).first();
        if (await productLink.isVisible({ timeout: 1000 }).catch(() => false)) {
          await productLink.click();
          await expect(page).toHaveURL(/.*\/products\/.*/);
          productFound = true;
          break;
        }
      }

      // If no known product found, click any product
      if (!productFound) {
        const anyProduct = page.locator('[class*="product"] a[href*="/products/"]').first();
        await anyProduct.click();
        await expect(page).toHaveURL(/.*\/products\/.*/);
      }
    });

    test('should show hover effects on product cards', async ({ page }) => {
      const firstCard = page.locator('[class*="product"], .grid-product, .product-card').first();

      await firstCard.hover();

      // Verify page doesn't error on hover
      await expect(page).not.toHaveTitle(/error/i);
    });

    test('should handle click on sold out product', async ({ page }) => {
      const soldOutProduct = page.locator('[class*="product"]:has-text("Sold Out") a, .grid-product:has-text("Sold Out") a').first();

      if (await soldOutProduct.isVisible({ timeout: 2000 }).catch(() => false)) {
        await soldOutProduct.click();

        // Should still navigate to product page
        await expect(page).toHaveURL(/.*\/products\/.*/);
      }
    });

    test('should have clickable product images', async ({ page }) => {
      const productImage = page.locator('[class*="product"] img, .grid-product img').first();

      // Find parent link
      const parentLink = productImage.locator('xpath=ancestor::a[contains(@href, "/products/")]');

      if (await parentLink.isVisible({ timeout: 2000 }).catch(() => false)) {
        await parentLink.click();
        await expect(page).toHaveURL(/.*\/products\/.*/);
      }
    });
  });

  test.describe('Navigation from Collection Page', () => {

    test('should navigate to cart from collection page', async ({ page }) => {
      await page.locator('[href="/cart"], .cart-link').first().click();

      await expect(page).toHaveURL(/.*\/cart.*/);
    });

    test('should navigate to home page via logo', async ({ page }) => {
      const logo = page.locator('a[href="/"]').first();
      await logo.click();

      await expect(page).toHaveURL(/^https:\/\/[^/]+\/?$/);
    });

    test('should allow search from collection page', async ({ page }) => {
      const searchIcon = page.locator('[data-search], .site-header__search, [aria-label*="Search"], .search-icon');

      if (await searchIcon.isVisible({ timeout: 3000 }).catch(() => false)) {
        await searchIcon.click();

        const searchInput = page.locator('input[type="search"], input[name="q"]');
        await searchInput.fill('jacket');
        await searchInput.press('Enter');

        await expect(page).toHaveURL(/.*search.*q=jacket.*/i);
      }
    });

    test('should navigate to catalog/collection from nav', async ({ page }) => {
      const catalogLink = page.locator('a:has-text("Catalog"), a[href*="/collections"]').first();

      if (await catalogLink.isVisible({ timeout: 2000 }).catch(() => false)) {
        await catalogLink.click();
        await expect(page).toHaveURL(/.*\/collections\/.*/);
      }
    });
  });

  test.describe('Responsive Layout @mobile', () => {

    test('should display correctly on mobile viewport', async ({ page }) => {
      await page.setViewportSize({ width: 375, height: 667 });
      await page.reload();
      await page.waitForLoadState('networkidle');

      // Page should still load
      await expect(page).not.toHaveTitle(/error/i);

      // Products should be visible
      const products = page.locator('[class*="product"], .grid-product, .product-card');
      await expect(products.first()).toBeVisible();
    });

    test('should display correctly on tablet viewport', async ({ page }) => {
      await page.setViewportSize({ width: 768, height: 1024 });
      await page.reload();
      await page.waitForLoadState('networkidle');

      const products = page.locator('[class*="product"], .grid-product, .product-card');
      const count = await products.count();
      expect(count).toBeGreaterThan(0);
    });

    test('should have accessible menu toggle on mobile', async ({ page }) => {
      await page.setViewportSize({ width: 375, height: 667 });
      await page.reload();
      await page.waitForLoadState('networkidle');

      const menuToggle = page.locator('[data-drawer-toggle], .menu-toggle, .hamburger, button:has-text("Menu"), [aria-label*="Menu"]');

      if (await menuToggle.isVisible({ timeout: 2000 }).catch(() => false)) {
        await expect(menuToggle).toBeEnabled();
      }
    });

    test('should maintain product grid on mobile', async ({ page }) => {
      await page.setViewportSize({ width: 375, height: 667 });
      await page.reload();

      const products = page.locator('[class*="product"] a[href*="/products/"], .grid-product a[href*="/products/"]');
      const count = await products.count();

      expect(count).toBeGreaterThanOrEqual(5);
    });
  });

  test.describe('Performance Checks', () => {

    test('should load all images within timeout', async ({ page }) => {
      const images = page.locator('[class*="product"] img, .grid-product img');
      const imageCount = await images.count();

      for (let i = 0; i < Math.min(imageCount, 5); i++) {
        const img = images.nth(i);
        await expect(img).toBeVisible({ timeout: 10000 });

        // Check image loaded successfully
        const naturalWidth = await img.evaluate((el: HTMLImageElement) => el.naturalWidth);
        expect(naturalWidth).toBeGreaterThan(0);
      }
    });

    test('should have no console errors on page load', async ({ page }) => {
      const errors: string[] = [];

      page.on('console', msg => {
        if (msg.type() === 'error') {
          errors.push(msg.text());
        }
      });

      await page.goto('/collections/all');
      await page.waitForLoadState('networkidle');

      // Filter out known third-party errors
      const criticalErrors = errors.filter(e =>
        !e.includes('facebook') &&
        !e.includes('adroll') &&
        !e.includes('hcaptcha') &&
        !e.includes('Failed to load resource') // CDN images
      );

      expect(criticalErrors).toHaveLength(0);
    });

    test('should complete initial load within 10 seconds', async ({ page }) => {
      const startTime = Date.now();

      await page.goto('/collections/all', { waitUntil: 'domcontentloaded' });

      const loadTime = Date.now() - startTime;
      expect(loadTime).toBeLessThan(10000);
    });
  });

  test.describe('Edge Cases', () => {

    test('should handle direct URL access to collection', async ({ page }) => {
      await page.goto('/collections/all');

      await expect(page).toHaveURL(/.*\/collections\/all.*/);
      await expect(page).not.toHaveTitle(/error|404/i);
    });

    test('should handle browser back navigation', async ({ page }) => {
      // Click a product
      await page.locator('[class*="product"] a[href*="/products/"]').first().click();
      await page.waitForURL(/.*\/products\/.*/);

      // Go back
      await page.goBack();

      await expect(page).toHaveURL(/.*\/collections\/all.*/);
    });

    test('should handle page refresh', async ({ page }) => {
      await page.reload();
      await page.waitForLoadState('networkidle');

      await expect(page).toHaveURL(/.*\/collections\/all.*/);

      const products = page.locator('[class*="product"], .grid-product');
      await expect(products.first()).toBeVisible();
    });

    test('should handle invalid collection URL gracefully', async ({ page }) => {
      const response = await page.goto('/collections/nonexistent-collection-xyz');

      // Should either 404 or redirect
      expect(response?.status()).toBeGreaterThanOrEqual(200);
    });

    test('should handle URL with query parameters', async ({ page }) => {
      await page.goto('/collections/all?sort_by=price-ascending');

      // Page should load without errors
      await expect(page).not.toHaveTitle(/error/i);
    });

    test('should handle rapid navigation between products', async ({ page }) => {
      // Click first product
      await page.locator('[class*="product"] a[href*="/products/"]').first().click();
      await page.waitForURL(/.*\/products\/.*/);

      // Go back quickly
      await page.goBack();

      // Click another product
      await page.locator('[class*="product"] a[href*="/products/"]').nth(1).click();
      await page.waitForURL(/.*\/products\/.*/);

      // Should not error
      await expect(page).not.toHaveTitle(/error/i);
    });
  });

  test.describe('Accessibility Checks @a11y', () => {

    test('should have alt text on product images', async ({ page }) => {
      const images = page.locator('[class*="product"] img, .grid-product img');
      const imageCount = await images.count();

      for (let i = 0; i < Math.min(imageCount, 5); i++) {
        const img = images.nth(i);
        const alt = await img.getAttribute('alt');

        // Alt should be defined (can be empty for decorative images)
        expect(alt).toBeDefined();
      }
    });

    test('should allow keyboard navigation through products', async ({ page }) => {
      // Tab through the page
      for (let i = 0; i < 15; i++) {
        await page.keyboard.press('Tab');
      }

      // Should have a focused element
      const focusedElement = await page.evaluate(() => document.activeElement?.tagName);
      expect(focusedElement).toBeTruthy();
    });

    test('should have focusable product links', async ({ page }) => {
      const productLink = page.locator('[class*="product"] a[href*="/products/"]').first();

      await productLink.focus();

      // Should be focused
      const isFocused = await productLink.evaluate(el => el === document.activeElement);
      expect(isFocused).toBe(true);
    });

    test('should have proper heading structure', async ({ page }) => {
      const h1Count = await page.locator('h1').count();

      // Should have at least one h1
      expect(h1Count).toBeGreaterThanOrEqual(1);
    });
  });
});

import { test, expect } from '@playwright/test';

/**
 * Security Tests for Product Collection Page
 * Target: https://sauce-demo.myshopify.com/collections/all
 *
 * QE Assessment: sauce-demo.myshopify.com
 * Generated by: QE Queen Coordinator - Security Domain
 * Assessment Date: 2026-01-26
 *
 * Coverage:
 * - XSS prevention
 * - Secure headers
 * - Cookie security
 * - Path traversal prevention
 * - Rate limiting
 * - Input sanitization
 */

test.describe('Collection Page Security @security', () => {

  test.describe('XSS Prevention', () => {

    test('should sanitize XSS in URL query parameters', async ({ page }) => {
      const xssPayload = encodeURIComponent('<script>alert("xss")</script>');
      await page.goto(`/collections/all?sort=${xssPayload}`);

      const content = await page.content();
      expect(content).not.toContain('<script>alert');
    });

    test('should sanitize XSS via img onerror in URL', async ({ page }) => {
      const xssPayload = encodeURIComponent('<img src=x onerror=alert(1)>');
      await page.goto(`/collections/all?q=${xssPayload}`);

      const content = await page.content();
      expect(content).not.toContain('onerror=alert');
    });

    test('should sanitize XSS in search from collection page', async ({ page }) => {
      await page.goto('/collections/all');

      const searchIcon = page.locator('[data-search], .site-header__search, [aria-label*="Search"]');
      if (await searchIcon.isVisible({ timeout: 3000 }).catch(() => false)) {
        await searchIcon.click();

        const searchInput = page.locator('input[type="search"], input[name="q"]');
        await searchInput.fill('<img src=x onerror=alert(1)>');
        await searchInput.press('Enter');

        const content = await page.content();
        expect(content).not.toContain('onerror=alert');
      }
    });

    test('should escape HTML entities in URL parameters', async ({ page }) => {
      await page.goto('/collections/all?filter=<b>bold</b>');

      const content = await page.content();
      // Should see escaped entities or no raw HTML
      expect(content).not.toMatch(/<b>bold<\/b>/);
    });

    test('should handle javascript: protocol in links', async ({ page }) => {
      await page.goto('/collections/all?redirect=javascript:alert(1)');

      // Page should load without executing script
      await expect(page).not.toHaveTitle(/error/i);
    });
  });

  test.describe('Secure Headers', () => {

    test('should use HTTPS for collection page', async ({ page }) => {
      await page.goto('/collections/all');

      expect(page.url()).toMatch(/^https:\/\//);
    });

    test('should have Strict-Transport-Security header', async ({ page }) => {
      const response = await page.goto('/collections/all');
      const headers = response?.headers();

      expect(headers?.['strict-transport-security']).toBeTruthy();
    });

    test('should have X-Content-Type-Options header', async ({ page }) => {
      const response = await page.goto('/collections/all');
      const headers = response?.headers();

      expect(headers?.['x-content-type-options']).toBe('nosniff');
    });

    test('should have X-Frame-Options or CSP frame-ancestors', async ({ page }) => {
      const response = await page.goto('/collections/all');
      const headers = response?.headers();

      const hasXFrameOptions = headers?.['x-frame-options'];
      const hasCSP = headers?.['content-security-policy'];

      // At least one should be present for clickjacking protection
      expect(hasXFrameOptions || hasCSP).toBeTruthy();
    });
  });

  test.describe('Cookie Security', () => {

    test('should have secure cookies', async ({ page }) => {
      await page.goto('/collections/all');

      const cookies = await page.context().cookies();

      cookies.forEach(cookie => {
        if (cookie.name.includes('session') || cookie.name.includes('cart') || cookie.name.includes('_shopify')) {
          expect(cookie.secure).toBe(true);
        }
      });
    });

    test('should have SameSite attribute on cookies', async ({ page }) => {
      await page.goto('/collections/all');

      const cookies = await page.context().cookies();

      cookies.forEach(cookie => {
        if (cookie.name.includes('session') || cookie.name.includes('cart')) {
          // SameSite should be Strict, Lax, or None
          expect(['Strict', 'Lax', 'None', undefined]).toContain(cookie.sameSite);
        }
      });
    });

    test('should not expose sensitive data in cookies', async ({ page }) => {
      await page.goto('/collections/all');

      const cookies = await page.context().cookies();

      cookies.forEach(cookie => {
        // Cookie values should not contain obvious PII patterns
        expect(cookie.value).not.toMatch(/@.*\./); // Email pattern
        expect(cookie.value).not.toMatch(/password/i);
        expect(cookie.value).not.toMatch(/\d{16}/); // Credit card pattern
      });
    });
  });

  test.describe('Path Traversal Prevention', () => {

    test('should prevent path traversal attacks', async ({ page }) => {
      const response = await page.goto('/collections/all/../../../etc/passwd');

      // Should not expose system files - expect redirect or error
      expect(response?.status()).toBeGreaterThanOrEqual(200);

      const content = await page.content();
      expect(content).not.toContain('root:');
    });

    test('should prevent encoded path traversal', async ({ page }) => {
      const response = await page.goto('/collections/all/%2e%2e/%2e%2e/etc/passwd');

      // Should not expose system files
      const content = await page.content();
      expect(content).not.toContain('root:');
    });

    test('should handle double encoding safely', async ({ page }) => {
      const response = await page.goto('/collections/all/%252e%252e/');

      await expect(page).not.toHaveTitle(/error/i);
    });
  });

  test.describe('Rate Limiting', () => {

    test('should handle rapid page requests', async ({ page }) => {
      const requests = [];

      for (let i = 0; i < 5; i++) {
        requests.push(page.goto('/collections/all'));
      }

      const results = await Promise.allSettled(requests);
      const errors = results.filter(r => r.status === 'rejected');

      expect(errors.length).toBe(0);
    });

    test('should handle concurrent API requests', async ({ page }) => {
      await page.goto('/collections/all');

      const responses = await Promise.all([
        page.evaluate(() => fetch('/cart.json').then(r => r.status)),
        page.evaluate(() => fetch('/cart.json').then(r => r.status)),
        page.evaluate(() => fetch('/cart.json').then(r => r.status)),
      ]);

      // All requests should succeed (no 429 rate limiting for reasonable usage)
      responses.forEach(status => {
        expect(status).toBeLessThan(500);
      });
    });
  });

  test.describe('Input Sanitization', () => {

    test('should handle SQL injection attempts in URL', async ({ page }) => {
      await page.goto("/collections/all?id=1' OR '1'='1");

      // Page should not error
      await expect(page).not.toHaveTitle(/error|500|exception/i);
    });

    test('should handle null byte injection', async ({ page }) => {
      await page.goto('/collections/all?file=test%00.txt');

      // Page should handle gracefully
      await expect(page).not.toHaveTitle(/error/i);
    });

    test('should handle Unicode attacks', async ({ page }) => {
      await page.goto('/collections/all?q=%E2%80%AEtset');

      // Page should render safely
      await expect(page).not.toHaveTitle(/error/i);
    });
  });

  test.describe('Session Security', () => {

    test('should not expose session tokens in URLs', async ({ page }) => {
      await page.goto('/collections/all');

      // Navigate around
      await page.locator('[href="/cart"]').first().click();
      await page.waitForURL(/.*\/cart.*/);

      // Check URL doesn't contain session tokens
      const url = page.url();
      expect(url).not.toMatch(/session[_-]?id=/i);
      expect(url).not.toMatch(/token=/i);
      expect(url).not.toMatch(/PHPSESSID=/i);
    });

    test('should maintain session across navigation', async ({ page }) => {
      await page.goto('/collections/all');

      const initialCookies = await page.context().cookies();
      const sessionCookie = initialCookies.find(c => c.name.includes('session') || c.name.includes('_shopify'));

      // Navigate to another page
      await page.goto('/cart');

      const afterCookies = await page.context().cookies();
      const afterSessionCookie = afterCookies.find(c => c.name === sessionCookie?.name);

      // Session should persist
      if (sessionCookie && afterSessionCookie) {
        expect(afterSessionCookie.value).toBeTruthy();
      }
    });
  });

  test.describe('Error Handling', () => {

    test('should not expose stack traces on 404', async ({ page }) => {
      const response = await page.goto('/collections/nonexistent-xyz-404');

      const content = await page.content();

      // Should not expose technical details
      expect(content).not.toMatch(/stack trace/i);
      expect(content).not.toMatch(/exception/i);
      expect(content).not.toMatch(/\.rb:\d+/); // Ruby stack traces
    });

    test('should not expose server information', async ({ page }) => {
      const response = await page.goto('/collections/all');
      const headers = response?.headers();

      // Server header should not expose version details
      const serverHeader = headers?.['server'];
      if (serverHeader) {
        expect(serverHeader).not.toMatch(/nginx\/\d/i);
        expect(serverHeader).not.toMatch(/apache\/\d/i);
      }
    });

    test('should handle malformed requests gracefully', async ({ page }) => {
      const response = await page.goto('/collections/all?%invalid');

      // Should not crash
      expect(response?.status()).toBeLessThan(500);
    });
  });

  test.describe('Content Security', () => {

    test('should load resources from allowed origins', async ({ page }) => {
      const resourceOrigins: string[] = [];

      page.on('request', request => {
        const url = new URL(request.url());
        resourceOrigins.push(url.origin);
      });

      await page.goto('/collections/all');
      await page.waitForLoadState('networkidle');

      // All resources should be from known origins
      const allowedOrigins = [
        'https://sauce-demo.myshopify.com',
        'https://cdn.shopify.com',
        'https://www.facebook.com',
        'https://connect.facebook.net',
        'https://d.adroll.com',
        'https://www.googletagmanager.com',
        'https://hcaptcha.com',
        'https://fonts.googleapis.com',
        'https://fonts.gstatic.com',
      ];

      // Just verify no unknown suspicious origins
      resourceOrigins.forEach(origin => {
        expect(origin).not.toMatch(/^http:\/\/localhost/);
        expect(origin).not.toMatch(/^http:\/\/127\./);
      });
    });
  });

  test.describe('PII Protection', () => {

    test('should not expose customer data in page source', async ({ page }) => {
      await page.goto('/collections/all');

      const content = await page.content();

      // Should not contain sensitive patterns
      const emailPattern = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
      const emails = content.match(emailPattern) || [];

      // Filter out legitimate emails
      const sensitiveEmails = emails.filter(email =>
        !email.includes('support') &&
        !email.includes('example') &&
        !email.includes('shopify') &&
        !email.includes('test')
      );

      expect(sensitiveEmails.length).toBe(0);
    });

    test('should not expose customer data in JavaScript', async ({ page }) => {
      await page.goto('/collections/all');

      const exposedData = await page.evaluate(() => {
        const sensitiveKeys = ['email', 'password', 'credit_card', 'ssn', 'phone'];
        const exposed: string[] = [];

        // Check window.Shopify
        const shopify = (window as any).Shopify;
        if (shopify?.customer?.email) {
          exposed.push('Shopify.customer.email');
        }

        return exposed;
      });

      // Guest session should not have customer data
      expect(exposedData.length).toBe(0);
    });
  });
});

import { test, expect } from '@playwright/test';
import { HomePage, ProductPage, CartPage } from '../pages';

/**
 * Accessibility E2E Tests
 * Test Suite: WCAG 2.1 Compliance Checks
 *
 * QE Assessment: sauce-demo.myshopify.com
 * Generated by: QE Queen Coordinator - qe-accessibility domain
 *
 * Coverage:
 * - Keyboard navigation
 * - Screen reader compatibility
 * - Color contrast (manual verification needed)
 * - ARIA attributes
 * - Focus management
 * - Form accessibility
 */

test.describe('Accessibility Tests - WCAG 2.1 Compliance', () => {
  test.describe('Keyboard Navigation', () => {
    test('should allow navigation via keyboard only', async ({ page }) => {
      await page.goto('/');

      // Tab through the page
      for (let i = 0; i < 10; i++) {
        await page.keyboard.press('Tab');
      }

      // Should have a focused element
      const focusedElement = await page.evaluate(() => document.activeElement?.tagName);
      expect(focusedElement).toBeTruthy();
    });

    test('should have visible focus indicators', async ({ page }) => {
      await page.goto('/');

      // Tab to first focusable element
      await page.keyboard.press('Tab');

      // Check focus is visible (element has outline or box-shadow)
      const hasFocusStyle = await page.evaluate(() => {
        const el = document.activeElement;
        if (!el) return false;

        const style = window.getComputedStyle(el);
        return (
          style.outline !== 'none' ||
          style.outlineWidth !== '0px' ||
          style.boxShadow !== 'none'
        );
      });

      expect(hasFocusStyle).toBe(true);
    });

    test('should allow Enter key to activate links', async ({ page }) => {
      const homePage = new HomePage(page);
      await homePage.goto();

      // Tab to first product link
      const productLink = page.locator('[class*="product"] a, .grid-product a').first();
      await productLink.focus();
      await page.keyboard.press('Enter');

      // Should navigate to product page
      await expect(page).toHaveURL(/.*\/products\/.*/);
    });

    test('should allow keyboard-only cart interaction', async ({ page }) => {
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.assertProductPageLoaded();

      // Focus on add to cart and press Enter
      await productPage.addToCartButton.focus();
      await page.keyboard.press('Enter');

      // Wait for cart update
      await page.waitForTimeout(1000);

      const cartCount = await productPage.getCartCount();
      expect(cartCount).toBeGreaterThan(0);
    });
  });

  test.describe('ARIA Attributes', () => {
    test('should have proper ARIA roles on navigation', async ({ page }) => {
      await page.goto('/');

      // Check for navigation role
      const navWithRole = await page.locator('nav, [role="navigation"]').count();
      expect(navWithRole).toBeGreaterThan(0);
    });

    test('should have ARIA labels on icon buttons', async ({ page }) => {
      await page.goto('/');

      // Check cart icon has accessible label
      const cartButton = page.locator('[href="/cart"], .cart-link, .site-header__cart');

      const hasAriaLabel = await cartButton.first().evaluate(el => {
        return (
          el.getAttribute('aria-label') ||
          el.getAttribute('title') ||
          el.textContent?.trim()
        );
      });

      expect(hasAriaLabel).toBeTruthy();
    });

    test('should have proper button roles', async ({ page }) => {
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.assertProductPageLoaded();

      // Add to cart should be a button
      const addToCartRole = await productPage.addToCartButton.evaluate(el => {
        return el.tagName.toLowerCase() === 'button' || el.getAttribute('role') === 'button';
      });

      expect(addToCartRole).toBe(true);
    });

    test('should announce dynamic content changes', async ({ page }) => {
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.addToCart();

      // Check for live region or status updates
      const liveRegions = await page.locator('[aria-live], [role="status"], [role="alert"]').count();

      // Should have some live region for cart updates
      expect(liveRegions).toBeGreaterThanOrEqual(0); // Informational
    });
  });

  test.describe('Form Accessibility', () => {
    test('should have labels for all form inputs', async ({ page }) => {
      await page.goto('/search');

      const searchInput = page.locator('input[type="search"], input[name="q"]');

      // Check for associated label or aria-label
      const hasLabel = await searchInput.first().evaluate(el => {
        const id = el.id;
        const ariaLabel = el.getAttribute('aria-label');
        const ariaLabelledBy = el.getAttribute('aria-labelledby');
        const placeholder = el.getAttribute('placeholder');
        const label = id ? document.querySelector(`label[for="${id}"]`) : null;

        return !!(ariaLabel || ariaLabelledBy || label || placeholder);
      });

      expect(hasLabel).toBe(true);
    });

    test('should have accessible error messages', async ({ page }) => {
      // Navigate to checkout with item
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.addToCart();

      const cartPage = new CartPage(page);
      await cartPage.goto();
      await cartPage.proceedToCheckout();

      // Wait for checkout
      await page.waitForURL(/.*checkout.*/, { timeout: 30000 });

      // Try to submit without filling required fields
      const continueButton = page.locator('#continue_button, button:has-text("Continue")');
      await continueButton.click().catch(() => {});

      // Error messages should be accessible
      await page.waitForTimeout(500);

      // Check for error elements
      const errors = page.locator('.field__message--error, [role="alert"], .error-message');
      const errorCount = await errors.count();

      if (errorCount > 0) {
        // Errors should have proper role
        const firstError = errors.first();
        const isAccessible = await firstError.evaluate(el => {
          return el.getAttribute('role') === 'alert' ||
                 el.closest('[aria-describedby]') !== null ||
                 el.getAttribute('aria-live') === 'polite';
        });
        expect(isAccessible).toBeDefined();
      }
    });

    test('should maintain focus on form errors', async ({ page }) => {
      // Navigate to login page
      await page.goto('/account/login');

      // Submit empty form
      const submitButton = page.locator('button[type="submit"], input[type="submit"]').first();
      await submitButton.click();

      // Focus should be on error or first invalid field
      await page.waitForTimeout(500);

      const activeElement = await page.evaluate(() => document.activeElement?.tagName);
      expect(activeElement).toBeTruthy();
    });
  });

  test.describe('Image Accessibility', () => {
    test('should have alt text for product images', async ({ page }) => {
      const homePage = new HomePage(page);
      await homePage.goto();

      const images = page.locator('[class*="product"] img, .grid-product img');
      const imageCount = await images.count();

      for (let i = 0; i < Math.min(imageCount, 5); i++) {
        const img = images.nth(i);
        const alt = await img.getAttribute('alt');

        // Alt should exist (can be empty for decorative images)
        expect(alt).toBeDefined();
      }
    });

    test('should have meaningful alt text (not just filenames)', async ({ page }) => {
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.assertProductPageLoaded();

      const mainImage = productPage.mainImage;
      const alt = await mainImage.getAttribute('alt');

      // Alt should not be a filename
      if (alt) {
        expect(alt).not.toMatch(/\.(jpg|jpeg|png|gif|webp)$/i);
        expect(alt).not.toMatch(/^img_\d+$/i);
        expect(alt).not.toMatch(/^image\d*$/i);
      }
    });
  });

  test.describe('Page Structure', () => {
    test('should have exactly one h1 per page', async ({ page }) => {
      await page.goto('/');

      const h1Count = await page.locator('h1').count();
      expect(h1Count).toBe(1);
    });

    test('should have logical heading hierarchy', async ({ page }) => {
      await page.goto('/');

      const headings = await page.evaluate(() => {
        const headers = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
        return Array.from(headers).map(h => parseInt(h.tagName[1]));
      });

      // Check heading levels don't skip (e.g., h1 -> h3 without h2)
      for (let i = 1; i < headings.length; i++) {
        const diff = headings[i] - headings[i - 1];
        // Allow same level or going deeper by 1, or going up any amount
        expect(diff).toBeLessThanOrEqual(1);
      }
    });

    test('should have main landmark', async ({ page }) => {
      await page.goto('/');

      const mainLandmark = await page.locator('main, [role="main"]').count();
      expect(mainLandmark).toBeGreaterThanOrEqual(1);
    });

    test('should have skip link or bypass block', async ({ page }) => {
      await page.goto('/');

      // Check for skip link (may be visually hidden)
      const skipLink = page.locator('a[href="#main"], a[href="#content"], a:has-text("Skip")');
      const skipLinkCount = await skipLink.count();

      // Skip links are recommended but not always present
      expect(skipLinkCount).toBeGreaterThanOrEqual(0); // Informational
    });
  });

  test.describe('Color and Contrast', () => {
    test('should not rely solely on color for information', async ({ page }) => {
      const productPage = new ProductPage(page);
      await page.goto('/collections/frontpage');
      await page.locator('[class*="product"] a, .grid-product a').first().click();
      await productPage.assertProductPageLoaded();

      // Check that links have underline or other non-color indicator
      const links = page.locator('a');
      const firstLink = links.first();

      const hasNonColorIndicator = await firstLink.evaluate(el => {
        const style = window.getComputedStyle(el);
        return (
          style.textDecoration.includes('underline') ||
          style.fontWeight === 'bold' ||
          style.fontWeight === '700'
        );
      });

      // Links should have some visual distinction beyond color
      expect(hasNonColorIndicator).toBeDefined();
    });
  });

  test.describe('Motion and Animation', () => {
    test('should respect prefers-reduced-motion', async ({ page }) => {
      // Enable reduced motion preference
      await page.emulateMedia({ reducedMotion: 'reduce' });
      await page.goto('/');

      // Page should still function
      const homePage = new HomePage(page);
      await homePage.assertHomePageLoaded();
    });
  });

  test.describe('Responsive Accessibility', () => {
    test('should maintain accessibility on mobile viewport', async ({ page }) => {
      await page.setViewportSize({ width: 375, height: 667 });
      await page.goto('/');

      // Check navigation is still accessible (may be in hamburger menu)
      const menuButton = page.locator('[data-drawer-toggle], .menu-toggle, .hamburger, [aria-expanded]');
      const menuButtonCount = await menuButton.count();

      if (menuButtonCount > 0) {
        // Menu button should have accessible label
        const hasLabel = await menuButton.first().evaluate(el => {
          return el.getAttribute('aria-label') || el.getAttribute('title');
        });
        expect(hasLabel).toBeTruthy();
      }
    });
  });
});

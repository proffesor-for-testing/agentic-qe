/**
 * GOAP Plan Executor
 *
 * Executes remediation plans generated by GOAPQualityGateIntegration:
 * - Spawns agents for each action
 * - Executes actions in sequence with dependency ordering
 * - Records outcomes for learning (wires recordActionOutcome)
 * - Handles failures with automatic replanning
 *
 * @module planning/execution/PlanExecutor
 * @version 1.0.0
 */

import Database from 'better-sqlite3';
import {
  GOAPQualityGateIntegration,
  RemediationPlan,
  RemediationAction,
  QualityGateContext,
  QualityGateMetrics,
  QUALITY_GATE_GOALS
} from '../integration/GOAPQualityGateIntegration';
import { Logger } from '../../utils/Logger';

// Lazy import to avoid circular dependencies and reduce memory in tests
let AgentRegistryModule: typeof import('../../mcp/services/AgentRegistry') | null = null;
async function getAgentRegistryModule() {
  if (!AgentRegistryModule) {
    AgentRegistryModule = await import('../../mcp/services/AgentRegistry');
  }
  return AgentRegistryModule;
}

/**
 * Result of executing a single action
 */
export interface ActionExecutionResult {
  actionId: string;
  actionName: string;
  success: boolean;
  durationMs: number;
  error?: string;
  agentId?: string;
  output?: any;
}

/**
 * Result of executing a full plan
 */
export interface PlanExecutionResult {
  planId: string;
  success: boolean;
  totalDurationMs: number;
  actionsExecuted: number;
  actionsSucceeded: number;
  actionsFailed: number;
  actionResults: ActionExecutionResult[];
  replanned: boolean;
  alternativePlanUsed?: string;
  error?: string;
}

/**
 * Configuration for plan execution
 */
export interface PlanExecutionConfig {
  /** Maximum retries per action (default: 1) */
  maxRetries?: number;
  /** Timeout per action in ms (default: 300000 = 5 min) */
  actionTimeoutMs?: number;
  /** Whether to continue on action failure (default: false - triggers replanning) */
  continueOnFailure?: boolean;
  /** Maximum replan attempts (default: 2) */
  maxReplanAttempts?: number;
  /** Dry run - don't actually execute, just validate (default: false) */
  dryRun?: boolean;
}

const DEFAULT_CONFIG: Required<PlanExecutionConfig> = {
  maxRetries: 1,
  actionTimeoutMs: 300000,
  continueOnFailure: false,
  maxReplanAttempts: 2,
  dryRun: false
};

/**
 * GOAP Plan Executor
 *
 * Bridges plan generation with actual agent execution.
 * Implements the OODA (Observe-Orient-Decide-Act) loop for plan execution.
 */
export class PlanExecutor {
  private registry: any | null = null; // AgentRegistry - lazily initialized
  private integration: GOAPQualityGateIntegration;
  private db: Database.Database;
  private logger: Logger;
  private config: Required<PlanExecutionConfig>;
  private ownsRegistry = false; // Track if we created the registry

  constructor(
    db: Database.Database,
    integration: GOAPQualityGateIntegration,
    config: PlanExecutionConfig = {}
  ) {
    this.db = db;
    this.integration = integration;
    this.logger = Logger.getInstance();
    this.config = { ...DEFAULT_CONFIG, ...config };
    // Registry is lazily initialized only when needed (not in dry-run mode)
  }

  /**
   * Initialize registry only when needed for actual execution
   */
  private async ensureRegistry(): Promise<any> {
    if (!this.registry) {
      const { getAgentRegistry } = await getAgentRegistryModule();
      this.registry = getAgentRegistry();
      this.ownsRegistry = true;
    }
    return this.registry;
  }

  /**
   * Cleanup resources - call this when done with the executor
   */
  async cleanup(): Promise<void> {
    // Don't cleanup singleton registry - it's shared
    this.registry = null;
    this.ownsRegistry = false;
  }

  /**
   * Execute a remediation plan
   *
   * @param plan - The remediation plan to execute
   * @param context - Quality gate context for replanning
   * @param metrics - Current metrics for replanning
   */
  async executePlan(
    plan: RemediationPlan,
    context: QualityGateContext,
    metrics: QualityGateMetrics
  ): Promise<PlanExecutionResult> {
    const startTime = Date.now();
    const result: PlanExecutionResult = {
      planId: plan.planId,
      success: false,
      totalDurationMs: 0,
      actionsExecuted: 0,
      actionsSucceeded: 0,
      actionsFailed: 0,
      actionResults: [],
      replanned: false
    };

    this.logger.info('[PlanExecutor] Starting plan execution', {
      planId: plan.planId,
      actionCount: plan.actions.length,
      dryRun: this.config.dryRun
    });

    // Update plan status to 'executing'
    await this.updatePlanStatus(plan.planId, 'executing');

    let replanAttempts = 0;
    let currentPlan = plan;

    while (replanAttempts <= this.config.maxReplanAttempts) {
      try {
        // Execute each action in sequence
        for (const action of currentPlan.actions) {
          const actionResult = await this.executeAction(action, context);
          result.actionResults.push(actionResult);
          result.actionsExecuted++;

          if (actionResult.success) {
            result.actionsSucceeded++;
            // Record success for learning
            await this.integration.recordActionOutcome(action.id, true);
          } else {
            result.actionsFailed++;
            // Record failure for learning
            await this.integration.recordActionOutcome(action.id, false);

            if (!this.config.continueOnFailure) {
              this.logger.warn('[PlanExecutor] Action failed, attempting replan', {
                actionId: action.id,
                actionName: action.name,
                error: actionResult.error
              });

              // Try to replan
              replanAttempts++;
              if (replanAttempts > this.config.maxReplanAttempts) {
                result.error = `Max replan attempts (${this.config.maxReplanAttempts}) exceeded. Last error: ${actionResult.error}`;
                break;
              }

              // Try alternative path first
              if (currentPlan.alternativePaths.length > 0) {
                const altPath = currentPlan.alternativePaths[0];
                this.logger.info('[PlanExecutor] Using alternative path', {
                  alternativePlanId: altPath.planId,
                  difference: altPath.differenceFromPrimary
                });

                // Generate new plan from alternative
                const newPlan = await this.integration.generateRemediationPlan(
                  metrics,
                  context
                );

                if (newPlan) {
                  currentPlan = newPlan;
                  result.replanned = true;
                  result.alternativePlanUsed = altPath.planId;
                  continue; // Restart with new plan
                }
              }

              // Full replan if no alternatives
              const newPlan = await this.integration.generateRemediationPlan(
                metrics,
                context
              );

              if (newPlan) {
                currentPlan = newPlan;
                result.replanned = true;
                this.logger.info('[PlanExecutor] Replanned with new strategy', {
                  newPlanId: newPlan.planId
                });
                continue;
              }

              result.error = `Replanning failed after action ${action.id}`;
              break;
            }
          }
        }

        // If we get here without breaking, we succeeded
        if (!result.error) {
          result.success = result.actionsFailed === 0;
        }
        break;

      } catch (error) {
        result.error = error instanceof Error ? error.message : String(error);
        this.logger.error('[PlanExecutor] Plan execution failed', { error: result.error });
        break;
      }
    }

    result.totalDurationMs = Date.now() - startTime;

    // Update plan status
    await this.updatePlanStatus(
      plan.planId,
      result.success ? 'completed' : 'failed',
      result.success,
      result.error
    );

    // Mark plan as completed via integration
    await this.integration.completePlan(plan.planId, result.success, result.error);

    this.logger.info('[PlanExecutor] Plan execution completed', {
      planId: plan.planId,
      success: result.success,
      duration: `${result.totalDurationMs}ms`,
      actionsExecuted: result.actionsExecuted,
      actionsSucceeded: result.actionsSucceeded,
      actionsFailed: result.actionsFailed,
      replanned: result.replanned
    });

    return result;
  }

  /**
   * Execute a single remediation action
   */
  private async executeAction(
    action: RemediationAction,
    context: QualityGateContext
  ): Promise<ActionExecutionResult> {
    const startTime = Date.now();
    const result: ActionExecutionResult = {
      actionId: action.id,
      actionName: action.name,
      success: false,
      durationMs: 0
    };

    if (this.config.dryRun) {
      this.logger.info('[PlanExecutor] DRY RUN - Would execute action', {
        actionId: action.id,
        actionName: action.name,
        agentType: action.agentType
      });
      result.success = true;
      result.durationMs = Date.now() - startTime;
      return result;
    }

    this.logger.info('[PlanExecutor] Executing action', {
      actionId: action.id,
      actionName: action.name,
      agentType: action.agentType
    });

    try {
      // Get registry only when actually executing (not in dry-run)
      const registry = await this.ensureRegistry();

      // Map GOAP agent type to MCP agent type
      const mcpAgentType = this.mapAgentType(action.agentType);

      // Spawn or get an agent of the required type
      const { id: agentId } = await registry.spawnAgent(mcpAgentType, {
        name: `${mcpAgentType}-${action.id}`,
        description: `Spawned for action: ${action.name}`,
        capabilities: this.getCapabilitiesForAction(action)
      });

      result.agentId = agentId;

      // Create task from action
      const task = this.createTaskFromAction(action, context);

      // Execute with timeout
      const executePromise = registry.executeTask(agentId, task);
      const timeoutPromise = new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Action timeout')), this.config.actionTimeoutMs)
      );

      const output = await Promise.race([executePromise, timeoutPromise]);

      result.success = true;
      result.output = output;

      // Terminate the agent after use (cleanup)
      await registry.terminateAgent(agentId).catch((err: unknown) =>
        this.logger.warn('[PlanExecutor] Failed to terminate agent', { agentId, error: err })
      );

    } catch (error) {
      result.success = false;
      result.error = error instanceof Error ? error.message : String(error);
      this.logger.error('[PlanExecutor] Action execution failed', {
        actionId: action.id,
        error: result.error
      });
    }

    result.durationMs = Date.now() - startTime;
    return result;
  }

  /**
   * Map GOAP agent type to MCP agent type
   */
  private mapAgentType(goapAgentType: string): string {
    const mapping: Record<string, string> = {
      // QE agents
      'qe-test-generator': 'test-generator',
      'qe-test-executor': 'test-executor',
      'qe-coverage-analyzer': 'coverage-analyzer',
      'qe-quality-gate': 'quality-gate',
      'qe-performance-tester': 'performance-tester',
      'qe-security-scanner': 'security-scanner',
      'qe-flaky-test-hunter': 'flaky-test-detector',
      'qe-regression-risk-analyzer': 'regression-analyzer',
      'qe-requirements-validator': 'requirements-validator',
      'qe-fleet-commander': 'fleet-commander',
      'qe-chaos-engineer': 'chaos-engineer',

      // Legacy/simple mappings
      'test-generator': 'test-generator',
      'test-executor': 'test-executor',
      'coverage-analyzer': 'coverage-analyzer',
      'quality-gate': 'quality-gate',
      'performance-tester': 'performance-tester',
      'security-scanner': 'security-scanner'
    };

    return mapping[goapAgentType] || 'quality-gate';
  }

  /**
   * Get capabilities for an action
   */
  private getCapabilitiesForAction(action: RemediationAction): string[] {
    const categoryCapabilities: Record<string, string[]> = {
      test: ['test-execution', 'test-validation'],
      coverage: ['coverage-analysis', 'gap-detection'],
      security: ['vulnerability-scanning', 'security-testing'],
      performance: ['load-testing', 'performance-analysis'],
      analysis: ['code-analysis', 'impact-analysis'],
      process: ['decision-making', 'workflow-management'],
      fleet: ['agent-coordination', 'resource-management']
    };

    return categoryCapabilities[action.category] || ['generic-execution'];
  }

  /**
   * Create a task from a remediation action
   */
  private createTaskFromAction(action: RemediationAction, context: QualityGateContext): any {
    return {
      id: `task-${action.id}-${Date.now()}`,
      type: action.category,
      payload: {
        actionId: action.id,
        actionName: action.name,
        description: action.description,
        effects: action.effects,
        projectId: context.projectId,
        buildId: context.buildId,
        environment: context.environment
      },
      priority: context.criticality === 'critical' ? 1 : context.criticality === 'high' ? 3 : 5,
      description: action.description || action.name,
      context: {
        source: 'goap-remediation',
        planAction: action.id
      }
    };
  }

  /**
   * Update plan status in database
   */
  private async updatePlanStatus(
    planId: string,
    status: 'pending' | 'executing' | 'completed' | 'failed',
    success?: boolean,
    failureReason?: string
  ): Promise<void> {
    try {
      if (status === 'executing') {
        this.db.prepare(`
          UPDATE goap_plans SET status = ?, started_at = CURRENT_TIMESTAMP WHERE id = ?
        `).run(status, planId);
      } else {
        this.db.prepare(`
          UPDATE goap_plans
          SET status = ?, success = ?, failure_reason = ?, completed_at = CURRENT_TIMESTAMP
          WHERE id = ?
        `).run(status, success ? 1 : 0, failureReason || null, planId);
      }
    } catch (error) {
      this.logger.warn('[PlanExecutor] Failed to update plan status', { planId, error });
    }
  }
}

/**
 * Factory function to create a PlanExecutor
 */
export function createPlanExecutor(
  dbPath: string,
  config: PlanExecutionConfig = {}
): { executor: PlanExecutor; integration: GOAPQualityGateIntegration } {
  const Database = require('better-sqlite3');
  const db = new Database(dbPath);
  const integration = new GOAPQualityGateIntegration(db);

  return {
    executor: new PlanExecutor(db, integration, config),
    integration
  };
}

/**
 * Execute a quality gate remediation with GOAP planning
 *
 * High-level function that:
 * 1. Generates a remediation plan
 * 2. Executes the plan
 * 3. Records outcomes for learning
 */
export async function executeQualityGateRemediation(
  metrics: QualityGateMetrics,
  context: QualityGateContext,
  dbPath: string,
  targetGoal?: keyof typeof QUALITY_GATE_GOALS,
  config: PlanExecutionConfig = {}
): Promise<PlanExecutionResult | null> {
  const { executor, integration } = createPlanExecutor(dbPath, config);

  try {
    await integration.initialize();

    // Generate remediation plan
    const plan = await integration.generateRemediationPlan(metrics, context, targetGoal);

    if (!plan) {
      Logger.getInstance().info('[executeQualityGateRemediation] No remediation needed - goal already satisfied');
      return null;
    }

    // Execute the plan
    return await executor.executePlan(plan, context, metrics);
  } finally {
    integration.close();
  }
}

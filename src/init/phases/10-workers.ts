/**
 * Phase 10: Workers
 * Configures background workers for continuous monitoring
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import { spawn } from 'child_process';

import {
  BasePhase,
  type InitContext,
} from './phase-interface.js';
import type { AQEInitConfig } from '../types.js';

interface WorkerRegistration {
  name: string;
  enabled: boolean;
  interval: number;
  lastRun: string | null;
  status: 'pending' | 'running' | 'completed' | 'error';
}

export interface WorkersResult {
  workersDir: string;
  workersConfigured: number;
  registryPath: string;
  daemonStarted: boolean;
  daemonPid: number | null;
  daemonError?: string;
}

/**
 * Workers phase - configures background workers
 */
export class WorkersPhase extends BasePhase<WorkersResult> {
  readonly name = 'workers';
  readonly description = 'Configure background workers';
  readonly order = 100;
  readonly critical = false;
  readonly requiresPhases = ['configuration'] as const;

  async shouldRun(context: InitContext): Promise<boolean> {
    const config = context.config as AQEInitConfig;
    return config?.workers?.daemonAutoStart && (config?.workers?.enabled?.length ?? 0) > 0;
  }

  protected async run(context: InitContext): Promise<WorkersResult> {
    const config = context.config as AQEInitConfig;
    const { projectRoot } = context;

    if (!config.workers.daemonAutoStart || config.workers.enabled.length === 0) {
      return {
        workersDir: '',
        workersConfigured: 0,
        registryPath: '',
        daemonStarted: false,
        daemonPid: null,
      };
    }

    // Create workers directory
    const workersDir = join(projectRoot, '.agentic-qe', 'workers');
    if (!existsSync(workersDir)) {
      mkdirSync(workersDir, { recursive: true });
    }

    // Default intervals for all 11 workers (ADR-014)
    const defaultIntervals: Record<string, number> = {
      // Learning & Pattern Workers
      'learning-consolidation': 1800000, // 30 min - Pattern consolidation, dream cycles
      'pattern-consolidator': 1800000,   // Alias for learning-consolidation

      // Test Quality Workers
      'test-health': 300000,             // 5 min - Test suite health
      'coverage-tracker': 600000,        // 10 min - Coverage trends
      'coverage-gap-scanner': 600000,    // Alias for coverage-tracker
      'flaky-detector': 900000,          // 15 min - Flaky test detection
      'flaky-test-detector': 900000,     // Alias for flaky-detector

      // Security & Quality Workers
      'security-scan': 1800000,          // 30 min - Vulnerability scanning
      'quality-gate': 300000,            // 5 min - Gate evaluation
      'compliance-checker': 1800000,     // 30 min - ADR/DDD compliance

      // ML & Prediction Workers
      'defect-predictor': 900000,        // 15 min - ML defect prediction
      'regression-monitor': 600000,      // 10 min - Regression watching
      'routing-accuracy-monitor': 900000,// 15 min - Routing accuracy

      // Performance Workers
      'performance-baseline': 3600000,   // 1 hour - Performance tracking

      // Sync Workers
      'cloud-sync': 300000,              // 5 min - Cloud synchronization
    };

    // Build worker registry
    const workerRegistry: Record<string, WorkerRegistration> = {};

    for (const workerName of config.workers.enabled) {
      workerRegistry[workerName] = {
        name: workerName,
        enabled: true,
        interval: config.workers.intervals[workerName] || defaultIntervals[workerName] || 60000,
        lastRun: null,
        status: 'pending',
      };
    }

    // Write registry
    const registryPath = join(workersDir, 'registry.json');
    const registryData = {
      version: config.version,
      maxConcurrent: config.workers.maxConcurrent,
      workers: workerRegistry,
      createdAt: new Date().toISOString(),
      daemonPid: null,
    };
    writeFileSync(registryPath, JSON.stringify(registryData, null, 2), 'utf-8');

    // Write individual worker configs
    for (const workerName of config.workers.enabled) {
      const workerConfigPath = join(workersDir, `${workerName}.json`);
      const workerConfig = {
        name: workerName,
        enabled: true,
        interval: config.workers.intervals[workerName] || defaultIntervals[workerName] || 60000,
        projectRoot,
        dataDir: join(projectRoot, '.agentic-qe', 'data'),
        createdAt: new Date().toISOString(),
      };
      writeFileSync(workerConfigPath, JSON.stringify(workerConfig, null, 2), 'utf-8');
    }

    // Write cross-platform daemon startup script
    const daemonScriptPath = join(workersDir, 'start-daemon.cjs');
    const daemonScript = `#!/usr/bin/env node
// AQE v3 Worker Daemon Startup Script (cross-platform)
// Generated by aqe init
// Starts the MCP server with background workers enabled

const { existsSync, readFileSync, writeFileSync, appendFileSync } = require('fs');
const { join } = require('path');
const { spawn } = require('child_process');

const projectRoot = join(__dirname, '..', '..');
const workersDir = join(projectRoot, '.agentic-qe', 'workers');
const pidFile = join(workersDir, 'daemon.pid');
const logFile = join(workersDir, 'daemon.log');

// Check if already running
if (existsSync(pidFile)) {
  const pid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);
  try { process.kill(pid, 0); console.log('Daemon already running (PID: ' + pid + ')'); process.exit(0); } catch {}
}

const ts = new Date().toISOString();
appendFileSync(logFile, '[' + ts + '] Starting AQE v3 Worker Daemon...\\n');

// Find the best way to run aqe-mcp
const candidates = [
  join(projectRoot, 'node_modules', '.bin', 'aqe-mcp'),
  join(projectRoot, 'node_modules', 'agentic-qe', 'v3', 'dist', 'mcp', 'bundle.js'),
];

let mcpCmd, mcpArgs;
const binCandidate = candidates.find(c => existsSync(c));

if (binCandidate && binCandidate.endsWith('bundle.js')) {
  mcpCmd = process.execPath;
  mcpArgs = [binCandidate];
} else if (binCandidate) {
  mcpCmd = binCandidate;
  mcpArgs = [];
} else {
  mcpCmd = process.platform === 'win32' ? 'npx.cmd' : 'npx';
  mcpArgs = ['--yes', 'agentic-qe', 'mcp'];
}

appendFileSync(logFile, '[' + ts + '] Using: ' + mcpCmd + ' ' + mcpArgs.join(' ') + '\\n');

const env = { ...process.env, AQE_PROJECT_ROOT: projectRoot, AQE_LEARNING_ENABLED: 'true', AQE_WORKERS_ENABLED: 'true', AQE_HTTP_PORT: '0' };
const child = spawn(mcpCmd, mcpArgs, { cwd: projectRoot, env, detached: true, stdio: ['ignore', 'pipe', 'pipe'] });
child.stdout.on('data', d => appendFileSync(logFile, d));
child.stderr.on('data', d => appendFileSync(logFile, d));
child.unref();

writeFileSync(pidFile, String(child.pid));
appendFileSync(logFile, '[' + ts + '] Daemon started with PID: ' + child.pid + '\\n');
console.log('AQE v3 Worker Daemon started (PID: ' + child.pid + ')');
console.log('Log file: ' + logFile);
console.log('To stop: node ' + join(workersDir, 'stop-daemon.cjs'));
`;
    writeFileSync(daemonScriptPath, daemonScript);

    // Also write a cross-platform stop script
    const stopScriptPath = join(workersDir, 'stop-daemon.cjs');
    const stopScript = `#!/usr/bin/env node
// AQE v3 Worker Daemon Stop Script (cross-platform)
// Generated by aqe init

const { existsSync, readFileSync, unlinkSync } = require('fs');
const { join } = require('path');

const workersDir = join(__dirname);
const pidFile = join(workersDir, 'daemon.pid');

if (!existsSync(pidFile)) { console.log('No PID file found - daemon may not be running'); process.exit(0); }

const pid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);
try {
  process.kill(pid, 0); // Check if alive
  console.log('Stopping daemon (PID: ' + pid + ')...');
  process.kill(pid, 'SIGTERM');
  try { unlinkSync(pidFile); } catch {}
  console.log('Daemon stopped');
} catch {
  console.log('Daemon not running (stale PID file)');
  try { unlinkSync(pidFile); } catch {}
}
`;
    writeFileSync(stopScriptPath, stopScript);

    context.services.log(`  Workers dir: ${workersDir}`);
    context.services.log(`  Workers: ${config.workers.enabled.join(', ')}`);

    // Auto-start the MCP daemon if configured
    let daemonStarted = false;
    let daemonPid: number | null = null;
    let daemonError: string | undefined;

    if (config.workers.daemonAutoStart) {
      try {
        const result = await this.startDaemon(workersDir, projectRoot, context);
        daemonStarted = result.started;
        daemonPid = result.pid;
        daemonError = result.error;

        if (daemonStarted) {
          context.services.log(`  MCP daemon started (PID: ${daemonPid})`);
        } else if (daemonError) {
          // Non-blocking: MCP will be started by Claude Code via .mcp.json
          context.services.log(`  MCP daemon: skipped (will start via Claude Code)`);
          context.services.log(`    Note: ${daemonError}`);
        }
      } catch (error) {
        // Non-blocking error - MCP works fine when Claude Code starts it
        daemonError = error instanceof Error ? error.message : 'Unknown error';
        context.services.log(`  MCP daemon: skipped (Claude Code will start it)`);
      }
    }

    return {
      workersDir,
      workersConfigured: config.workers.enabled.length,
      registryPath,
      daemonStarted,
      daemonPid,
      daemonError,
    };
  }

  /**
   * Start the MCP daemon in the background
   */
  private async startDaemon(
    workersDir: string,
    projectRoot: string,
    context: InitContext
  ): Promise<{ started: boolean; pid: number | null; error?: string }> {
    const pidFile = join(workersDir, 'daemon.pid');
    const logFile = join(workersDir, 'daemon.log');

    // Check if already running
    if (existsSync(pidFile)) {
      try {
        const existingPid = parseInt(readFileSync(pidFile, 'utf-8').trim(), 10);
        // Check if process is running
        process.kill(existingPid, 0);
        return { started: true, pid: existingPid, error: 'Already running' };
      } catch {
        // PID file exists but process not running, continue
      }
    }

    // Try to find aqe-mcp command
    const mcpCommand = await this.findMcpCommand(projectRoot);
    if (!mcpCommand) {
      return {
        started: false,
        pid: null,
        error: 'aqe-mcp not found. Install globally with: npm install -g agentic-qe',
      };
    }

    return new Promise((resolve) => {
      try {
        // Set up environment
        const env = {
          ...process.env,
          AQE_PROJECT_ROOT: projectRoot,
          AQE_LEARNING_ENABLED: 'true',
          AQE_WORKERS_ENABLED: 'true',
          AQE_HTTP_PORT: '0',
        };

        // Spawn the MCP server as a detached process
        const child = spawn(mcpCommand.command, mcpCommand.args, {
          cwd: projectRoot,
          env,
          detached: true,
          stdio: ['ignore', 'pipe', 'pipe'],
        });

        // Give the process a moment to start
        let started = false;
        let errorOutput = '';

        child.stderr?.on('data', (data) => {
          errorOutput += data.toString();
        });

        child.on('error', (error) => {
          resolve({
            started: false,
            pid: null,
            error: error.message,
          });
        });

        // Wait a short time to see if the process starts successfully
        setTimeout(() => {
          // Check if process is still alive
          try {
            if (child.pid) {
              process.kill(child.pid, 0); // Check if alive (throws if not)

              // Write PID file
              writeFileSync(pidFile, child.pid.toString(), 'utf-8');

              // Log startup
              const logEntry = `[${new Date().toISOString()}] MCP daemon started with PID: ${child.pid}\n`;
              writeFileSync(logFile, logEntry, { flag: 'a' });

              // Unref so the parent can exit
              child.unref();

              resolve({
                started: true,
                pid: child.pid,
              });
            } else {
              resolve({
                started: false,
                pid: null,
                error: errorOutput || 'No PID assigned',
              });
            }
          } catch {
            // Process died - check error output
            const errMsg = errorOutput.includes('ERR_MODULE_NOT_FOUND')
              ? 'Missing dependencies. Run: npm install agentic-qe'
              : errorOutput || 'Process exited immediately';
            resolve({
              started: false,
              pid: null,
              error: errMsg,
            });
          }
        }, 1500);
      } catch (error) {
        resolve({
          started: false,
          pid: null,
          error: error instanceof Error ? error.message : 'Spawn failed',
        });
      }
    });
  }

  /**
   * Find the aqe-mcp command
   *
   * Search order:
   * 1. Local aqe-mcp binary (node_modules/.bin/)
   * 2. Local bundled MCP server (node_modules/agentic-qe/dist/)
   * 3. Local aqe CLI binary with mcp subcommand
   * 4. npx fallback (uses aqe mcp subcommand)
   */
  private async findMcpCommand(
    projectRoot: string
  ): Promise<{ command: string; args: string[] } | null> {
    // Try local node_modules aqe-mcp binary first
    const localMcpBin = join(projectRoot, 'node_modules', '.bin', 'aqe-mcp');
    if (existsSync(localMcpBin)) {
      return { command: localMcpBin, args: [] };
    }

    // Try local node_modules bundle (alternative path)
    const localBundle = join(projectRoot, 'node_modules', 'agentic-qe', 'v3', 'dist', 'mcp', 'bundle.js');
    if (existsSync(localBundle)) {
      return { command: 'node', args: [localBundle] };
    }

    // Try local aqe CLI binary with mcp subcommand
    const localAqeBin = join(projectRoot, 'node_modules', '.bin', 'aqe');
    if (existsSync(localAqeBin)) {
      return { command: localAqeBin, args: ['mcp'] };
    }

    // Fallback to npx with aqe mcp subcommand
    // The CLI now has an 'mcp' command that starts the MCP server
    return { command: 'npx', args: ['--yes', 'agentic-qe', 'mcp'] };
  }
}

// Instance exported from index.ts

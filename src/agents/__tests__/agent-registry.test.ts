import { DefaultAgentRegistry } from '../agent-registry';\nimport { AgentInstance } from '../../types/agent';\n\ndescribe('DefaultAgentRegistry', () => {\n  let registry: DefaultAgentRegistry;\n  let mockAgents: AgentInstance[];\n\n  beforeEach(() => {\n    registry = new DefaultAgentRegistry();\n    mockAgents = [\n      createMockAgent('agent-1', 'testing', ['boundary_testing', 'test_generation']),\n      createMockAgent('agent-2', 'security', ['security_testing', 'vulnerability_assessment']),\n      createMockAgent('agent-3', 'performance', ['performance_testing', 'load_testing']),\n      createMockAgent('agent-4', 'testing', ['api_testing', 'integration_testing'])\n    ];\n  });\n\n  function createMockAgent(name: string, type: string, capabilities: string[]): AgentInstance {\n    return {\n      id: `${name}-id`,\n      name,\n      type,\n      capabilities,\n      tools: new Map(),\n      state: 'initialized',\n      parameters: {},\n      metadata: { created_at: new Date().toISOString() },\n      definition: {} as any,\n      initialize: jest.fn(),\n      execute: jest.fn(),\n      setState: jest.fn(),\n      getCapabilities: () => [...capabilities],\n      getTool: jest.fn(),\n      destroy: jest.fn()\n    };\n  }\n\n  describe('Agent Registration', () => {\n    it('should register agents successfully', () => {\n      const agent = mockAgents[0];\n      registry.register(agent);\n      \n      expect(registry.get(agent.id)).toBe(agent);\n      expect(registry.getByName(agent.name)).toBe(agent);\n    });\n\n    it('should prevent duplicate registration', () => {\n      const agent = mockAgents[0];\n      registry.register(agent);\n      registry.register(agent); // Should not throw, but warn\n      \n      expect(registry.list()).toHaveLength(1);\n    });\n\n    it('should handle name conflicts gracefully', () => {\n      const agent1 = mockAgents[0];\n      const agent2 = { ...mockAgents[1], name: agent1.name }; // Same name, different ID\n      \n      registry.register(agent1);\n      registry.register(agent2);\n      \n      expect(registry.list()).toHaveLength(2);\n      expect(registry.getByName(agent1.name)).toBe(agent2); // Latest registration wins\n    });\n\n    it('should build capability index', () => {\n      registry.register(mockAgents[0]); // has 'boundary_testing'\n      registry.register(mockAgents[1]); // has 'security_testing'\n      \n      const boundaryAgents = registry.getByCapability('boundary_testing');\n      const securityAgents = registry.getByCapability('security_testing');\n      \n      expect(boundaryAgents).toHaveLength(1);\n      expect(boundaryAgents[0].name).toBe('agent-1');\n      expect(securityAgents).toHaveLength(1);\n      expect(securityAgents[0].name).toBe('agent-2');\n    });\n\n    it('should build category index', () => {\n      registry.register(mockAgents[0]); // type: 'testing'\n      registry.register(mockAgents[1]); // type: 'security'\n      registry.register(mockAgents[3]); // type: 'testing'\n      \n      const testingAgents = registry.getByCategory('testing');\n      const securityAgents = registry.getByCategory('security');\n      \n      expect(testingAgents).toHaveLength(2);\n      expect(securityAgents).toHaveLength(1);\n    });\n  });\n\n  describe('Agent Unregistration', () => {\n    beforeEach(() => {\n      mockAgents.forEach(agent => registry.register(agent));\n    });\n\n    it('should unregister agents successfully', () => {\n      const agent = mockAgents[0];\n      registry.unregister(agent.id);\n      \n      expect(registry.get(agent.id)).toBeUndefined();\n      expect(registry.getByName(agent.name)).toBeUndefined();\n    });\n\n    it('should clean up capability index', () => {\n      const agent = mockAgents[0]; // has 'boundary_testing'\n      registry.unregister(agent.id);\n      \n      const boundaryAgents = registry.getByCapability('boundary_testing');\n      expect(boundaryAgents).toHaveLength(0);\n    });\n\n    it('should clean up category index', () => {\n      const testingAgents = registry.getByCategory('testing');\n      expect(testingAgents).toHaveLength(2); // agents 0 and 3\n      \n      registry.unregister(mockAgents[0].id);\n      const remainingTestingAgents = registry.getByCategory('testing');\n      expect(remainingTestingAgents).toHaveLength(1);\n    });\n\n    it('should handle unregistration of non-existent agent', () => {\n      expect(() => {\n        registry.unregister('non-existent-id');\n      }).not.toThrow();\n    });\n  });\n\n  describe('Agent Retrieval', () => {\n    beforeEach(() => {\n      mockAgents.forEach(agent => registry.register(agent));\n    });\n\n    it('should get agent by ID', () => {\n      const agent = mockAgents[0];\n      expect(registry.get(agent.id)).toBe(agent);\n    });\n\n    it('should get agent by name', () => {\n      const agent = mockAgents[0];\n      expect(registry.getByName(agent.name)).toBe(agent);\n    });\n\n    it('should get agents by capability', () => {\n      const testingAgents = registry.getByCapability('boundary_testing');\n      expect(testingAgents).toHaveLength(1);\n      expect(testingAgents[0].name).toBe('agent-1');\n    });\n\n    it('should get agents by category', () => {\n      const testingAgents = registry.getByCategory('testing');\n      expect(testingAgents).toHaveLength(2);\n      expect(testingAgents.map(a => a.name)).toEqual(expect.arrayContaining(['agent-1', 'agent-4']));\n    });\n\n    it('should list all agents', () => {\n      const allAgents = registry.list();\n      expect(allAgents).toHaveLength(mockAgents.length);\n    });\n\n    it('should return empty arrays for non-existent queries', () => {\n      expect(registry.getByCapability('non_existent')).toEqual([]);\n      expect(registry.getByCategory('non_existent')).toEqual([]);\n    });\n  });\n\n  describe('Advanced Search Features', () => {\n    beforeEach(() => {\n      mockAgents.forEach(agent => registry.register(agent));\n    });\n\n    it('should find agents by multiple capabilities (ANY match)', () => {\n      const agents = registry.findByCapabilities(['boundary_testing', 'security_testing'], false);\n      \n      expect(agents).toHaveLength(2); // agent-1 and agent-2\n      expect(agents.map(a => a.name)).toEqual(expect.arrayContaining(['agent-1', 'agent-2']));\n    });\n\n    it('should find agents by multiple capabilities (ALL match)', () => {\n      // Add an agent with multiple matching capabilities\n      const multiCapAgent = createMockAgent('multi-cap', 'testing', ['boundary_testing', 'test_generation']);\n      registry.register(multiCapAgent);\n      \n      const agents = registry.findByCapabilities(['boundary_testing', 'test_generation'], true);\n      \n      expect(agents).toHaveLength(2); // agent-1 and multi-cap\n      expect(agents.every(a => \n        a.capabilities.includes('boundary_testing') && a.capabilities.includes('test_generation')\n      )).toBe(true);\n    });\n\n    it('should search agents by name pattern', () => {\n      const agents = registry.searchByName('agent-[12]');\n      \n      expect(agents).toHaveLength(2);\n      expect(agents.map(a => a.name)).toEqual(expect.arrayContaining(['agent-1', 'agent-2']));\n    });\n\n    it('should get agents by state', () => {\n      // Change state of one agent\n      const agent = mockAgents[0];\n      agent.state = 'working';\n      \n      const initializedAgents = registry.getByState('initialized');\n      const workingAgents = registry.getByState('working');\n      \n      expect(initializedAgents).toHaveLength(3);\n      expect(workingAgents).toHaveLength(1);\n      expect(workingAgents[0]).toBe(agent);\n    });\n\n    it('should check name availability', () => {\n      expect(registry.isNameAvailable('agent-1')).toBe(false);\n      expect(registry.isNameAvailable('new-agent')).toBe(true);\n    });\n  });\n\n  describe('Task Suggestion', () => {\n    beforeEach(() => {\n      mockAgents.forEach(agent => registry.register(agent));\n    });\n\n    it('should suggest agent for boundary testing task', () => {\n      const suggestedAgent = registry.suggestAgentForTask('Generate boundary test cases for API validation');\n      \n      expect(suggestedAgent).toBeDefined();\n      expect(suggestedAgent!.capabilities).toContain('boundary_testing');\n    });\n\n    it('should suggest agent for security testing task', () => {\n      const suggestedAgent = registry.suggestAgentForTask('Perform security vulnerability assessment');\n      \n      expect(suggestedAgent).toBeDefined();\n      expect(suggestedAgent!.capabilities.some(cap => cap.includes('security'))).toBe(true);\n    });\n\n    it('should return null for empty registry', () => {\n      const emptyRegistry = new DefaultAgentRegistry();\n      const suggestedAgent = emptyRegistry.suggestAgentForTask('Any task');\n      \n      expect(suggestedAgent).toBeNull();\n    });\n\n    it('should return agent even for unrelated tasks', () => {\n      const suggestedAgent = registry.suggestAgentForTask('Completely unrelated task with no keywords');\n      \n      // Should return some agent, even with low score\n      expect(suggestedAgent).toBeDefined();\n    });\n  });\n\n  describe('Registry Management', () => {\n    beforeEach(() => {\n      mockAgents.forEach(agent => registry.register(agent));\n    });\n\n    it('should clear all agents', () => {\n      registry.clear();\n      \n      expect(registry.list()).toHaveLength(0);\n      expect(registry.getByCapability('boundary_testing')).toHaveLength(0);\n      expect(registry.getByCategory('testing')).toHaveLength(0);\n    });\n\n    it('should provide registry statistics', () => {\n      const stats = registry.getStats();\n      \n      expect(stats.totalAgents).toBe(4);\n      expect(stats.totalCapabilities).toBeGreaterThan(0);\n      expect(stats.totalCategories).toBe(3); // testing, security, performance\n      expect(stats.agentsByCategory.testing).toBe(2);\n      expect(stats.topCapabilities).toBeDefined();\n    });\n\n    it('should get all available capabilities', () => {\n      const capabilities = registry.getAllCapabilities();\n      \n      expect(capabilities).toContain('boundary_testing');\n      expect(capabilities).toContain('security_testing');\n      expect(capabilities).toContain('performance_testing');\n      expect(capabilities).toBeSorted();\n    });\n\n    it('should get all available categories', () => {\n      const categories = registry.getAllCategories();\n      \n      expect(categories).toContain('testing');\n      expect(categories).toContain('security');\n      expect(categories).toContain('performance');\n      expect(categories).toBeSorted();\n    });\n  });\n\n  describe('Data Export', () => {\n    beforeEach(() => {\n      mockAgents.forEach(agent => registry.register(agent));\n    });\n\n    it('should export registry data', () => {\n      const exportData = registry.export();\n      \n      expect(exportData.agents).toHaveLength(4);\n      expect(exportData.timestamp).toBeDefined();\n      expect(exportData.agents[0]).toHaveProperty('id');\n      expect(exportData.agents[0]).toHaveProperty('name');\n      expect(exportData.agents[0]).toHaveProperty('capabilities');\n    });\n\n    it('should export minimal agent data', () => {\n      const exportData = registry.export();\n      const agent = exportData.agents[0];\n      \n      // Should not export complex objects like tools or definition\n      expect(agent).not.toHaveProperty('tools');\n      expect(agent).not.toHaveProperty('definition');\n      expect(agent).not.toHaveProperty('initialize');\n    });\n  });\n\n  describe('Health Monitoring', () => {\n    it('should report healthy status for good registry', () => {\n      mockAgents.forEach(agent => registry.register(agent));\n      \n      const health = registry.getHealthStatus();\n      \n      expect(health.healthy).toBe(true);\n      expect(health.totalAgents).toBe(4);\n      expect(health.initializedAgents).toBe(4);\n      expect(health.errorAgents).toBe(0);\n      expect(health.issues).toHaveLength(0);\n    });\n\n    it('should report unhealthy status for agents in error state', () => {\n      const errorAgent = { ...mockAgents[0], state: 'error' };\n      registry.register(errorAgent);\n      \n      const health = registry.getHealthStatus();\n      \n      expect(health.healthy).toBe(false);\n      expect(health.errorAgents).toBe(1);\n      expect(health.issues).toContain('1 agents in error state');\n    });\n\n    it('should report issue when no agents are initialized', () => {\n      const uninitializedAgents = mockAgents.map(agent => ({ ...agent, state: 'created' }));\n      uninitializedAgents.forEach(agent => registry.register(agent));\n      \n      const health = registry.getHealthStatus();\n      \n      expect(health.healthy).toBe(false);\n      expect(health.initializedAgents).toBe(0);\n      expect(health.issues).toContain('No agents are properly initialized');\n    });\n\n    it('should report healthy status for empty registry', () => {\n      const health = registry.getHealthStatus();\n      \n      expect(health.healthy).toBe(true);\n      expect(health.totalAgents).toBe(0);\n      expect(health.issues).toHaveLength(0);\n    });\n  });\n\n  describe('Performance and Edge Cases', () => {\n    it('should handle large number of agents efficiently', () => {\n      const largeAgentSet = Array.from({ length: 1000 }, (_, i) => \n        createMockAgent(`agent-${i}`, `type-${i % 10}`, [`capability-${i % 20}`])\n      );\n      \n      const startTime = Date.now();\n      largeAgentSet.forEach(agent => registry.register(agent));\n      const registrationTime = Date.now() - startTime;\n      \n      expect(registrationTime).toBeLessThan(1000); // Should register 1000 agents in < 1 second\n      expect(registry.list()).toHaveLength(1000);\n      \n      // Test search performance\n      const searchStartTime = Date.now();\n      const foundAgents = registry.getByCapability('capability-0');\n      const searchTime = Date.now() - searchStartTime;\n      \n      expect(searchTime).toBeLessThan(100); // Should search in < 100ms\n      expect(foundAgents).toHaveLength(50); // Every 20th agent has this capability\n    });\n\n    it('should handle agents with no capabilities', () => {\n      const agent = createMockAgent('no-cap-agent', 'basic', []);\n      registry.register(agent);\n      \n      expect(registry.get(agent.id)).toBe(agent);\n      expect(registry.getAllCapabilities()).not.toContain('');\n    });\n\n    it('should handle agents with duplicate capabilities', () => {\n      const agent = createMockAgent('dup-cap-agent', 'testing', ['test', 'test', 'validate']);\n      registry.register(agent);\n      \n      const testAgents = registry.getByCapability('test');\n      expect(testAgents).toHaveLength(1);\n    });\n\n    it('should handle concurrent operations safely', async () => {\n      const operations = [];\n      \n      // Simulate concurrent registrations and searches\n      for (let i = 0; i < 100; i++) {\n        operations.push(\n          Promise.resolve().then(() => {\n            const agent = createMockAgent(`concurrent-${i}`, 'test', [`cap-${i}`]);\n            registry.register(agent);\n            return registry.get(agent.id);\n          })\n        );\n      }\n      \n      const results = await Promise.all(operations);\n      expect(results).toHaveLength(100);\n      expect(results.every(r => r !== undefined)).toBe(true);\n      expect(registry.list()).toHaveLength(100);\n    });\n  });\n});\n"
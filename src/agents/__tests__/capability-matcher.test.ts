import {\n  DefaultCapabilityMatcher,\n  StrictCapabilityMatcher,\n  FuzzyCapabilityMatcher,\n  CapabilityMatcherFactory,\n  CapabilityAnalyzer\n} from '../capability-matcher';\nimport { AgentInstance } from '../../types/agent';\n\ndescribe('DefaultCapabilityMatcher', () => {\n  let matcher: DefaultCapabilityMatcher;\n  let mockAgents: AgentInstance[];\n\n  beforeEach(() => {\n    matcher = new DefaultCapabilityMatcher();\n    \n    // Create mock agents\n    mockAgents = [\n      createMockAgent('test-agent-1', 'testing', ['boundary_testing', 'test_generation']),\n      createMockAgent('security-agent', 'security', ['security_testing', 'vulnerability_assessment']),\n      createMockAgent('performance-agent', 'performance', ['performance_testing', 'load_testing']),\n      createMockAgent('api-agent', 'api', ['api_testing', 'integration_testing', 'boundary_testing'])\n    ];\n  });\n\n  function createMockAgent(name: string, type: string, capabilities: string[]): AgentInstance {\n    return {\n      id: `${name}-id`,\n      name,\n      type,\n      capabilities,\n      tools: new Map(),\n      state: 'initialized',\n      parameters: {},\n      metadata: {},\n      definition: {} as any,\n      initialize: jest.fn(),\n      execute: jest.fn(),\n      setState: jest.fn(),\n      getCapabilities: () => [...capabilities],\n      getTool: jest.fn(),\n      destroy: jest.fn()\n    };\n  }\n\n  describe('findBestAgent', () => {\n    it('should find agent with exact capability match', () => {\n      const bestAgent = matcher.findBestAgent(['boundary_testing'], mockAgents);\n      \n      expect(bestAgent).toBeDefined();\n      expect(bestAgent!.capabilities).toContain('boundary_testing');\n    });\n\n    it('should find agent with multiple capability matches', () => {\n      const bestAgent = matcher.findBestAgent(\n        ['security_testing', 'vulnerability_assessment'],\n        mockAgents\n      );\n      \n      expect(bestAgent?.name).toBe('security-agent');\n    });\n\n    it('should return null for empty agent list', () => {\n      const bestAgent = matcher.findBestAgent(['boundary_testing'], []);\n      \n      expect(bestAgent).toBeNull();\n    });\n\n    it('should return any agent for empty requirements', () => {\n      const bestAgent = matcher.findBestAgent([], mockAgents);\n      \n      expect(bestAgent).toBeDefined();\n      expect(mockAgents).toContain(bestAgent);\n    });\n\n    it('should return null when no capabilities match', () => {\n      const bestAgent = matcher.findBestAgent(['non_existent_capability'], mockAgents);\n      \n      expect(bestAgent).toBeNull();\n    });\n\n    it('should prefer agents with more matching capabilities', () => {\n      // api-agent has both 'api_testing' and 'boundary_testing'\n      const bestAgent = matcher.findBestAgent(\n        ['boundary_testing', 'api_testing'],\n        mockAgents\n      );\n      \n      expect(bestAgent?.name).toBe('api-agent');\n    });\n  });\n\n  describe('scoreAgent', () => {\n    it('should give high score for exact matches', () => {\n      const agent = mockAgents[0]; // has 'boundary_testing'\n      const score = matcher.scoreAgent(agent, ['boundary_testing']);\n      \n      expect(score).toBeGreaterThan(0);\n    });\n\n    it('should give higher score for multiple matches', () => {\n      const agent = mockAgents[0]; // has ['boundary_testing', 'test_generation']\n      const singleScore = matcher.scoreAgent(agent, ['boundary_testing']);\n      const multipleScore = matcher.scoreAgent(agent, ['boundary_testing', 'test_generation']);\n      \n      expect(multipleScore).toBeGreaterThan(singleScore);\n    });\n\n    it('should give zero score for no matches', () => {\n      const agent = mockAgents[0];\n      const score = matcher.scoreAgent(agent, ['non_existent_capability']);\n      \n      expect(score).toBe(0);\n    });\n\n    it('should consider category bonus', () => {\n      const testingAgent = mockAgents[0]; // type: 'testing'\n      const securityAgent = mockAgents[1]; // type: 'security'\n      \n      const testingScore = matcher.scoreAgent(testingAgent, ['testing']);\n      const securityScore = matcher.scoreAgent(securityAgent, ['testing']);\n      \n      // Testing agent should get category bonus for testing-related capability\n      expect(testingScore).toBeGreaterThan(securityScore);\n    });\n  });\n\n  describe('getCapabilityCompatibility', () => {\n    it('should return 1.0 for perfect match', () => {\n      const compatibility = matcher.getCapabilityCompatibility(\n        ['boundary_testing', 'test_generation'],\n        ['boundary_testing', 'test_generation']\n      );\n      \n      expect(compatibility).toBe(1.0);\n    });\n\n    it('should return 0.5 for half match', () => {\n      const compatibility = matcher.getCapabilityCompatibility(\n        ['boundary_testing', 'other_capability'],\n        ['boundary_testing', 'test_generation']\n      );\n      \n      expect(compatibility).toBe(0.5);\n    });\n\n    it('should return 1.0 for empty requirements', () => {\n      const compatibility = matcher.getCapabilityCompatibility(\n        ['boundary_testing'],\n        []\n      );\n      \n      expect(compatibility).toBe(1.0);\n    });\n\n    it('should consider partial matches', () => {\n      const compatibility = matcher.getCapabilityCompatibility(\n        ['testing'],\n        ['boundary_testing'] // partial match\n      );\n      \n      expect(compatibility).toBeGreaterThan(0);\n    });\n  });\n});\n\ndescribe('StrictCapabilityMatcher', () => {\n  let matcher: StrictCapabilityMatcher;\n  let mockAgents: AgentInstance[];\n\n  beforeEach(() => {\n    matcher = new StrictCapabilityMatcher();\n    mockAgents = [\n      createMockAgent('agent1', 'type1', ['cap1', 'cap2']),\n      createMockAgent('agent2', 'type2', ['cap2', 'cap3']),\n      createMockAgent('agent3', 'type3', ['cap1', 'cap2', 'cap3'])\n    ];\n  });\n\n  function createMockAgent(name: string, type: string, capabilities: string[]): AgentInstance {\n    return {\n      id: `${name}-id`,\n      name,\n      type,\n      capabilities,\n      tools: new Map(),\n      state: 'initialized',\n      parameters: {},\n      metadata: {},\n      definition: {} as any,\n      initialize: jest.fn(),\n      execute: jest.fn(),\n      setState: jest.fn(),\n      getCapabilities: () => [...capabilities],\n      getTool: jest.fn(),\n      destroy: jest.fn()\n    };\n  }\n\n  it('should find agent with exact capabilities only', () => {\n    const agent = matcher.findBestAgent(['cap1', 'cap2'], mockAgents);\n    \n    expect(agent).toBeDefined();\n    expect(agent!.capabilities).toContain('cap1');\n    expect(agent!.capabilities).toContain('cap2');\n  });\n\n  it('should return null if no agent has all capabilities', () => {\n    const agent = matcher.findBestAgent(['cap1', 'cap2', 'cap4'], mockAgents);\n    \n    expect(agent).toBeNull();\n  });\n\n  it('should score 100 for exact match, 0 otherwise', () => {\n    const exactAgent = mockAgents[0]; // has ['cap1', 'cap2']\n    const partialAgent = mockAgents[1]; // has ['cap2', 'cap3']\n    \n    const exactScore = matcher.scoreAgent(exactAgent, ['cap1', 'cap2']);\n    const partialScore = matcher.scoreAgent(partialAgent, ['cap1', 'cap2']);\n    \n    expect(exactScore).toBe(100);\n    expect(partialScore).toBe(0);\n  });\n\n  it('should return 1.0 or 0.0 compatibility', () => {\n    const exactCompatibility = matcher.getCapabilityCompatibility(\n      ['cap1', 'cap2'],\n      ['cap1', 'cap2']\n    );\n    const partialCompatibility = matcher.getCapabilityCompatibility(\n      ['cap1', 'cap3'],\n      ['cap1', 'cap2']\n    );\n    \n    expect(exactCompatibility).toBe(1.0);\n    expect(partialCompatibility).toBe(0.0);\n  });\n});\n\ndescribe('FuzzyCapabilityMatcher', () => {\n  let matcher: FuzzyCapabilityMatcher;\n  let mockAgents: AgentInstance[];\n\n  beforeEach(() => {\n    matcher = new FuzzyCapabilityMatcher();\n    mockAgents = [\n      createMockAgent('agent1', 'type1', ['testing', 'validation']),\n      createMockAgent('agent2', 'type2', ['test_generation', 'boundary_testing']),\n      createMockAgent('agent3', 'type3', ['security', 'auth'])\n    ];\n  });\n\n  function createMockAgent(name: string, type: string, capabilities: string[]): AgentInstance {\n    return {\n      id: `${name}-id`,\n      name,\n      type,\n      capabilities,\n      tools: new Map(),\n      state: 'initialized',\n      parameters: {},\n      metadata: {},\n      definition: {} as any,\n      initialize: jest.fn(),\n      execute: jest.fn(),\n      setState: jest.fn(),\n      getCapabilities: () => [...capabilities],\n      getTool: jest.fn(),\n      destroy: jest.fn()\n    };\n  }\n\n  it('should find agent with similar capabilities', () => {\n    // 'test' should match 'testing' with high similarity\n    const agent = matcher.findBestAgent(['test'], mockAgents);\n    \n    expect(agent).toBeDefined();\n    expect(agent!.capabilities.some(cap => cap.includes('test'))).toBe(true);\n  });\n\n  it('should return null if similarity is too low', () => {\n    const agent = matcher.findBestAgent(['completely_different_capability'], mockAgents);\n    \n    // Might return null if similarity threshold not met\n    // This depends on the similarity threshold setting\n    expect(agent).toBeDefined(); // Or could be null based on threshold\n  });\n\n  it('should calculate similarity scores', () => {\n    const agent = mockAgents[0]; // has 'testing'\n    const score = matcher.scoreAgent(agent, ['test']);\n    \n    expect(score).toBeGreaterThan(0);\n    expect(score).toBeLessThanOrEqual(1.0);\n  });\n\n  it('should handle exact matches', () => {\n    const agent = mockAgents[0]; // has 'testing'\n    const score = matcher.scoreAgent(agent, ['testing']);\n    \n    expect(score).toBe(1.0);\n  });\n});\n\ndescribe('CapabilityMatcherFactory', () => {\n  it('should create default matcher', () => {\n    const matcher = CapabilityMatcherFactory.create('default');\n    expect(matcher).toBeInstanceOf(DefaultCapabilityMatcher);\n  });\n\n  it('should create strict matcher', () => {\n    const matcher = CapabilityMatcherFactory.create('strict');\n    expect(matcher).toBeInstanceOf(StrictCapabilityMatcher);\n  });\n\n  it('should create fuzzy matcher', () => {\n    const matcher = CapabilityMatcherFactory.create('fuzzy');\n    expect(matcher).toBeInstanceOf(FuzzyCapabilityMatcher);\n  });\n\n  it('should default to default matcher', () => {\n    const matcher = CapabilityMatcherFactory.create();\n    expect(matcher).toBeInstanceOf(DefaultCapabilityMatcher);\n  });\n});\n\ndescribe('CapabilityAnalyzer', () => {\n  let mockAgents: AgentInstance[];\n\n  beforeEach(() => {\n    mockAgents = [\n      createMockAgent('agent1', 'testing', ['boundary_testing', 'test_generation']),\n      createMockAgent('agent2', 'security', ['security_testing', 'boundary_testing']),\n      createMockAgent('agent3', 'performance', ['performance_testing', 'load_testing'])\n    ];\n  });\n\n  function createMockAgent(name: string, type: string, capabilities: string[]): AgentInstance {\n    return {\n      id: `${name}-id`,\n      name,\n      type,\n      capabilities,\n      tools: new Map(),\n      state: 'initialized',\n      parameters: {},\n      metadata: {},\n      definition: {} as any,\n      initialize: jest.fn(),\n      execute: jest.fn(),\n      setState: jest.fn(),\n      getCapabilities: () => [...capabilities],\n      getTool: jest.fn(),\n      destroy: jest.fn()\n    };\n  }\n\n  describe('analyzeCoverage', () => {\n    it('should analyze capability coverage', () => {\n      const analysis = CapabilityAnalyzer.analyzeCoverage(mockAgents);\n      \n      expect(analysis.totalCapabilities).toBe(5); // unique capabilities\n      expect(analysis.uniqueCapabilities).toContain('boundary_testing');\n      expect(analysis.capabilityFrequency['boundary_testing']).toBe(2); // shared by 2 agents\n      expect(analysis.redundancy['boundary_testing']).toBe(2);\n    });\n\n    it('should handle empty agent list', () => {\n      const analysis = CapabilityAnalyzer.analyzeCoverage([]);\n      \n      expect(analysis.totalCapabilities).toBe(0);\n      expect(analysis.uniqueCapabilities).toEqual([]);\n      expect(Object.keys(analysis.capabilityFrequency)).toHaveLength(0);\n    });\n  });\n\n  describe('suggestTeam', () => {\n    it('should suggest optimal team', () => {\n      const requiredCapabilities = ['boundary_testing', 'security_testing', 'performance_testing'];\n      const suggestion = CapabilityAnalyzer.suggestTeam(requiredCapabilities, mockAgents, 3);\n      \n      expect(suggestion.team.length).toBeGreaterThan(0);\n      expect(suggestion.coverage).toBeGreaterThan(0);\n      expect(suggestion.uncoveredCapabilities.length).toBeLessThanOrEqual(requiredCapabilities.length);\n    });\n\n    it('should respect team size limit', () => {\n      const requiredCapabilities = ['boundary_testing', 'security_testing', 'performance_testing'];\n      const suggestion = CapabilityAnalyzer.suggestTeam(requiredCapabilities, mockAgents, 2);\n      \n      expect(suggestion.team.length).toBeLessThanOrEqual(2);\n    });\n\n    it('should achieve perfect coverage when possible', () => {\n      const requiredCapabilities = ['boundary_testing', 'security_testing'];\n      const suggestion = CapabilityAnalyzer.suggestTeam(requiredCapabilities, mockAgents, 5);\n      \n      expect(suggestion.coverage).toBe(1.0);\n      expect(suggestion.uncoveredCapabilities).toHaveLength(0);\n    });\n\n    it('should handle impossible requirements', () => {\n      const requiredCapabilities = ['non_existent_capability'];\n      const suggestion = CapabilityAnalyzer.suggestTeam(requiredCapabilities, mockAgents, 5);\n      \n      expect(suggestion.coverage).toBe(0);\n      expect(suggestion.uncoveredCapabilities).toEqual(requiredCapabilities);\n    });\n\n    it('should not include duplicate agents', () => {\n      const requiredCapabilities = ['boundary_testing', 'test_generation'];\n      const suggestion = CapabilityAnalyzer.suggestTeam(requiredCapabilities, mockAgents, 5);\n      \n      const agentIds = suggestion.team.map(agent => agent.id);\n      const uniqueIds = [...new Set(agentIds)];\n      expect(agentIds.length).toBe(uniqueIds.length);\n    });\n  });\n});\n\ndescribe('Capability Matching Integration', () => {\n  it('should work with real-world scenarios', () => {\n    const agents = [\n      createMockAgent('boundary-tester', 'testing', [\n        'boundary_testing',\n        'equivalence_partitioning',\n        'test_generation'\n      ]),\n      createMockAgent('security-scanner', 'security', [\n        'security_testing',\n        'vulnerability_assessment',\n        'penetration_testing'\n      ]),\n      createMockAgent('api-validator', 'api', [\n        'api_testing',\n        'integration_testing',\n        'contract_testing',\n        'boundary_testing'\n      ]),\n      createMockAgent('performance-analyzer', 'performance', [\n        'performance_testing',\n        'load_testing',\n        'stress_testing',\n        'benchmarking'\n      ])\n    ];\n\n    const matcher = new DefaultCapabilityMatcher();\n\n    // Test 1: Find agent for boundary testing\n    const boundaryAgent = matcher.findBestAgent(['boundary_testing'], agents);\n    expect(boundaryAgent).toBeDefined();\n    expect(boundaryAgent!.capabilities).toContain('boundary_testing');\n\n    // Test 2: Find agent for API testing with boundary testing\n    const apiAgent = matcher.findBestAgent(['api_testing', 'boundary_testing'], agents);\n    expect(apiAgent?.name).toBe('api-validator'); // Should prefer agent with both capabilities\n\n    // Test 3: Find agent for comprehensive security testing\n    const securityAgent = matcher.findBestAgent([\n      'security_testing',\n      'vulnerability_assessment',\n      'penetration_testing'\n    ], agents);\n    expect(securityAgent?.name).toBe('security-scanner');\n\n    // Test 4: Team suggestion for comprehensive testing\n    const teamSuggestion = CapabilityAnalyzer.suggestTeam([\n      'boundary_testing',\n      'security_testing',\n      'performance_testing',\n      'api_testing'\n    ], agents, 4);\n\n    expect(teamSuggestion.coverage).toBe(1.0); // Should achieve full coverage\n    expect(teamSuggestion.team.length).toBeGreaterThan(0);\n  });\n\n  function createMockAgent(name: string, type: string, capabilities: string[]): AgentInstance {\n    return {\n      id: `${name}-id`,\n      name,\n      type,\n      capabilities,\n      tools: new Map(),\n      state: 'initialized',\n      parameters: {},\n      metadata: {},\n      definition: {} as any,\n      initialize: jest.fn(),\n      execute: jest.fn(),\n      setState: jest.fn(),\n      getCapabilities: () => [...capabilities],\n      getTool: jest.fn(),\n      destroy: jest.fn()\n    };\n  }\n});\n"
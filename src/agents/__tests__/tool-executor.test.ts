import { DefaultToolExecutor } from '../tool-executor';\nimport { Tool, ToolExecutionContext, ToolHandler } from '../../types/agent';\n\ndescribe('DefaultToolExecutor', () => {\n  let toolExecutor: DefaultToolExecutor;\n  let mockContext: ToolExecutionContext;\n\n  beforeEach(() => {\n    toolExecutor = new DefaultToolExecutor();\n    mockContext = {\n      agentId: 'test-agent-id',\n      agentName: 'test-agent',\n      task: 'test task',\n      parameters: {},\n      capabilities: ['boundary_testing', 'test_generation'],\n      metadata: {}\n    };\n  });\n\n  describe('Built-in Tools', () => {\n    it('should have built-in tools registered', () => {\n      const availableTools = toolExecutor.getAvailableTools();\n      \n      expect(availableTools).toContain('boundary_value_analysis');\n      expect(availableTools).toContain('generate_invalid_payloads');\n      expect(availableTools).toContain('fuzz_testing');\n      expect(availableTools).toContain('validate_error_handling');\n    });\n\n    it('should check capability requirements for tools', () => {\n      const canExecuteBoundary = toolExecutor.canExecute('boundary_value_analysis', mockContext);\n      const canExecuteInvalid = toolExecutor.canExecute('non_existent_tool', mockContext);\n      \n      expect(canExecuteBoundary).toBe(true);\n      expect(canExecuteInvalid).toBe(false);\n    });\n\n    it('should deny execution without required capabilities', () => {\n      const contextWithoutCapabilities = {\n        ...mockContext,\n        capabilities: ['unrelated_capability']\n      };\n      \n      const canExecute = toolExecutor.canExecute('boundary_value_analysis', contextWithoutCapabilities);\n      expect(canExecute).toBe(false);\n    });\n  });\n\n  describe('Tool Registration', () => {\n    it('should register custom tools', () => {\n      const customTool: Tool = {\n        name: 'custom_tool',\n        description: 'A custom testing tool',\n        parameters: {\n          input: {\n            type: 'string',\n            description: 'Input parameter'\n          }\n        }\n      };\n\n      const handler: ToolHandler = {\n        execute: jest.fn().mockResolvedValue({ result: 'success' }),\n        validate: jest.fn().mockReturnValue(true)\n      };\n\n      toolExecutor.registerTool(customTool, handler);\n      \n      expect(toolExecutor.getAvailableTools()).toContain('custom_tool');\n    });\n\n    it('should unregister tools', () => {\n      const customTool: Tool = {\n        name: 'temporary_tool',\n        description: 'A temporary tool'\n      };\n\n      const handler: ToolHandler = {\n        execute: jest.fn(),\n        validate: jest.fn().mockReturnValue(true)\n      };\n\n      toolExecutor.registerTool(customTool, handler);\n      expect(toolExecutor.getAvailableTools()).toContain('temporary_tool');\n      \n      toolExecutor.unregisterTool('temporary_tool');\n      expect(toolExecutor.getAvailableTools()).not.toContain('temporary_tool');\n    });\n  });\n\n  describe('Tool Execution', () => {\n    it('should execute boundary value analysis', async () => {\n      const parameters = {\n        field_spec: {\n          name: 'age',\n          type: 'integer',\n          min: 18,\n          max: 120\n        }\n      };\n      \n      const result = await toolExecutor.execute('boundary_value_analysis', parameters, mockContext);\n      \n      expect(result).toBeDefined();\n      expect(result.field).toBe('age');\n      expect(result.test_cases).toBeDefined();\n      expect(result.test_cases.length).toBeGreaterThan(0);\n    });\n\n    it('should execute invalid payload generation', async () => {\n      const parameters = {\n        schema: {\n          type: 'object',\n          properties: {\n            name: { type: 'string', maxLength: 50 },\n            age: { type: 'number', minimum: 0, maximum: 120 }\n          },\n          required: ['name']\n        },\n        mutation_types: ['type_mismatch', 'missing_required']\n      };\n      \n      const result = await toolExecutor.execute('generate_invalid_payloads', parameters, mockContext);\n      \n      expect(result).toBeDefined();\n      expect(result.total_payloads).toBeGreaterThan(0);\n      expect(result.payloads).toBeDefined();\n      expect(Array.isArray(result.payloads)).toBe(true);\n    });\n\n    it('should execute fuzz testing', async () => {\n      const parameters = {\n        base_payload: {\n          name: 'John Doe',\n          age: 25,\n          email: 'john@example.com'\n        },\n        fuzz_level: 'moderate'\n      };\n      \n      const result = await toolExecutor.execute('fuzz_testing', parameters, mockContext);\n      \n      expect(result).toBeDefined();\n      expect(result.fuzz_level).toBe('moderate');\n      expect(result.total_payloads).toBe(10); // moderate level = 10 payloads\n      expect(result.payloads).toBeDefined();\n    });\n\n    it('should execute error handling validation', async () => {\n      const parameters = {\n        error_response: {\n          status: 400,\n          message: 'Bad Request',\n          code: 'INVALID_INPUT',\n          timestamp: new Date().toISOString()\n        },\n        expected_behavior: {\n          status_code: 400\n        }\n      };\n      \n      const result = await toolExecutor.execute('validate_error_handling', parameters, mockContext);\n      \n      expect(result).toBeDefined();\n      expect(result.status_code).toBeDefined();\n      expect(result.error_message).toBeDefined();\n      expect(result.overall_score).toBeDefined();\n    });\n\n    it('should throw error for non-existent tool', async () => {\n      await expect(\n        toolExecutor.execute('non_existent_tool', {}, mockContext)\n      ).rejects.toThrow(/not found/);\n    });\n\n    it('should throw error for insufficient capabilities', async () => {\n      const contextWithoutCapabilities = {\n        ...mockContext,\n        capabilities: []\n      };\n      \n      await expect(\n        toolExecutor.execute('boundary_value_analysis', {}, contextWithoutCapabilities)\n      ).rejects.toThrow(/does not have required capabilities/);\n    });\n\n    it('should validate parameters before execution', async () => {\n      const invalidParameters = {}; // Missing required field_spec\n      \n      await expect(\n        toolExecutor.execute('boundary_value_analysis', invalidParameters, mockContext)\n      ).rejects.toThrow(/Invalid parameters/);\n    });\n  });\n\n  describe('Custom Tool Handler', () => {\n    it('should execute custom tool with handler', async () => {\n      const customTool: Tool = {\n        name: 'math_calculator',\n        description: 'Performs mathematical calculations',\n        parameters: {\n          operation: {\n            type: 'string',\n            description: 'Math operation'\n          },\n          numbers: {\n            type: 'array',\n            description: 'Numbers to operate on'\n          }\n        }\n      };\n\n      const handler: ToolHandler = {\n        async execute(parameters: any, context: ToolExecutionContext): Promise<any> {\n          const { operation, numbers } = parameters;\n          \n          switch (operation) {\n            case 'add':\n              return { result: numbers.reduce((a: number, b: number) => a + b, 0) };\n            case 'multiply':\n              return { result: numbers.reduce((a: number, b: number) => a * b, 1) };\n            default:\n              throw new Error(`Unsupported operation: ${operation}`);\n          }\n        },\n        \n        validate(parameters: any): boolean {\n          return parameters &&\n                 typeof parameters.operation === 'string' &&\n                 Array.isArray(parameters.numbers) &&\n                 parameters.numbers.length > 0;\n        }\n      };\n\n      toolExecutor.registerTool(customTool, handler);\n      \n      const result = await toolExecutor.execute('math_calculator', {\n        operation: 'add',\n        numbers: [1, 2, 3, 4, 5]\n      }, mockContext);\n      \n      expect(result.result).toBe(15);\n    });\n\n    it('should handle tool execution errors gracefully', async () => {\n      const faultyTool: Tool = {\n        name: 'faulty_tool',\n        description: 'A tool that always fails'\n      };\n\n      const faultyHandler: ToolHandler = {\n        async execute(): Promise<any> {\n          throw new Error('Tool execution failed');\n        },\n        validate(): boolean {\n          return true;\n        }\n      };\n\n      toolExecutor.registerTool(faultyTool, faultyHandler);\n      \n      await expect(\n        toolExecutor.execute('faulty_tool', {}, mockContext)\n      ).rejects.toThrow('Tool execution failed');\n    });\n  });\n\n  describe('Boundary Value Analysis Tool', () => {\n    it('should handle string field types', async () => {\n      const parameters = {\n        field_spec: {\n          name: 'username',\n          type: 'string',\n          minLength: 3,\n          maxLength: 20\n        }\n      };\n      \n      const result = await toolExecutor.execute('boundary_value_analysis', parameters, mockContext);\n      \n      expect(result.test_cases).toBeDefined();\n      expect(result.test_cases.some((tc: any) => tc.description.includes('empty'))).toBe(true);\n      expect(result.test_cases.some((tc: any) => tc.description.includes('minimum length'))).toBe(true);\n      expect(result.test_cases.some((tc: any) => tc.description.includes('maximum length'))).toBe(true);\n    });\n\n    it('should handle numeric overflow when requested', async () => {\n      const parameters = {\n        field_spec: {\n          name: 'count',\n          type: 'integer',\n          min: 0,\n          max: 100\n        },\n        include_overflow: true\n      };\n      \n      const result = await toolExecutor.execute('boundary_value_analysis', parameters, mockContext);\n      \n      expect(result.test_cases.some((tc: any) => tc.description.includes('Maximum safe integer'))).toBe(true);\n    });\n  });\n\n  describe('Invalid Payload Generation Tool', () => {\n    it('should generate type mismatch payloads', async () => {\n      const parameters = {\n        schema: {\n          type: 'object',\n          properties: {\n            name: { type: 'string' },\n            age: { type: 'number' }\n          }\n        },\n        mutation_types: ['type_mismatch']\n      };\n      \n      const result = await toolExecutor.execute('generate_invalid_payloads', parameters, mockContext);\n      \n      expect(result.payloads.some((p: any) => \n        p.description.includes('number instead of string')\n      )).toBe(true);\n    });\n\n    it('should generate missing required field payloads', async () => {\n      const parameters = {\n        schema: {\n          type: 'object',\n          properties: {\n            name: { type: 'string' },\n            email: { type: 'string' }\n          },\n          required: ['name', 'email']\n        },\n        mutation_types: ['missing_required']\n      };\n      \n      const result = await toolExecutor.execute('generate_invalid_payloads', parameters, mockContext);\n      \n      expect(result.payloads.length).toBeGreaterThanOrEqual(2); // One for each required field\n      expect(result.payloads.some((p: any) => \n        p.description.includes('Missing required field: name')\n      )).toBe(true);\n    });\n  });\n\n  describe('Fuzz Testing Tool', () => {\n    it('should respect fuzz level intensity', async () => {\n      const basePayload = { name: 'test', value: 42 };\n      \n      const lightResult = await toolExecutor.execute('fuzz_testing', {\n        base_payload: basePayload,\n        fuzz_level: 'light'\n      }, mockContext);\n      \n      const aggressiveResult = await toolExecutor.execute('fuzz_testing', {\n        base_payload: basePayload,\n        fuzz_level: 'aggressive'\n      }, mockContext);\n      \n      expect(lightResult.total_payloads).toBe(5);\n      expect(aggressiveResult.total_payloads).toBe(20);\n    });\n\n    it('should generate diverse fuzzed values', async () => {\n      const parameters = {\n        base_payload: { name: 'original', count: 10 },\n        fuzz_level: 'moderate'\n      };\n      \n      const result = await toolExecutor.execute('fuzz_testing', parameters, mockContext);\n      \n      // Check that at least some payloads are different from the original\n      const hasModifications = result.payloads.some((p: any) => \n        p.payload.name !== 'original' || p.payload.count !== 10\n      );\n      \n      expect(hasModifications).toBe(true);\n    });\n  });\n\n  describe('Error Handling Validation Tool', () => {\n    it('should validate HTTP status codes', async () => {\n      const parameters = {\n        error_response: {\n          status: 404,\n          message: 'Resource not found'\n        },\n        expected_behavior: {\n          status_code: 404\n        }\n      };\n      \n      const result = await toolExecutor.execute('validate_error_handling', parameters, mockContext);\n      \n      expect(result.status_code.score).toBe(1.0); // Perfect match\n    });\n\n    it('should detect security information leakage', async () => {\n      const parameters = {\n        error_response: {\n          status: 500,\n          message: 'Database connection failed: password123 invalid',\n          stack_trace: 'Error in database.js:42'\n        },\n        expected_behavior: {}\n      };\n      \n      const result = await toolExecutor.execute('validate_error_handling', parameters, mockContext);\n      \n      expect(result.security_check.issues.length).toBeGreaterThan(0);\n      expect(result.security_check.score).toBeLessThan(1.0);\n    });\n\n    it('should validate error message quality', async () => {\n      const goodResponse = {\n        error_response: {\n          message: 'The provided email address format is invalid. Please ensure it contains @ symbol and valid domain.'\n        },\n        expected_behavior: {}\n      };\n      \n      const poorResponse = {\n        error_response: {\n          message: 'Error'\n        },\n        expected_behavior: {}\n      };\n      \n      const goodResult = await toolExecutor.execute('validate_error_handling', goodResponse, mockContext);\n      const poorResult = await toolExecutor.execute('validate_error_handling', poorResponse, mockContext);\n      \n      expect(goodResult.error_message.score).toBeGreaterThan(poorResult.error_message.score);\n    });\n  });\n});\n"